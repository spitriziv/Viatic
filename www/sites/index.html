<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<title>Viatic - Welcome</title>
  <meta name="description" img src="image.png" content="The Viatic Website"> 
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="chromelogo.png">
  <link rel="icon" href="https://github.com/spitriziv/Viatic/blob/main/www/image/Viaticlogononame.png?raw=true" type="imageX" sizes="16x16">
  <head>
  <body onload="typeWriter()"></body>
    <!-- ccs -->
    <link rel='stylesheet' href='https://spitriziv.github.io/Viatic/www/css/website.css'>
        <link rel='stylesheet' href='https://spitriziv.github.io/Viatic/www/css/themes.css'>
      <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
      <!-- Javascript-->
          <script src="https://kit.fontawesome.com/38a479c8d7.js" crossorigin="anonymous"></script>
<script src="https://spitriziv.github.io/Viatic/www/js/filter.js"></script>
    <!--other -->
    <link href='https://unpkg.com/boxicons@2.0.7/css/boxicons.min.css' rel='stylesheet'>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
   </head>
   
<body class="w3-animate-left">
  <div class="sidebar close">
    <div class="logo-details">
      <i><img src="https://github.com/spitriziv/Viatic/blob/main/www/image/Viaticlogononame.png?raw=true" alt="" style="width:45px;height:45px;"></i>
      <span class="logo_name">Viatic</span>
    </div>
    <ul class="nav-links">
            <li>
        <a href="https://spitriziv.github.io/Viatic/www/sites/index.html">
          <i class='bx bx-grid-alt'></i>
          <span class="link_name">Dashboard</span>
        </a>
        <ul class="sub-menu blank">
          <li><a class="link_name" href="https://spitriziv.github.io/Viatic/www/sites/index.html">Dashboard</a></li>
        </ul>
      </li>
      <li>
        <div class="iocn-link">
           <a href="https://spitriziv.github.io/Viatic/www/sites/main.html">
            <i class='bx bx-collection' ></i>
          <span class="link_name">Viatic Main</span>
        </a>
        <ul class="sub-menu blank">
          <li><a class="link_name" href="https://spitriziv.github.io/Viatic/www/sites/index.html">Viatic Main</a></li>
        </ul>
      </li>
      
      <li>
        <div class="iocn-link">
          <a href="utilities.html">
            <i class='fas fa-tools' ></i>
            <span class="link_name">Utilities</span>
        </a>
        <ul class="sub-menu blank">
          <li><a class="link_name" href="https://spitriziv.github.io/Viatic/www/sites/utilities.html">Utilities</a></li>
        </ul>
      </li>
      <li>
        <div class="iocn-link">
          <a href="infomation.html">
            <i class='far fa-chart-bar' ></i>
            <span class="link_name">Infomation</span>
          </a>
        <ul class="sub-menu blank">
          <li><a class="link_name">Infomation</a></li>
        </ul>
      </li>
      <li>
        <div class="iocn-link">
          <a href="webdesigns.html">
            <i class='fas fa-pen-alt' ></i>
            <span class="link_name">Web Designs</span>
          </a>
        <ul class="sub-menu blank">
          <li><a class="link_name">Web Designs</a></li>
        </ul>
      </li>
            <li>
        <div class="iocn-link">
          <a href="extradesigns.html">
            <i class='fas fa-ring' ></i>
            <span class="link_name">Extra Designs</span>
          </a>
        <ul class="sub-menu blank">
          <li><a class="link_name">Extra Designs</a></li>
        </ul>
      </li>
      <li>
        <a href="https://spitriziv.github.io/Viatic/www/sites/setting.html">
          <i class='bx bx-cog' ></i>
          <span class="link_name">Settings</span>
        </a>
        <ul class="sub-menu blank">

          <li><a class="link_name" href="https://spitriziv.github.io/Viatic/www/sites/setting.html">Settings</a></li>
        </ul>
      </li>
      <li>
    <div class="profile-details">
      <div class="profile-content">
        <!--<img src="image/profile.jpg" alt="profileImg">-->
      </div>
      <div class="name-job">
        <div class="profile_name">SpiritXIV</div>
        <div class="job">Creator and Desginer</div>
      </div>
      <i><img class="w3-animate-left" src="https://github.com/spitriziv/Viatic/blob/main/www/image/profilenoback.png?raw=true" alt="" style="width:45px;height:45px;"></i>
    </div>
  </li>
</ul>
  </div>
  <section  style="overflow:hidden:" class="home-section">    
</head>
<body class="" id="snow" style="overflow:hidden:">
 <div id="result-iframe-wrap" role="main">

    <iframe id="result" style="position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />
<style>
#canvas, canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <script id=&quot;snoise-function&quot; type=&quot;x-shader/x-vertex&quot;>
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                                0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                                -0.577350269189626,  // -1.0 + 2.0 * C.x
                                0.024390243902439); // 1.0 / 41.0
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v -   i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod289(i); // Avoid truncation effects in permutation
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));

            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m ;
            m = m*m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }
    </script>
    <script id=&quot;vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;>
        uniform float u_time;
        uniform vec2 u_randomisePosition;

        varying float vDistortion;
        varying float xDistortion;
        varying vec2 vUv;

        void main() {
            vUv = uv;
            vDistortion = snoise(vUv.xx * 3. - u_randomisePosition * 0.15);
            xDistortion = snoise(vUv.yy * 1. - u_randomisePosition * 0.05);
            vec3 pos = position;
            pos.z += (vDistortion * 35.);
            pos.x += (xDistortion * 25.);

            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    </script>

    <script id=&quot;fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;>
        
        vec3 rgb(float r, float g, float b) {
            return vec3(r / 255., g / 255., b / 255.);
        }

        vec3 rgb(float c) {
            return vec3(c / 255., c / 255., c / 255.);
        }

        uniform vec3 u_bg;
        uniform vec3 u_bgMain;
        uniform vec3 u_color1;
        uniform vec3 u_color2;
        uniform float u_time;

        varying vec2 vUv;
        varying float vDistortion;

        void main() {
            vec3 bg = rgb(u_bg.r, u_bg.g, u_bg.b);
            vec3 c1 = rgb(u_color1.r, u_color1.g, u_color1.b);
            vec3 c2 = rgb(u_color2.r, u_color2.g, u_color2.b);
            vec3 bgMain = rgb(u_bgMain.r, u_bgMain.g, u_bgMain.b);

            float noise1 = snoise(vUv + u_time * 0.08);
            float noise2 = snoise(vUv * 2. + u_time * 0.1);

            vec3 color = bg;
            color = mix(color, c1, noise1 * 0.6);
            color = mix(color, c2, noise2 * .4);

            color = mix(color, mix(c1, c2, vUv.x), vDistortion);

            float border = smoothstep(0.1, 0.6, vUv.x);

            color = mix(color, bgMain, 1. -border);

            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    <script src=&quot;https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js&quot;></script>

  
      <script id=&quot;rendered-js&quot; type=&quot;module&quot;>
import * as THREE from 'https://cdn.skypack.dev/three@v0.122.0';

function randomInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rgb(r, g, b) {
  return new THREE.Vector3(r, g, b);
}
document.addEventListener(&quot;DOMContentLoaded&quot;, function (e) {

  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

  let vCheck = false;

  camera.position.z = 5;

  var randomisePosition = new THREE.Vector2(1, 2);

  var R = function (x, y, t) {
    return Math.floor(192 + 64 * Math.cos((x * x - y * y) / 300 + t));
  };

  var G = function (x, y, t) {
    return Math.floor(192 + 64 * Math.sin((x * x * Math.cos(t / 4) + y * y * Math.sin(t / 3)) / 300));
  };

  var B = function (x, y, t) {
    return Math.floor(192 + 64 * Math.sin(5 * Math.sin(t / 9) + ((x - 100) * (x - 100) + (y - 100) * (y - 100)) / 1100));
  };
  let sNoise = document.querySelector('#snoise-function').textContent;
  let geometry = new THREE.PlaneGeometry(window.innerWidth / 2, 400, 100, 100);
  let material = new THREE.ShaderMaterial({
    uniforms: {
      u_bg: { type: 'v3', value: rgb(162, 138, 241) },
      u_bgMain: { type: 'v3', value: rgb(162, 138, 241) },
      u_color1: { type: 'v3', value: rgb(162, 138, 241) },
      u_color2: { type: 'v3', value: rgb(82, 31, 241) },
      u_time: { type: 'f', value: 30 },
      u_randomisePosition: { type: 'v2', value: randomisePosition } },

    fragmentShader: sNoise + document.querySelector('#fragment-shader').textContent,
    vertexShader: sNoise + document.querySelector('#vertex-shader').textContent });


  let mesh = new THREE.Mesh(geometry, material);
  mesh.position.set(-200, 270, -280);
  mesh.scale.multiplyScalar(4);
  mesh.rotationX = -1.0;
  mesh.rotationY = 0.0;
  mesh.rotationZ = 0.1;
  scene.add(mesh);

  renderer.render(scene, camera);
  let t = 0;
  let j = 0;
  let x = randomInteger(0, 32);
  let y = randomInteger(0, 32);
  const animate = function () {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
    mesh.material.uniforms.u_randomisePosition.value = new THREE.Vector2(j, j);

    mesh.material.uniforms.u_color1.value = new THREE.Vector3(R(x, y, t / 2), G(x, y, t / 2), B(x, y, t / 2));

    mesh.material.uniforms.u_time.value = t;
    if (t % 0.1 == 0) {
      if (vCheck == false) {
        x -= 1;
        if (x <= 0) {
          vCheck = true;
        }
      } else {
        x += 1;
        if (x >= 32) {
          vCheck = false;
        }

      }
    }

    // Increase t by a certain value every frame
    j = j + 0.01;
    t = t + 0.05;
  };
  animate();

});
//# sourceURL=pen.js
    </script>

  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>
</div>
</body>
</div>
</html>
  
  
  <!--VALENTINE-->
  
      <iframe data-visible-from="02-14" data-visible-to="02-14" style="z-index:0;position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>
  <meta charset=&quot;UTF-8&quot;>
  

    <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

    <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

    <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

    <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />  
  
  
  
<style>
body {
  margin: 0;
  padding: 0;
}

.valentine {
  height: 100vh;
  width: 100%;
  position: fixed;
  background: linear-gradient(313.01deg, #dd5485, #841648 81.14%);
}
.valentine #heart-group-1 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 23% 40% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 76% 57% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 22% 12% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 99% 2% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 53% 42% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 47% 14% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 90% 58% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 29% 77% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(12px);
  z-index: 10;
  position: absolute;
  transform: translateY(-100%);
  animation: drop linear 17s 2s infinite;
}
.valentine #heart-group-2 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-4.svg?alt=media&amp;token=a9aca079-9b66-4d27-83fa-a2cbf4f97df8) 17% 60% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-4.svg?alt=media&amp;token=a9aca079-9b66-4d27-83fa-a2cbf4f97df8) 32% 39% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-4.svg?alt=media&amp;token=a9aca079-9b66-4d27-83fa-a2cbf4f97df8) 95% 90% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(5px);
  z-index: 20;
  position: absolute;
  transform: translateY(-100%);
  animation: drop linear 14s 0s infinite;
}
.valentine #heart-group-3 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-2.svg?alt=media&amp;token=e542fc9c-87de-4817-a42e-3a23c42e9e92) 38% 96% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-2.svg?alt=media&amp;token=e542fc9c-87de-4817-a42e-3a23c42e9e92) 31% 98% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-2.svg?alt=media&amp;token=e542fc9c-87de-4817-a42e-3a23c42e9e92) 73% 36% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(3px);
  z-index: 30;
  position: absolute;
  transform: translateY(-100%);
  animation: drop linear 12s 1s infinite;
}
.valentine #heart-group-4 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 8% 94% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 59% 64% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-1.svg?alt=media&amp;token=c8ee973c-fd7a-4b18-b7cf-fd260962768c) 94% 80% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(2px);
  z-index: 40;
  position: absolute;
  transform: translateY(-100%);
  animation: drop linear 10s 1s infinite;
}
.valentine #heart-group-5 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-5.svg?alt=media&amp;token=71ca3b0c-8715-4484-92e7-b027edd71631) 95% 54% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-5.svg?alt=media&amp;token=71ca3b0c-8715-4484-92e7-b027edd71631) 8% 11% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-5.svg?alt=media&amp;token=71ca3b0c-8715-4484-92e7-b027edd71631) 26% 5% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-5.svg?alt=media&amp;token=71ca3b0c-8715-4484-92e7-b027edd71631) 75% 28% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(1px);
  z-index: 50;
  position: absolute;
  transform: translateY(-100%);
  animation: drop linear 8s 0s infinite;
}
.valentine #star-group-1 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 60% 42% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 86% 89% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 57% 33% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 4% 69% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 13% 72% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star.svg?alt=media&amp;token=0b693d8e-e569-4567-8827-10f8c25dbbdd) 87% 12% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(0px);
  z-index: 60;
  position: absolute;
  transform: translateY(0%);
  animation: glitter linear 1.8s 0s infinite;
}
.valentine #star-group-2 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 31% 80% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 83% 20% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 75% 97% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 42% 15% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 38% 72% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-sm.svg?alt=media&amp;token=13e65b1f-d181-4266-ac34-97485789e1af) 21% 79% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(0px);
  z-index: 60;
  position: absolute;
  transform: translateY(0%);
  animation: glitter linear 1s 0s infinite;
}
.valentine #star-group-3 {
  background: url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 100% 2% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 83% 26% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 91% 63% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 73% 28% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 21% 25% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 67% 2% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 48% 37% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 61% 31% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 92% 97% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 4% 71% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 29% 34% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 16% 77% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 15% 37% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 100% 63% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 31% 75% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 13% 88% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 3% 90% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 6% 55% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 36% 92% no-repeat, url(https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fglitter-star-xs.svg?alt=media&amp;token=0516d117-d8c2-4c0e-b0f8-e468b33ede05) 73% 37% no-repeat;
  height: 100vh;
  width: 100%;
  filter: blur(0px);
  z-index: 60;
  position: absolute;
  transform: translateY(0%);
  animation: glitter linear 1.9s 0s infinite;
}
.valentine .heart-fixed {
  position: fixed;
  height: 100%;
  width: 100%;
}
.valentine .heart-lg {
  background: url(&quot;https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-lg.svg?alt=media&amp;token=aabe9399-f03f-44de-9b55-99025b2981a3&quot;) no-repeat;
  height: 389px;
  width: 438px;
  top: 50%;
  left: -2%;
  transform: rotate(299deg);
  filter: blur(1px);
  z-index: 45;
}
.valentine .heart-sm {
  background: url(&quot;https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-sm.svg?alt=media&amp;token=2750292c-92fd-41de-8e1d-d8814119a602&quot;) no-repeat;
  height: 264px;
  width: 299px;
  top: 30%;
  left: 65%;
  transform: rotate(45deg);
  filter: blur(7px);
  z-index: 15;
}
.valentine .heart-xs {
  background: url(&quot;https://firebasestorage.googleapis.com/v0/b/codepen-asset.appspot.com/o/valentine-animation%2Fheart-xs-2.svg?alt=media&amp;token=e542fc9c-87de-4817-a42e-3a23c42e9e92&quot;) no-repeat;
  height: 87px;
  width: 89px;
  top: 10%;
  left: 30%;
  transform: rotate(299deg);
  filter: blur(3px);
  z-index: 35;
}
.valentine .overlay {
  background-color: white;
  height: 100vh;
  opacity: 0.23;
  width: 100vw;
  position: absolute;
  z-index: 100;
}

@keyframes drop {
  from {
    transform: translateY(-100%);
  }
  to {
    transform: translateY(100%);
  }
}
@keyframes glitter {
  0% {
    opacity: 0;
  }
  70% {
    opacity: 0.4;
  }
  100% {
    opacity: 0;
  }
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
</head>

<body translate=&quot;no&quot;>
  <div class=&quot;valentine&quot;>
  <div id=&quot;heart-group-1&quot;></div>
  <div id=&quot;heart-group-2&quot;></div>
  <div id=&quot;heart-group-3&quot;></div>
  <div id=&quot;heart-group-4&quot;></div>
  <div id=&quot;star-group-1&quot;></div>
  <div id=&quot;star-group-2&quot;></div>
  <div id=&quot;star-group-3&quot;></div>
  <div class=&quot;heart-fixed heart-xs&quot;></div>
  <div class=&quot;heart-fixed heart-sm&quot;></div>
  <div class=&quot;heart-fixed heart-lg&quot;></div>
  <div class=&quot;overlay&quot;></div>
</div>
    <script src=&quot;https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js&quot;></script>

  
      <script id=&quot;rendered-js&quot; >
&quot;use strict&quot;;
//# sourceURL=pen.js
    </script>

  
</body>

</html>" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>
  </div> 
  
 <div id="result-iframe-wrap" role="main">
      
<!--EASTER-->	 
	  <div id="result-iframe-wrap" role="main">

    <iframe data-visible-from="03-25" data-visible-to="04-20" style="z-index:0;position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />


  
  <title>CodePen - Easter island v4</title>
  
  
  
  
<style>
html, body{
margin:0;
padding:0;
width:100%;
height:100%;
overflow:hidden;
}
body{
background:#e0e0e0;
}
h1, h2{
cursor:default;
position:absolute;
left:25px;
font-family:&quot;Lucida Sans Unicode&quot;, &quot;Lucida Grande&quot;, sans-serif;
}
h2{
top:10px;
font-size:20px;
color:white;
opacity:.7;
}
.vnumber{
font-size:15px;
}
#clock{
font-family:&quot;Lucida Sans Unicode&quot;, &quot;Lucida Grande&quot;, sans-serif;
position:absolute;
font-size:0px;
color:white;
bottom:10px;
right:25px;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <canvas id=&quot;c&quot; style=&quot;width:100%;height:100%;&quot;></canvas>
<div id=&quot;clock&quot;></div>



<script id=&quot;2d-vertex-shader-particles&quot; type=&quot;x-shader/x-vertex&quot;>

precision highp float;
precision highp int;

// vertex shader inputs:
attribute vec3  aVertexPosition;      //these are the coordinates of the vertices -> x,y,z
attribute vec3  aParticleInitPosition;
attribute float aParticleVelocity;
attribute float aParticleType;
attribute vec3  aParticleDestination;
attribute vec3  aParticleTranslation; //x,y,z translations are applied to each vertex to move entities around the world (Daft Punk)
attribute float aParticleLifetime;
attribute vec4  aParticleColor;

uniform mat4 uMVMatrix; //model view matrix        -> rotations
uniform mat4 uPMatrix;  //camera projection matrix -> perspective
uniform vec3 uCameraTranslation; //the x, y, z coordinates of the camera are added to each vertex
uniform float uTimeDelta;
uniform float uDelta;
uniform float uRainDelta;
varying float vParticleType;
//varying float vParticleOpacity;
varying vec4  vParticleColor;
varying vec3  vLightWeighting;

uniform vec3 uPointLighting1Location; //the x,y,z position of our first light point
uniform vec3 uPointLighting2Location; //the x,y,z position of our second light point
// global ambient light
// setting it to 1.0.1.0.1.0 we have full lighting
// setting it to 0.0.0.0.0.0 will have light only from the point light
uniform highp vec3 uAmbientLightColorIntensity;
uniform highp vec3 uAmbientLightColor; //the color of the ambient light, controls the color of all sprites globally

//https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner
float hashRand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
float hashRand(float o){
  vec2 co=vec2(o,o);
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
float hashRand(float o, float o2){
  vec2 co=vec2(o,o2);
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void main(void){

  vParticleType=aParticleType; //pass particle type to fragment
  vec3 mumu=aParticleTranslation;
  vParticleColor=aParticleColor;

  if (aParticleType<0.9){ //raindrops
    vParticleColor.a=0.6;

    //by adding the camera y position to the particles we can fill the screen regardless of the height at which we are

    float localTimeDelta=mod(uTimeDelta*aParticleVelocity,aParticleInitPosition.y); //since 0 is in the center of the screen
    vec3 particleMovement=vec3(uCameraTranslation.x-8.0,-localTimeDelta+aParticleInitPosition.y+uCameraTranslation.y-3.0,uCameraTranslation.z-25.0);
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition+aParticleTranslation+particleMovement-uCameraTranslation,1.0);
  }

  if (aParticleType>0.9 &amp;&amp; aParticleType<1.9){ //raindrop collisions on terrain
    float localTimeDelta=0.0;
    float velocity=1.0;
    if (aParticleVelocity!=0.0)
      velocity=aParticleVelocity;
    if (aParticleLifetime>0.0){
      localTimeDelta=mod(uTimeDelta,1.0/velocity)/(1.0/velocity);
    }

    vec3 particleMovement=mix(aParticleInitPosition,aParticleDestination,mod(localTimeDelta,aParticleLifetime));
    float distance=aParticleDestination.x-aParticleInitPosition.x;
    if (distance!=0.0){

      particleMovement.y=sin(mix(0.0,6.28,(particleMovement.x-aParticleInitPosition.x)/distance))/380.0;
    }

    float randValue=floor(uTimeDelta*velocity);
    particleMovement.z=hashRand(vec2(randValue,randValue));
    particleMovement.x=hashRand(vec2(randValue,randValue));
    //2018-09-24 12:29:48
    //raindrops y offset ++
    particleMovement+=vec3(uCameraTranslation.x-8.0,0.2,uCameraTranslation.z-16.0);
    vParticleColor.a=1.0-localTimeDelta;

    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition+aParticleTranslation+particleMovement-uCameraTranslation,1.0);
  }

  if (aParticleType>1.9 &amp;&amp; aParticleType<2.9){ //raindrop collisions on entities

    float slowNess=1.0;
    if (aParticleVelocity!=0.0)
      slowNess=aParticleVelocity;
    float speedDelta=slowNess*uDelta;
    float ms=mod(uTimeDelta,speedDelta);
    float norm=ms/speedDelta;
    float breathDeformLimit=aParticleLifetime;
    ms=sin(norm*6.2831852)*breathDeformLimit;

    vec3 entityMovement=aParticleInitPosition;
    float particleVelocity=aParticleDestination.x;
    float attachedEntityBehavior=aParticleDestination.y;
    float entityIsFloatingOnWater=aParticleDestination.z;
    float particleSpeedDelta=particleVelocity*uDelta; //float particleSpeedDelta=0.01*uDelta;
    float particleMs=mod(uTimeDelta,particleSpeedDelta);
    float particleNorm=particleMs/particleSpeedDelta;
    if (attachedEntityBehavior>1.9){
      //living being
      entityMovement.xy-=ms;
      entityMovement.y+=sin(particleNorm*6.2831852)*breathDeformLimit/7.5;
    }else{
      //vegetation
      entityMovement.x-=ms;
      entityMovement.y+=sin(particleNorm*6.2831852)*breathDeformLimit/8.0;
    }
    if (entityIsFloatingOnWater>0.9){ //add vertical movement to particle to match floating on water movement

      //WIRED G9YjdnHuAK
      float onWaterYMovementSlowness=0.3;
      float onWaterYMovementDistance=0.05;
      float ms2=mod(uTimeDelta,onWaterYMovementSlowness*uDelta);
      float norm2=ms2/(onWaterYMovementSlowness*uDelta);
      ms2=sin(norm2*6.2831852)*onWaterYMovementDistance;
      entityMovement.y+=ms2;
    }
    float xTranslation=entityMovement.x;

    vec3 particleMovement=vec3(xTranslation,entityMovement.y,0.0);

    if (vParticleColor.a<2.0)
      vParticleColor.a=mix(0.0,1.0-particleNorm,uRainDelta);
    else
      vParticleColor.a=1.0;

    //add random x component, particleNorm
    float randValue=floor(uTimeDelta/particleSpeedDelta);
    particleMovement.x=(entityMovement.x+hashRand(vec2(randValue,randValue))/20.0)+(mix(0.0,hashRand(-randValue,randValue),particleNorm)/20.0);

    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition+aParticleTranslation+particleMovement-uCameraTranslation,1.0);
  }

  //add light to particles
  vec3 pointLighting1ColorIntensity=vec3(1.0,1.0,1.0);//light color intensity of point light 1 (sun)
  vec3 pointLighting2ColorIntensity=vec3(0.5,0.5,0.6);//light color intensity of point light 2 (moon) a little bluish
  //we must determine the direction of the light:
  vec3 vectorNormal=vec3(0.0,1.0,0.0); //in our simple geometry just consider a fixed normal
  vec3 light1Direction = normalize(uPointLighting1Location  - aVertexPosition);
  vec3 light2Direction = normalize(uPointLighting2Location - aVertexPosition);

  float directionalLight1Weighting = max(dot(vectorNormal, light1Direction), 0.0);
  float directionalLight2Weighting = max(dot(vectorNormal, light2Direction), 0.0);

  vec3 sunWhiteLight  = pointLighting1ColorIntensity
                        * directionalLight1Weighting; //  * uAmbientLightColor -> do not consider ambient color for rain
  vec3 moonWhiteLight = pointLighting2ColorIntensity
                        * directionalLight2Weighting; //  * uAmbientLightColor -> do not consider ambient color for rain

  //our world has two mobile points of light in total
  vLightWeighting = uAmbientLightColorIntensity + sunWhiteLight  * vParticleColor.xyz; //sunlight
  vLightWeighting+= uAmbientLightColorIntensity + moonWhiteLight * vParticleColor.xyz; //moonlight

}

</script>

<script id=&quot;2d-fragment-shader-particles&quot; type=&quot;x-shader/x-fragment&quot;>
precision highp float;
precision highp int;
varying float vParticleType;
//varying float vParticleOpacity;
varying vec4  vParticleColor;
varying vec3  vLightWeighting;

void main(void){

  gl_FragColor = vParticleColor*vec4(vLightWeighting*2.0,1.0);

}
</script>

<script id=&quot;2d-vertex-shader&quot; type=&quot;x-shader/x-vertex&quot;>
//proc 3d DOC {violet bold}
//
// 3d coordinate system used on sebastian.it
//
//
//              +Y
//               |
//          e    |
//         n     |
//        a      |     XY - plane
//       l       |
//      p        |
//     /         |
//    ZY         /------------------+X
//              /
//             /       ZX - plane
//            /
//          +Z

// In our world all graphic objects are represented by a quadrilateral polygon.
// Each polygon is composed of two triangles and therefore has 6 vertices (a, b, c; d, e, f).
// Each vertex is composed of three X,Y,Z coordinates (aX,aY,aZ, bX,bY,bZ ... fX,fY,fZ).
//
//   a           d    e
//   |\          ------
//   | \          \   |
//   |  \          \  |
//   |   \          \ |
//   ------          \|
//   b    c           f
//
// Each polygon has a texture assigned to the vertices of the triangles that compose it.
// Since the texture has no depth it has only two coordinates per vertex.
//
// In our simplified 3d world there are two types of geometric objects:
// - the tiles &quot;T&quot;, which make up the terrain of the world and are considered fixed.
// - the entities &quot;E&quot;, which represent everything else and which are generally dynamic objects.
//

// NOTE
// A graphical feature that differentiates between tiles and entities
// is the method by which they are drawn. The tiles do not have any kind of
// transparency while the entities do.
// This distinction has a weight in webgl since it forces us to
// manually manage the z-order when we draw objects that need alpha-blending
// as it is necessary to disable the depth buffer by using the following statement
// gl.depthMask (false)

// The tiles make up the ground and are drawn parallel to the ZX plane,
// entities are generally drawn parallel to the XY plane except in some cases.
// For example, the following entities are drawn parallel to the ZX plane:
// - water
// - nymphaea
//
// Here is an &quot;excellent&quot; representation of what has been said:
//               ._____.
//               |     |
//      ------   |  E  |
//     /  T  /   |_____|
//    /_____/
//
//
// TEXTURES
// ref: https://open.gl/textures
//
// The coordinates of the textures follow the opengl logic
// in which the coordinates are normalized in the range 0.0-1.0
//
// The pixels in the texture are addressed using texture coordinates
// during drawing operations.
// 0,0 is conventionally the bottom-left corner
// 1,1 is the top-right corner of the texture image
//
//
// 0.0 1.0        1.0 1.0
//    .______________.
//    |              |
//    |              |
//    |              |
//    |              |
//    |              |
//    |              |
//    |______________|
// 0.0 0.0        1.0 0.0
//
//
// To avoid confusion with the X,Y coordinates of the vertices,
// by convention the coordinates of the textures are referenced
// with the parameters S and T.
//
// This is how the polygons are represented in our code:
// Tile &quot;T&quot; - ZX plane
// Since the texture follows the order of the vertices of the triangles
// we arrange the coordinates S and T according to the current vertex:
//
// vertices        name  buffer_index  texture_coords  name
// X    Y    Z                         S    T
// 0.0  0.0  0.0   a     0, 1, 2       0.0  1.0        A
// 0.0  0.0  1.0   b     3, 4, 5       0.0  0.0        B
// 1.0  0.0  1.0   c     6, 7, 8       1.0  0.0        C
//
// 0.0  0.0  0.0   d     9,10,11       0.0  1.0        D
// 1.0  0.0  0.0   e     12,13,14      1.0  1.0        E
// 1.0  0.0  1.0   f     15,16,17      1.0  0.0        F
//
//
//              +Y
//               |
//          e    |
//         n     |
//        a      |
//       l       |
//      p        |
//     /         |
//    ZY       aA,dD---------eE----+X
//              /\          /
//             /  \        /
//            /    \      /
//           /      \    /
//          /        \  /
//         /__________\/
//        /bB        cC,fF
//       /
//     +Z
//
//
//entity &quot;E&quot; - XY plane
//
// vertices        name  buffer_index  texture_coords  name
// X    Y    Z                         S    T
// 0.0  1.0  0.0   a     0, 1, 2       0.0  1.0        A
// 0.0  0.0  0.0   b     3, 4, 5       0.0  0.0        B
// 1.0  0.0  0.0   c     6, 7, 8       1.0  0.0        C
//
// 0.0  1.0  0.0   d     9,10,11       0.0  1.0        D
// 1.0  1.0  0.0   e     12,13,14      1.0  1.0        E
// 1.0  0.0  0.0   f     15,16,17      1.0  0.0        F
//
//
//              +Y
//               |
//              aA,dD--------eE
//               |\          |
//               | \         |
//               |  \        |
//               |   \       |
//               |    \      |
//          e    |     \     |
//         n     |      \    |
//        a      |       \   |
//       l       |        \  |
//      p        |         \ |
//     /         |          \|
//    ZY       bB-----------cC,fF-----+X
//              /
//             /
//            /
//           /
//          /
//        +Z
//
//
// and I would say that for today I have done enough ASCII art.
//
//
//
//--------------------------------------------------------------------------

//For our simple world lowp precision is enough
//2018-05-15 16:27:53, switching to highp for full compatibility.
//lowp is good for desktop but leads to numeric approximation errors on mobile browsers.

precision highp float;
precision highp int;

// vertex shader inputs:
attribute vec3 aVertexPosition;    //these are the coordinates of the vertices -> x,y,z
attribute vec2 aTextureCoord;      //s,t textures coords for each vertext
attribute vec3 aEntityTranslation; //x,y,z translations are applied to each vertex to move entities around the world (Daft Punk)
attribute vec4 aEntityColor;       //r,g,b,a colors for every vertex

attribute vec4 aEntityProperties;
// [0]=entity current texture normalized x0 coordinate (used for x fliping)
// [1]=texture_atlas_layer_index
// [2]=entity current texture normalized x1 coordinate (used for x fliping)
// since apparently openl gl 3.0 is required for bitwise operations ....
// [3]=poor man's fast bitwise -> 'packed' combined mutual exclusive properties
//     bool hasShadowMitigation (generally clouds and other types of objects in the sky)
//     bool isLightEmitter (sun, moon)
//     bool isFlippedX  (flip entity around y axis)

uniform mat4  uMVMatrix; //model view matrix        -> rotations
uniform mat4  uPMatrix;  //camera projection matrix -> perspective

uniform vec3 uCameraTranslation; //the x, y, z coordinates of the camera are added to each vertex

uniform vec3 uPointLighting1Location; //the x,y,z position of our first light point
uniform vec3 uPointLighting2Location; //the x,y,z position of our second light point

// global ambient light
// setting it to 1.0.1.0.1.0 we have full lighting
// setting it to 0.0.0.0.0.0 will have light only from the point light
uniform highp vec3 uAmbientLightColorIntensity;
uniform highp vec3 uAmbientLightColor; //the color of the ambient light, controls the color of all sprites globally

varying vec2  vTextureCoord;
varying vec3  vLightWeighting;
varying vec3  vLightWeightingWhiteLight;
varying float vTextureAlpha;
varying float vTextureLayerIndex;

void main(void){

  vec3 pointLighting1ColorIntensity=vec3(1.0,1.0,1.0);//light color intensity of point light 1 (sun)
  vec3 pointLighting2ColorIntensity=vec3(0.5,0.5,0.6);//light color intensity of point light 2 (moon) a little bluish

  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition+aEntityTranslation-uCameraTranslation,1.0);
  vTextureCoord = aTextureCoord;

  vTextureAlpha       =aEntityColor.a;
  vTextureLayerIndex  =aEntityProperties[1];
  float combinedProperties=aEntityProperties[3];
                           //1
  bool hasShadowMitigation=((combinedProperties>0.9 &amp;&amp; combinedProperties<1.9)); //clouds
                           //10
  bool isLightEmitter     =(combinedProperties>9.9 &amp;&amp; combinedProperties<10.9);  //stars and satellites
                           //20
  bool isFlippedX         =(combinedProperties>19.9);                            //entities

  if (isFlippedX){
    //aEntityProperties receives at aEntityProperties[0]
    //the normalized x coordinate of the texture from the texture atlas
    //and aEntityProperties[0] the normalized x1 coordinates (x + width) of the texture
    vTextureCoord.x = aEntityProperties[2]-aTextureCoord.x+aEntityProperties[0];
  }

  vec3 pointLighting1Location=uPointLighting1Location;
  vec3 pointLighting2Location=uPointLighting2Location;
  if (hasShadowMitigation){
    //Let's raise the light for the current entity more than the rest,
    //this allows us to have illuminated objects on the sky while the others are not
    pointLighting1Location[1]+=100.0;  //sun light
    pointLighting2Location[1]+=20.0;   //moon light
  }

  if (!isLightEmitter){
    //the entity does not emit its own light

    //we must determine the direction of the light:
    vec3 vectorNormal=vec3(0.0,1.0,0.0); //in our simple geometry just consider a fixed normal
    vec3 light1Direction = normalize(pointLighting1Location - aEntityTranslation - aVertexPosition);
    vec3 light2Direction = normalize(pointLighting2Location - aEntityTranslation - aVertexPosition);

    float directionalLight1Weighting = max(dot(vectorNormal, light1Direction), 0.0);
    float directionalLight2Weighting = max(dot(vectorNormal, light2Direction), 0.0);

    vec3 sunWhiteLight  = pointLighting1ColorIntensity
                          * directionalLight1Weighting * (uAmbientLightColor+0.1);
    //+0.1 explained ->
    //give a little shove to the color to have white <-> #fffff during zenith

    vec3 moonWhiteLight = pointLighting2ColorIntensity
                          * directionalLight2Weighting * uAmbientLightColor;

    //our world has two mobile points of light in total
    vLightWeighting = uAmbientLightColorIntensity + sunWhiteLight  * aEntityColor.xyz; //sunlight
    vLightWeighting+= uAmbientLightColorIntensity + moonWhiteLight * aEntityColor.xyz; //moonlight

    //----
    //we repeat the above calculations but without taking into
    //account the color of the entity. This will give us a white
    //light that we can use to manage the 'neutral' pixels of
    //the entity in the fragment shader that will not have
    //to undergo color alterations (such as the eyes).

    vLightWeightingWhiteLight = uAmbientLightColorIntensity + sunWhiteLight;
    vLightWeightingWhiteLight+= uAmbientLightColorIntensity + moonWhiteLight;

  }else{
    //if the entity emits light do not apply color variation
    vLightWeighting=vec3(1.0,1.0,1.0);
  }

}
</script>

<script id=&quot;2d-fragment-shader&quot; type=&quot;x-shader/x-fragment&quot;>
precision highp float;
precision highp int;

//our textures
//instead of using a texture array that requires an extension
//we select the texture atlas layer by using a variable.
//It is not the most efficient thing in the world but it works
//and for our little world is enough.
//about tiling+texture atlas
//----
//the texture bleeding phenomenon is 'solved'
//by an appropriate drawing method during the texture atlas generation

uniform sampler2D uTextureSampler0; //ref: https://www.khronos.org/opengl/wiki/Sampler_(GLSL)
uniform sampler2D uTextureSampler1;
uniform sampler2D uTextureSampler2;
uniform sampler2D uTextureSampler3;
uniform sampler2D uTextureSampler4;
uniform sampler2D uTextureSampler5;
uniform sampler2D uTextureSampler6;
uniform sampler2D uTextureSampler7;
//2018-04-02 15:54:41 - in the tests I did on mobile it seems that there are problems beyond the 8 textures

//the texCoords passed in from the vertex shader.
//gluniform doc -> ref: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glUniform.xhtml
varying vec2  vTextureCoord;
varying vec3  vLightWeighting;
varying vec3  vLightWeightingWhiteLight;
varying float vTextureAlpha;
varying float vTextureLayerIndex;
uniform float uRainDelta;
//float rainDelta=1.0;

void main(void){

  vec4 color;

  // We use a float range to determine the layer
  // and not a specific number to allow correct management on mobile browsers

  if (vTextureLayerIndex==0.0)                               //select atlas 0
    color=texture2D(uTextureSampler0,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>0.9 &amp;&amp; vTextureLayerIndex<1.9) //atlas 1
    color=texture2D(uTextureSampler1,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>1.9 &amp;&amp; vTextureLayerIndex<2.9) //atlas 2
    color=texture2D(uTextureSampler2,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>2.9 &amp;&amp; vTextureLayerIndex<3.9) //atlas 3
    color=texture2D(uTextureSampler3,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>3.9 &amp;&amp; vTextureLayerIndex<4.9) //atlas 4
    color=texture2D(uTextureSampler4,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>4.9 &amp;&amp; vTextureLayerIndex<5.9) //atlas 5
    color=texture2D(uTextureSampler5,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>5.9 &amp;&amp; vTextureLayerIndex<6.9) //atlas 6
    color=texture2D(uTextureSampler6,vec2(vTextureCoord.s,vTextureCoord.t));
  else if (vTextureLayerIndex>6.9 &amp;&amp; vTextureLayerIndex<7.9) //atlas 7
    color=texture2D(uTextureSampler7,vec2(vTextureCoord.s,vTextureCoord.t));

  vec3 LightWeighting;
  vec3 fragColor;

  //2018-05-04 15:39:04
  //with the following IF we choose the RED color (used as a mask) in a fairly aprox way,
  // We use a color mask to be able to color the eyes of the entities with white light
  // and the rest of the body with the color of the sprite
  if (color.r>.1 &amp;&amp; color.g<.05 &amp;&amp; color.b<.05){
    float resetRed=color.r+color.g+color.b;
    vec3  colorGray=vec3(resetRed,resetRed,resetRed);
    fragColor=colorGray.rgb;
    LightWeighting=vLightWeightingWhiteLight;
    //gl_FragColor = vec4(colorGray.rgb*vLightWeightingWhiteLight,vTextureAlpha*color.a);
  }else{

    fragColor=color.rgb;
    LightWeighting=vLightWeighting;

  }

  if (uRainDelta>0.0){
    //fade light color
    float gray=(LightWeighting.r+LightWeighting.g+LightWeighting.b)/3.0;
    float r=mix(LightWeighting.r,gray,uRainDelta);
    float g=mix(LightWeighting.g,gray,uRainDelta);
    float b=mix(LightWeighting.b,gray,uRainDelta);
    LightWeighting=vec3(r,g,b);

    //fade entity color
    gray=(fragColor.r+fragColor.g+fragColor.b)/3.0;
    r=mix(fragColor.r,gray,uRainDelta);
    g=mix(fragColor.g,gray,uRainDelta);
    b=mix(fragColor.b,gray,uRainDelta);
    fragColor=vec3(r,g,b);
  }

  gl_FragColor = vec4(fragColor*LightWeighting,vTextureAlpha*color.a);

}
</script>
    <script src=&quot;https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js&quot;></script>

  <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/sebastian.glmatrix.js'></script>
      <script id=&quot;rendered-js&quot; >
const SEBASTIAN = { //proc SEBASTIAN
  GLOBALS: { //proc GLOBALS {orange indent_1}
    firstDraw: 1,
    timeDelta: 0, //proc particles
    fps: 30, //orginal value: 1000 - number of frames rendered per second, the higher the number the greater the cpu usage
    maxHandledTextures: 8, //8 seems the max number suitable for mobile. if increased, fragment shader code modifications are required iON2D2Js0y
    maxTextureAtlasWidth: 4096, //4096 tested on on iPhone 6 and Android
    maxTextureAtlasHeight: 4096,
    m3d: null, //mouse 3d coordinates from 2d position
    mx: 0, //actual mouse coord and prev mouse coords
    my: 0,
    mb: null, //mouse button pressed or released
    oMx: null, //detect mouse movement
    oMy: null,

    //time
    hours: null,
    minutes: null,

    //entities idx counter
    idx: 0,

    loadedAssets: 0, //texture loader index
    //pressed keys
    keys: [],
    keysUp: [],
    //frame control
    lastTime: window.performance.now(),
    //color mapping and time travel
    lastTimeKey: null,
    debugLightColors: 1,
    timeTravel: 0,
    //proc camera keypoints {indent_3}
    cameraKeyPoints: [
    //birds
    {
      xPos: 16.459999999999965, yPos: 34.05000000000035, zPos: 11.139999999999791, pitch: 0, yaw: 0 },

    { //snails
      xPos: 10.059999999999981, yPos: 0.5100000000001518, zPos: 20.38999999999983, pitch: -0.5, yaw: 0 },

    { //grumpy frog
      xPos: 24.660000000000082, yPos: 0.4899999999999314, zPos: 25.7199999999999, pitch: 0, yaw: 0 },

    { //mushrooms
      xPos: 13.809999999999901, yPos: 0.5100000000001518, zPos: 18.439999999999756, pitch: -0.5, yaw: 0 },

    { //drutts
      xPos: 26.620000000000257, yPos: 0.5100000000001518, zPos: 21.349999999999866, pitch: -0.5, yaw: 0 },

    { //moais
      xPos: 38.260000000000694, yPos: 1.1100000000001522, zPos: 24.86, pitch: -0.5, yaw: 0 }],




    cameraKeyPoinstIndex: 0,
    //map Editor
    editorConsoleIsVisible: 1,
    tilesColorPool: ['C5', 'C1', 'C3', 'C2', 'C4', 'B1', 'B2', 'B3'],
    tilesColorPoolIdx: 0,
    tilesBusyList: {},
    //tile blob editor
    mapEntityGroups: [
    'water2', 'water2_tiled', 'moai1', 'moai2', 'moai3',
    'drutt',
    'raindrops',
    'mushroom_01', 'mushroom_01B', 'mushroom_02', 'mushrooms',
    'snail_papa', 'snail_son',
    'nymphaea', 'nymphaea2', 'pavementAngleTopLeft', 'pavementTop', 'pavementAngleTopRight',
    'pavementLeft', 'pavementRight',
    'pavementAngleBottomLeft', 'pavementBottom', 'pavementAngleBottomRight',
    'water', 'water_tiled', 'grass', 'taraxacum', 'bullrushes', 'frog'],

    mapEntityGroupsIdx: 0,
    //--
    editorMode: 'terrain', //auto select editor mode
    currentInput: null,
    currentEntityId: 0, //current selected entity
    currentEntityMOId: 0, //current entity under mouse
    entitySelectionColor: [1.0, 0.0, 1.0], //the color used to highlight a selected entity
    entitySelectedColor: [1.0, 0.0, 1.0], //the color used to highlight an entity when the mouse is on it
    tilesTexturePool: ['pavement_02', 'pavement_01'],
    tilesTexturePoolIdx: 0,
    tilesOpacityPool: [1.0, .7, .9, .5, .3],
    tilesOpacityPoolIdx: 0,
    currentTileId: null, //current selected tile
    currentTileMOId: null, //current tile under mouse

    //particles
    currentSelectedParticles: [], //current editor selected particles
    currentSelectedParticlesIdx: -1,
    currentSelectedParticlesGIdx: 0,
    currentSelectedParticlesGMovementSpeed: 0.05,
    currentSelectedParticlesGMovementSpeedStep: 0.005,
    currentSelectedParticlesGMovementMinSpeed: 0.001,
    currentSelectedParticlesGMovementMaxSpeed: 0.1,
    currentSelectedParticlesGX: 0, //store last editor position
    currentSelectedParticlesGY: 0,
    particleSelEnableSingle: false, //if true enable adjustments for a single particle of a particle cluster
    currentSelectedParticleIdx: 0, //current idx for a single particle of a particle cluster
    particleSelectionColor: [1.0, 0.0, 0.0], //the color used to highlight a selected particle or particle cluster

    dynamicEntitiesGeometry: 1,
    //flags/counters
    isParticlesBufferDataDirty: 1,
    isWorldTilesVerticesPositionDirty: 0,
    isWorldTilesColorsDirty: 0,
    isWorldTilesTextureCoordsDirty: 0,
    isWorldTilesPropertiesDirty: 0, //if a tile alpha or sprite is changed we set this flag to 1
    autoBuildTextureAtlases: 0, //if true, load all the separate texture images and create a texture atlas, otherwise load the atlas (manually saved)
    isEditorEnabled: 0,

    chooseRandomWeather: 1,
    chanceOfRain: 0.3, //0 disabled - 0..1 simple chance of rain
    chooseRandomCameraKeyPoint: 1,
    loadSavedScene: 1,

    isMouseDirty: 0, //used to perform analysis only during mouse movements
    sceneVersion: 0, //used to visually increase the version number of the scene during save, it has no other uses.
    useUTCTime: 1 },

  init: function () {//proc init {green indent_1}
    const _seba = SEBASTIAN;

    _seba.GLOBALS.canvas = document.getElementById('c');
    _seba.GLOBALS.clock = document.getElementById('clock');
    _seba.WEBGL.initGL();
    _seba.UTILS.init();
    _seba.WEBGL.initShaders();
    _seba.WEBGL.WORLD.ENTITIES.init();

    //init time
    // we use getUTCHours so that there are no 'jumps'
    // in the hour due to the introduction of daylight savings time
    // if we used eg getHours
    // there would be a jump from 01:59 to 03:00 on 24/03/2018
    // and this would cause the moon to jump forward
    var tDate = new Date();
    _seba.GLOBALS.fpsInterval = 1000 / _seba.GLOBALS.fps;
    if (_seba.GLOBALS.useUTCTime) {
      _seba.GLOBALS.hours = tDate.getUTCHours();
      _seba.GLOBALS.minutes = tDate.getUTCMinutes();
    } else {
      _seba.GLOBALS.hours = tDate.getHours();
      _seba.GLOBALS.minutes = tDate.getMinutes();
    }

    //color timekey
    var h_key, m_key;
    var hours, minutes;
    if (_seba.GLOBALS.debugLightColors === 1) {//allows setting the time manually
      var tDate = new Date();
      var unixtime = tDate.getTime();
      unixtime += _seba.GLOBALS.timeTravel * 60 * 1000;
      tDate.setTime(unixtime);
      if (SEBASTIAN.GLOBALS.useUTCTime) {
        h_key = tDate.getUTCHours();
        m_key = tDate.getUTCMinutes();
      } else {
        h_key = tDate.getHours();
        m_key = tDate.getMinutes();
      }
      hours = h_key;
      minutes = m_key;
    } else {
      if (SEBASTIAN.GLOBALS.useUTCTime) {
        h_key = oDate.getUTCHours();
        m_key = oDate.getUTCMinutes();
      } else {
        h_key = oDate.getHours();
        m_key = oDate.getMinutes();
      }
      hours = h_key;
      minutes = m_key;
    }
    var colorKey = h_key + '_' + m_key;
    _seba.GLOBALS.lastTimeKey = colorKey;

    //proc assets loading CODEPEN {byellow indent_2}
    //load assets with a callback, then load world with a callback
    //then init gameloop.
    var assetsListContent = [
    {
      lightColorTimeMap: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/colormap.eiv3.json',
      //color data is a little compressed, translate it before decoding from json
      onLoad: function (responseText) {
        responseText = responseText.replace(/\|/g, '0.');
        responseText = responseText.replace(/LG/g, 'linear-gradient(to bottom,');
        return responseText;
      },
      onLoadDone: function (o) {
        // assign an index to every hour of the day,
        // we will use this to rotate the moon and the sun
        // based on current hour
        var counter = 0;
        for (var z in o) {
          o[z].idx = counter;
          //console.log(z);
          counter++;
        }
        //console.log(o);
      } }];


    var assetsListContentTextures = [
    {
      texturesData: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/texturesData.eiv4.json',
      onLoadDone: function (o) {
        SEBASTIAN.WEBGL.GLOBALS.textures = o;
        //console.log(o);
      } }];


    var assetsListAtlases = [
    { 'atlas1.glTexture': 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/1.eiv4.png' }, //here we can for example choose textures with different quality/resolution to improve performance on mobile browsers
    { 'atlas2.glTexture': 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/2.eiv4.png' },
    { 'atlas3.glTexture': 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/3.eiv4.png' }];

    var assetsList = [];
    assetsList = assetsListContent.concat(assetsListContentTextures, assetsListAtlases);
    SEBASTIAN.UTILS.initAssets(assetsList, function () {
      SEBASTIAN.WEBGL.loadTextureAtlases(function () {
        SEBASTIAN.WEBGL.WORLD.init();
        SEBASTIAN.WEBGL.WORLD.load(function () {SEBASTIAN.gameLoop(window.performance.now());});
      });
    });

  },
  gameLoop: function (newtime) {//proc gameLoop {green indent_1}
    const _seba = SEBASTIAN;
    //proc draw scene call {violet indent_2}
    _seba.WEBGL.WORLD.draw(newtime);

    var keys = _seba.GLOBALS.keys;
    var keysUp = _seba.GLOBALS.keysUp;

    //j -> camera keypoint travel--
    if (keysUp[74]) {
      keysUp[74] = 0;
      //determiniamo il numero di camera key points
      SEBASTIAN.GLOBALS.cameraKeyPoinstIndex--;
      var totalCameraKeyPoints0idx = SEBASTIAN.GLOBALS.cameraKeyPoints.length - 1;
      if (SEBASTIAN.GLOBALS.cameraKeyPoinstIndex < 0)
      SEBASTIAN.GLOBALS.cameraKeyPoinstIndex = totalCameraKeyPoints0idx;
      //console.log(SEBASTIAN.GLOBALS.cameraKeyPoinstIndex);
      SEBASTIAN.WEBGL.WORLD.setCameraTo(SEBASTIAN.GLOBALS.cameraKeyPoints[SEBASTIAN.GLOBALS.cameraKeyPoinstIndex]);
    }

    //k -> camera keypoint travel++
    if (keysUp[75] || _seba.GLOBALS.touchClick === 1) {
      _seba.GLOBALS.touchClick = 0;
      keysUp[75] = 0;
      //determiniamo il numero di camera key points
      SEBASTIAN.GLOBALS.cameraKeyPoinstIndex++;
      var totalCameraKeyPoints0idx = SEBASTIAN.GLOBALS.cameraKeyPoints.length - 1;
      if (SEBASTIAN.GLOBALS.cameraKeyPoinstIndex > totalCameraKeyPoints0idx)
      SEBASTIAN.GLOBALS.cameraKeyPoinstIndex = 0;
      //console.log(SEBASTIAN.GLOBALS.cameraKeyPoinstIndex);
      SEBASTIAN.WEBGL.WORLD.setCameraTo(SEBASTIAN.GLOBALS.cameraKeyPoints[SEBASTIAN.GLOBALS.cameraKeyPoinstIndex]);
    }

    var rainMoreKeyCode = 107; //+
    var rainLessKeyCode = 109; //-

    if (keys[rainMoreKeyCode] || _seba.GLOBALS.swipeDirH === 'right') {//rainDelta++
      //console.log(SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey]);
      //console.log(SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].g);
      //keysUp[221]=0;
      var rainInc = 0.03;
      if (_seba.GLOBALS.swipeDirH === 'right') {
        rainInc = _seba.GLOBALS.swipeDirHDistance;
        _seba.GLOBALS.swipeDirH = 'none';
      }
      _seba.WEBGL.WORLD.GLOBALS.rainDelta += rainInc;
      if (_seba.WEBGL.WORLD.GLOBALS.rainDelta > 1)
      _seba.WEBGL.WORLD.GLOBALS.rainDelta = 1;
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      var shaderProgram = _seba.WEBGL.GLOBALS.shaderProgram;
      var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;
      gl.useProgram(shaderProgram);
      gl.uniform1f(shaderProgram.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
      gl.useProgram(shaderProgramP);
      gl.uniform1f(shaderProgramP.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
      _seba.UTILS.backgroundGradientFadeToGray();
    }
    if (keys[rainLessKeyCode] || _seba.GLOBALS.swipeDirH === 'left') {//rainDelta--
      //keysUp[219]=0;
      var rainDec = 0.03;
      if (_seba.GLOBALS.swipeDirH === 'left') {
        rainDec = _seba.GLOBALS.swipeDirHDistance;
        _seba.GLOBALS.swipeDirH = 'none';
      }
      _seba.WEBGL.WORLD.GLOBALS.rainDelta -= rainDec;
      if (_seba.WEBGL.WORLD.GLOBALS.rainDelta < 0)
      _seba.WEBGL.WORLD.GLOBALS.rainDelta = 0;
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      var shaderProgram = _seba.WEBGL.GLOBALS.shaderProgram;
      var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;
      gl.useProgram(shaderProgram);
      gl.uniform1f(shaderProgram.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
      gl.useProgram(shaderProgramP);
      gl.uniform1f(shaderProgramP.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
      _seba.UTILS.backgroundGradientFadeToGray();
    }

    keys[84] ? _seba.GLOBALS.timeTravel++ : 0; //t -> time travel
    keys[82] ? _seba.GLOBALS.timeTravel-- : 0; //r -> time travel

    //precise timetravel
    if (keysUp[89]) {//y ->
      keysUp[89] = 0;
      _seba.GLOBALS.timeTravel--;
    }
    if (keysUp[85]) {//u ->
      keysUp[85] = 0;
      _seba.GLOBALS.timeTravel++;
    }

    keys[33] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.yPos += 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //Page up
    keys[34] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.yPos -= 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //Page up
    keys[37] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.xPos -= 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //cursor left
    keys[39] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.xPos += 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //cursor right
    keys[38] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.zPos -= 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //cursor up
    keys[40] ? (SEBASTIAN.WEBGL.WORLD.GLOBALS.zPos += 0.03, _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1) : 0; //cursor down

    keys[36] ? SEBASTIAN.WEBGL.WORLD.GLOBALS.pitch += 0.3 : 0; //init line
    keys[35] ? SEBASTIAN.WEBGL.WORLD.GLOBALS.pitch -= 0.3 : 0; //END line

    keys[45] ? SEBASTIAN.WEBGL.WORLD.GLOBALS.yaw += 0.3 : 0; //INSERT
    keys[46] ? SEBASTIAN.WEBGL.WORLD.GLOBALS.yaw -= 0.3 : 0; //CANC

    requestAnimationFrame(_seba.gameLoop); //loop forever
  },
  UTILS: { //proc UTILS {orange indent_1}
    init: function () {//proc init {green indent_2}
      const _seba = SEBASTIAN;

      //mobile input detection
      //adapted from http://www.javascriptkit.com/javatutors/touchevents2.shtml
      document.body.addEventListener('touchstart', function (e) {
        var nowNow = new Date().getTime();
        _seba.GLOBALS.touchEvent = { time2: nowNow, time: nowNow, touch: e.changedTouches[0] };
        _seba.GLOBALS.touchClick = 0;
        return false;
      });
      var touchEnd = function (e) {
        var allowedTime = 2000;
        var vThreshold = 150;
        var hThreshold = 20;
        var swipeDirH = 'none';
        var swipeDirV = 'none';
        var previousEvent = _seba.GLOBALS.touchEvent;
        var distX = e.changedTouches[0].pageX - previousEvent.touch.pageX;
        var distY = e.changedTouches[0].pageY - previousEvent.touch.pageY;
        var nowNow = new Date().getTime();
        var elapsedTime = nowNow - previousEvent.time;
        var elapsedTimeReal = nowNow - previousEvent.time2;
        //console.log(elapsedTime,'<=',allowedTime,_seba.GLOBALS.swipeDirV,_seba.GLOBALS.swipeDirVDistance);
        //console.log(elapsedTime,'<=',allowedTime,Math.abs(distX),'>=',threshold,Math.abs(distY),'<=');
        //console.log(elapsedTime,'<',100,'&amp;&amp;',(nowNow-_seba.GLOBALS.touchEventResetAt),'>200','&amp;&amp;',e.type,'===touchend &amp;&amp; ',Math.abs(distX),'<5','&amp;&amp;',Math.abs(distY),'<5');
        //if (elapsedTime<100 &amp;&amp; (typeof _seba.GLOBALS.touchEventResetAt==='undefined' || nowNow-_seba.GLOBALS.touchEventResetAt>200) &amp;&amp; e.type==='touchend' &amp;&amp; Math.abs(distX)<5 &amp;&amp; Math.abs(distY)<5)
        if (elapsedTimeReal < 300 &amp;&amp; e.type === 'touchend' &amp;&amp; Math.abs(distX) < 5 &amp;&amp; Math.abs(distY) < 5)
        _seba.GLOBALS.touchClick = 1;

        if (elapsedTime <= allowedTime) {
          if (Math.abs(distX) >= hThreshold)
          swipeDirH = distX < 0 ? 'left' : 'right';
          if (Math.abs(distY) >= vThreshold)
          swipeDirV = distY < 0 ? 'up' : 'down';
        }
        if (
        swipeDirV !== _seba.GLOBALS.swipeDirV || swipeDirH !== _seba.GLOBALS.swipeDirH ||
        elapsedTime > allowedTime &amp;&amp; e.type === 'touchmove')
        {
          //dir is changed -> reset
          _seba.GLOBALS.touchEvent = { time: new Date().getTime(), touch: e.changedTouches[0] };
        }
        _seba.GLOBALS.swipeDirH = swipeDirH;
        _seba.GLOBALS.swipeType = e.type;
        _seba.GLOBALS.swipeDirV = swipeDirV;
        var docWidth = document.documentElement.clientWidth;
        var docHeight = document.documentElement.clientHeight;
        _seba.GLOBALS.swipeDirHDistance = Math.abs(distX / (docWidth / 1.5));
        _seba.GLOBALS.swipeDirVDistance = Math.abs(distY / (docHeight / 1.5));
        //console.log(_seba.GLOBALS.swipeDirH,_seba.GLOBALS.swipeDirV,_seba.GLOBALS.swipeDirVDistance);
        return false;
      };
      document.body.addEventListener('touchend', touchEnd);
      document.body.addEventListener('touchmove', touchEnd);

      //proc window.onresize {violet indent_3}
      window.onresize = function () {
        //console.log('resize',document.documentElement.clientWidth);
        //canvas resizing
        var docWidth = document.documentElement.clientWidth;
        var docHeight = document.documentElement.clientHeight;
        var canvasDom = document.getElementById('c');
        canvasDom.width = docWidth;
        canvasDom.setAttribute('width', docWidth);
        canvasDom.style.width = docWidth + 'px';
        canvasDom.height = docHeight;
        canvasDom.style.height = docHeight + 'px';
        canvasDom.setAttribute('height', docHeight);

        //resize webgl render window
        var gl = _seba.GLOBALS.webgl_ctx; //lookup var
        gl.viewportWidth = docWidth;
        gl.viewportHeight = docHeight;
        _seba.WEBGL.WORLD.GLOBALS.isViewportDirty = 1;
      };
      window.onresize();

      //proc window.onkeyup {violet indent_3}
      window.onkeyup = function (e) {

        _seba.GLOBALS.keys[e.keyCode] = 0;
        _seba.GLOBALS.keysUp[e.keyCode] = 1;

      };

      //proc window.onkeydown {violet indent_3}
      //keyboard event handlers
      window.onkeydown = function (e) {

        _seba.GLOBALS.keys[e.keyCode] = 1;
        if (typeof _seba.GLOBALS.worldData === 'undefined')
        return;

      };

    },
    onVisibilityChangeHandler: function (hiddenPropertyName) {//proc editorInputKeyUp
      if (document[hiddenPropertyName]) {
        SEBASTIAN.GLOBALS.fpsInterval = 10000;
        //console.log('HIDDEN',new Date());
      } else {
        SEBASTIAN.GLOBALS.fpsInterval = 1000 / SEBASTIAN.GLOBALS.fps;
        //console.log('VISIBLE',new Date());
      }
    },
    backgroundGradientFadeToGray: function () {//proc init {green indent_2}
      const _seba = SEBASTIAN;
      var colorKey = _seba.GLOBALS.lastTimeKey;
      //console.log(SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey]);
      if (typeof SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].oG === 'undefined')
      SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].oG = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].g;

      var rainDelta = _seba.WEBGL.WORLD.GLOBALS.rainDelta;
      var g = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].oG;
      //console.log(SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].oG);
      var sg = g.replace(/\#([^\s]+)/g, function (a, hex) {
        //https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
        var bigint = parseInt(hex, 16);
        var r = bigint >> 16 &amp; 255;
        var g = bigint >> 8 &amp; 255;
        var b = bigint &amp; 255;
        var gray = (r + g + b) / 3;
        var rG = r + rainDelta * (gray - r);
        var gG = g + rainDelta * (gray - g);
        var bG = b + rainDelta * (gray - b);

        var rgb = bG | gG << 8 | rG << 16;
        var grayG = '#' + (0x1000000 + rgb).toString(16).slice(1);
        //console.log(grayG);
        return grayG;
        //console.log(r + &quot;,&quot; + g + &quot;,&quot; + b);
      });
      SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].g = sg;
      //apply new background color
      document.body.style.background = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].g;
      //apply sun opacity
      var worldData = SEBASTIAN.GLOBALS.worldData;
      var brotherSun = worldData.entitiesNamePointer['sun'];
      brotherSun.opacity = _seba.UTILS.lerp(1, 0.2, rainDelta);
      _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(brotherSun); //update alpha
    },
    lerp: function (a, b, alpha) {//proc lerp {green indent_2}
      //https://en.wikipedia.org/wiki/Linear_interpolation
      return a + alpha * (b - alpha);
    },

    applyTimeCalc(cfg) {//proc applyTimeCalc {green indent_2}
      var config = {
        //sunLightVerticalPosition:cfg.sunLightVerticalPosition, //_seba.WEBGL.WORLD.GLOBALS.sunLightVerticalDistance
        parameter: cfg.parameter,
        currentHour: cfg.currentHour,
        currentMinute: cfg.currentMinute,
        fromHours: cfg.fromHours,
        toHours: cfg.toHours,
        fromMinutes: cfg.fromMinutes,
        toMinutes: cfg.toMinutes,
        fromValue: cfg.fromValue,
        toValue: cfg.toValue,
        logInfo: cfg.logInfo || 0,
        applyTimeBouncing: cfg.applyTimeBouncing };

      var _seba = SEBASTIAN;
      var parameter = config.parameter;
      var currentHour = config.currentHour;
      var currentMinute = config.currentMinute;
      var fromHours = config.fromHours;
      var toHours = config.toHours;
      var fromMinutes = config.fromMinutes;
      var toMinutes = config.toMinutes;
      var fromValue = config.fromValue;
      var toValue = config.toValue;
      var logInfo = config.logInfo;
      var applyTimeBouncing = config.applyTimeBouncing;
      if (typeof applyTimeBouncing === 'undefined')
      applyTimeBouncing = 1;

      //build Time index
      var h_key, m_key, colorKey;
      //current index
      //to index
      h_key = currentHour;
      m_key = currentMinute;
      colorKey = h_key + '_' + m_key;
      var currentTimeIdx = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx;
      //from index
      h_key = fromHours;
      m_key = fromMinutes;
      colorKey = h_key + '_' + m_key;
      var initTimeIdx = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx;
      //to index
      h_key = toHours;
      m_key = toMinutes;
      colorKey = h_key + '_' + m_key;
      var endTimeIdx = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx;
      var distanceIdx = endTimeIdx - initTimeIdx;
      var halfTimeIdx = initTimeIdx + distanceIdx / 2;

      if (applyTimeBouncing) {
        //if (currentHour===fromHours &amp;&amp; currentMinute>=fromMinutes){
        if (currentTimeIdx >= initTimeIdx &amp;&amp; currentTimeIdx < halfTimeIdx) {
          //console.log('+delta',(currentTimeIdx-initTimeIdx)*1/halfTimeIdx);
          //var delta=(currentTimeIdx-initTimeIdx)/initTimeIdx; //normalize
          var delta = (currentTimeIdx - initTimeIdx) * 1 / distanceIdx * 2; //normalize to 0..1
          parameter = fromValue * (1 - delta) + toValue * delta; //lerp
          //console.log('>>',parameter);
        }
        if (currentTimeIdx >= halfTimeIdx &amp;&amp; currentTimeIdx <= endTimeIdx) {
          //var delta=1-((toMinutes-currentMinute)/toMinutes); //normalize
          //console.log('-delta',1-((endTimeIdx-currentTimeIdx)*1/halfTimeIdx));
          //var delta=1-((endTimeIdx-currentTimeIdx)/endTimeIdx); //normalize
          var delta = 1 - (endTimeIdx - currentTimeIdx) * 1 / distanceIdx * 2;
          parameter = toValue * (1 - delta) + fromValue * delta; //lerp
          //console.log('<<',parameter);
        }
      } else {
        if (currentTimeIdx >= initTimeIdx &amp;&amp; currentTimeIdx <= endTimeIdx) {
          //console.log('+DELTA',(currentTimeIdx-initTimeIdx)*1/halfTimeIdx);
          //var delta=(currentTimeIdx-initTimeIdx)/initTimeIdx; //normalize
          var delta = (currentTimeIdx - initTimeIdx) * 1 / distanceIdx; //normalize to 0..1
          parameter = fromValue * (1 - delta) + toValue * delta; //lerp
          //console.log('>>',parameter);
        }
      }
      return parameter;

    },
    degToRad(degrees) {//proc deg2rad {green indent_2}
      return degrees * Math.PI / 180;
    },
    initAssets: function (tList, callback) {//proc initAssets {green indent_2}
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      for (var z = 0, zEnd = tList.length; z < zEnd; z++) {

        //a bit hacky
        //for (var assetId in tList[z]){}
        //clearer ->
        var assetId = Object.keys(tList[z])[0];

        //console.log(assetId);

        if (tList[z][assetId].match(/\.json$/)) {
          var assetUrl = tList[z][assetId];
          var xhr = new XMLHttpRequest();
          xhr.onload = function (z, assetId) {
            return function () {//func factory {indent_4}
              //if (xhr.status===200){ //2018-05-15 02:25:37 - wrong, this does not allow us to properly load files if they are cached
              var responseText = this.responseText;
              if (typeof tList[z].onLoad !== 'undefined')
              responseText = tList[z].onLoad(responseText);
              SEBASTIAN.GLOBALS[assetId] = JSON.parse(responseText); //save the object in SEBASTIAN.GLOBALS with the specified key
              if (typeof tList[z].onLoadDone !== 'undefined')
              responseText = tList[z].onLoadDone(SEBASTIAN.GLOBALS[assetId]);

              SEBASTIAN.GLOBALS.loadedAssets++;
              if (SEBASTIAN.GLOBALS.loadedAssets === tList.length) {//all loaded
                callback();
              }
            };
          }(z, assetId);
          xhr.open('GET', assetUrl);
          xhr.send();
        } else if (assetId.match(/\.glTexture$/)) {
          var imgUrl = tList[z][assetId];
          var tempImage = gl.createTexture();
          tempImage.image = new Image();
          SEBASTIAN.WEBGL.GLOBALS.tempTextures[assetId] = tempImage;
          tempImage._data = tList[z].data; //set data
          tempImage.image.onload = function (assetId) {
            return function () {
              SEBASTIAN.GLOBALS.loadedAssets++;
              //console.log(SEBASTIAN.GLOBALS.loadedAssets,tList.length);
              if (SEBASTIAN.GLOBALS.loadedAssets === tList.length) {//all loaded
                callback();
              }
            };
          }(assetId);

          //activate Cross Origin Resource Sharing
          //ask the remote image server for permission to use the image.
          tempImage.image.crossOrigin = 'anonymous';

          tempImage.image.src = imgUrl;

        } else {
          var imgUrl = tList[z][assetId];
          var tempImage = new Image();
          SEBASTIAN.WEBGL.GLOBALS.tempTextures[assetId] = tempImage;
          tempImage._data = tList[z].data; //set data
          tempImage.onload = function (assetId) {
            return function () {
              SEBASTIAN.GLOBALS.loadedAssets++;
              if (SEBASTIAN.GLOBALS.loadedAssets === tList.length) {//all loaded
                callback();
              }
            };
          }(assetId);

          //activate Cross Origin Resource Sharing
          //ask the remote image server for permission to use the image.
          tempImage.crossOrigin = 'anonymous';
          var rainMoreKeyCode = 107;
          tempImage.src = imgUrl;
        }
      }
    } },

  WEBGL: { //proc WEBGL {orange indent_1}
    GLOBALS: { //proc WEBGL.GLOBALS {orange indent_3}
      buffers: {}, //proc buffers {blue indent_3}
      textures: {}, //proc textures {blue indent_3} texture database in relation to the atlas texture
      tempTextures: {}, //proc tempTextures {blue indent_3} textures loaded individually before creating the atlas texture
      shaderProgram: {}, //proc shaderProgram {blue indent_3}
      anisotropicFilter: null },

    //--
    initGL: function () {//proc initGL {green indent_2}
      var canvas = SEBASTIAN.GLOBALS.canvas;
      //preserveDrawingBuffer    -> determines whether or not to clear the buffer at each frame
      //alpha:false              -> disabled alpha blending with html background
      //premultipliedAlpha:false -> blend alpha from gl with html background
      SEBASTIAN.GLOBALS.webgl_ctx = canvas.getContext('webgl', { preserveDrawingBuffer: false, premultipliedAlpha: true });
      if (!SEBASTIAN.GLOBALS.webgl_ctx) //no luck? ok, let's try something different....
        SEBASTIAN.GLOBALS.webgl_ctx = canvas.getContext('experimental-webgl', { preserveDrawingBuffer: false, premultipliedAlpha: true });
      //--
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;

      //enable ALPHA blending for png transparent textures
      //gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA); //premultipliedAlpha should be set to true and -> gl.pixelStorei   (gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); should be used
      //enable ALPHA blending for gif transparent textures (deal with 1 bit transparency)
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.enable(gl.BLEND);

      //2018-03-12 22:58:42
      //test if we can enable anisotropic filtering
      //https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_filter_anisotropic
      SEBASTIAN.WEBGL.GLOBALS.anisotropicFilter = gl.getExtension('EXT_texture_filter_anisotropic');

      // if we want alpha blending for our .PNGs file we can't use DEPTH_TEST
      // we manage the depth test in a distinct way during drawing.
      // use depthMask(true) for objects without alpha
      // use depthMask(false) for transparent objects ->
      // in this case the z-ordering must be done by our routine
      // see drawloop

      gl.enable(gl.DEPTH_TEST);
    },

    initShaders: function () {//proc initShaders {green indent_2}
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      //Init shaders
      //setup a GLSL program
      var vertexShader = SEBASTIAN.WEBGL.createShaderFromScript(gl, '2d-vertex-shader');
      var fragmentShader = SEBASTIAN.WEBGL.createShaderFromScript(gl, '2d-fragment-shader');
      var shaderProgram = SEBASTIAN.WEBGL.createProgram(gl, [vertexShader, fragmentShader]);
      SEBASTIAN.WEBGL.GLOBALS.shaderProgram = shaderProgram;
      //gl.useProgram(shaderProgram);

      //proc shaderProgram set vars {violet indent_3}

      shaderProgram.data = {
        aVertexPosition: { location: gl.getAttribLocation(shaderProgram, 'aVertexPosition') },
        aTextureCoord: { location: gl.getAttribLocation(shaderProgram, 'aTextureCoord') },
        aEntityTranslation: { location: gl.getAttribLocation(shaderProgram, 'aEntityTranslation') },
        aEntityColor: { location: gl.getAttribLocation(shaderProgram, 'aEntityColor') },
        aEntityProperties: { location: gl.getAttribLocation(shaderProgram, 'aEntityProperties') },
        uPMatrix: { location: gl.getUniformLocation(shaderProgram, 'uPMatrix') },
        uMVMatrix: { location: gl.getUniformLocation(shaderProgram, 'uMVMatrix') },
        //uTimeDelta                  :{location:gl.getUniformLocation(shaderProgram,'uTimeDelta')},
        uCameraTranslation: { location: gl.getUniformLocation(shaderProgram, 'uCameraTranslation') },
        uTextureSampler0: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler0') },
        uTextureSampler1: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler1') },
        uTextureSampler2: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler2') },
        uTextureSampler3: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler3') },
        uTextureSampler4: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler4') },
        uTextureSampler5: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler5') },
        uTextureSampler6: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler6') },
        uTextureSampler7: { location: gl.getUniformLocation(shaderProgram, 'uTextureSampler7') },
        uAmbientLightColor: { location: gl.getUniformLocation(shaderProgram, 'uAmbientLightColor') },
        uAmbientLightColorIntensity: { location: gl.getUniformLocation(shaderProgram, 'uAmbientLightColorIntensity') },
        uPointLighting1Location: { location: gl.getUniformLocation(shaderProgram, 'uPointLighting1Location') },
        uPointLighting2Location: { location: gl.getUniformLocation(shaderProgram, 'uPointLighting2Location') },
        uRainDelta: { location: gl.getUniformLocation(shaderProgram, 'uRainDelta') },
        interleavedStruct: {
          buffer: gl.createBuffer(),
          //data    :new Float32Array(verticesbuffer),

          //stride is
          //number of interleaved properties associated with a vertex
          //--
          //size in bytes
          //this will be used by opengl to associate the linear
          //array with the attributes passed to each vertex
          stride: 15 * Float32Array.BYTES_PER_ELEMENT //unused for now
        },
        enable: function () {
          for (var z in this) {
            if (typeof this[z].location !== 'undefined' &amp;&amp; z.indexOf('a') === 0)
            gl.enableVertexAttribArray(this[z].location);
          }
          //gl.enableVertexAttribArray(shaderProgram.aVertexPosition_var);
        } };

      shaderProgram.data.enable();

      //proc particles
      var vertexShaderP = SEBASTIAN.WEBGL.createShaderFromScript(gl, '2d-vertex-shader-particles');
      var fragmentShaderP = SEBASTIAN.WEBGL.createShaderFromScript(gl, '2d-fragment-shader-particles');
      var shaderProgramP = SEBASTIAN.WEBGL.createProgram(gl, [vertexShaderP, fragmentShaderP]);
      gl.useProgram(shaderProgramP); //swith to particles program

      var triangleStrippedQuad = [//draw a quad with two different triangles
      0, 0, 0,
      0, 1, 0,
      1, 1, 0,
      1, 0, 0];

      var indices = [0, 1, 2, 2, 3, 0];

      //rain drops

      var verticesbuffer = [];
      var indicesBuffer = [];
      var indicesIdx = 0;

      var rainDropsTotalParticles = 9000; //10000; //10000 = very good
      var particleType = 0;
      var color_r = 0.8;
      var color_g = 0.8;
      var color_b = 0.8;
      for (var z = 0; z < rainDropsTotalParticles; z++) {

        var minRand = 5;
        var maxRand = 15;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var yPositionRandom = randValue;
        //yPositionRandom=0;

        var minRand = 0.0;
        //minRand=0.0;
        var maxRand = 14.0; //con il trucco telecamera basta molto meno, -telecamera.x su shader*2 -> SEBASTIAN.WEBGL.WORLD.GLOBALS.columns;
        //maxRand=10;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var xPositionRandom = randValue;
        //xPositionRandom=0;

        var minRand = SEBASTIAN.WEBGL.WORLD.GLOBALS.rows - 8;
        var maxRand = SEBASTIAN.WEBGL.WORLD.GLOBALS.rows - 1; //we remove one because SEBASTIAN.WEBGL.WORLD.GLOBALS.rows is not visible
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var zPositionRandom = randValue;
        //zPositionRandom=0;

        var minRand = 4.0;
        var maxRand = 6.0;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var velocityRandom = randValue;

        var scaleX = 280; //80
        var scaleY = 5; //20

        //scaleX=1; //80
        //scaleY=1;   //20

        //vertex 1
        verticesbuffer.push(
        //the numbers between squares show the value that we will have to pass to vertexAttribPointer as an offset
        //[0]                                           1                               2
        triangleStrippedQuad[0] / scaleX, triangleStrippedQuad[1] / scaleY, triangleStrippedQuad[2]
        //[3]   4                 5   - INIT POSITION (used as default state)
        , 0, yPositionRandom, 0,
        //[6]
        velocityRandom,
        //[7]
        particleType,
        //[8]   9    10 - DESTINATION
        0, 0, 0,
        //[11]                12    13 - TRANSLATION
        xPositionRandom, 0, zPositionRandom,
        //[14] - LIFETIME
        0,
        //[15] - Color.r,  16 color.g  17 color.b 18 color.a
        color_r, color_g, color_b, 0);

        //vertex 2
        verticesbuffer.push(triangleStrippedQuad[3] / scaleX, triangleStrippedQuad[4] / scaleY, triangleStrippedQuad[5], 0, yPositionRandom, 0, velocityRandom, particleType, 0, 0, 0, xPositionRandom, 0, zPositionRandom, 0, color_r, color_g, color_b, 0);
        //vertex 3
        verticesbuffer.push(triangleStrippedQuad[6] / scaleX, triangleStrippedQuad[7] / scaleY, triangleStrippedQuad[8], 0, yPositionRandom, 0, velocityRandom, particleType, 0, 0, 0, xPositionRandom, 0, zPositionRandom, 0, color_r, color_g, color_b, 0);
        //vertex 4
        verticesbuffer.push(triangleStrippedQuad[9] / scaleX, triangleStrippedQuad[10] / scaleY, triangleStrippedQuad[11], 0, yPositionRandom, 0, velocityRandom, particleType, 0, 0, 0, xPositionRandom, 0, zPositionRandom, 0, color_r, color_g, color_b, 0);

        var idx4 = indicesIdx;
        indicesBuffer.push(indices[0] + idx4, indices[1] + idx4, indices[2] + idx4, indices[3] + idx4, indices[4] + idx4, indices[5] + idx4);
        indicesIdx += 4; //we have 4 vertices per triangle
      }
      //console.log(indicesBuffer.length);

      //rain drops collision
      var rainDropsCollisionsTotalParticles = Math.floor(65536 / 4) - rainDropsTotalParticles;
      var particleType = 1;
      var color_r = 0.9;
      var color_g = 0.9;
      var color_b = 0.9;
      for (var z = 0; z < rainDropsCollisionsTotalParticles; z++) {

        var minRand = 0;
        var maxRand = 14;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var xTranslationRandom = randValue;
        //xTranslationRandom=0;

        var minRand = 5;
        var maxRand = 15;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var yTranslationRandom = randValue;
        yTranslationRandom = 0;

        var minRand = 0;
        var maxRand = 16; //SEBASTIAN.WEBGL.WORLD.GLOBALS.rows;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var zTranslationRandom = randValue;
        //zTranslationRandom=0;

        var minRand = -.01;
        var maxRand = .01;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var xDestinationRandom = randValue;
        //xDestinationRandom=0;

        var minRand = 0;
        var maxRand = .01;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var yDestinationRandom = randValue;
        yDestinationRandom = 0;

        var minRand = -.05;
        var maxRand = .05;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var zDestinationRandom = randValue;
        zDestinationRandom = 0;

        var minRand = 0.5;
        var maxRand = 0.7;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        //randValue=2;
        var lifeTimeRandom = 1; //randValue;

        var minRand = 5;
        var maxRand = 6;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        //randValue=2;
        var velocityRandom = randValue; //randValue;

        var minRand = 90; //80
        var maxRand = 120;
        var randValue = Math.random() * (maxRand - minRand) + minRand;
        var sizeRandom = randValue; //randValue;
        var scaleX = sizeRandom; //80
        var scaleY = sizeRandom; //20

        verticesbuffer.push(
        //the numbers between squares show the value that we will have to pass to vertexAttribPointer as an offset
        //[0]                                           1                               2
        triangleStrippedQuad[0] / scaleX, triangleStrippedQuad[1] / scaleY, triangleStrippedQuad[2]
        //[3]   4                 5
        , 0, 0, 0,
        //[6]
        velocityRandom,
        //[7]
        particleType,
        //[8]                    9                     10 - DESTINATION
        xDestinationRandom, yDestinationRandom, zDestinationRandom,
        //[11] 12    13 - TRANSLATION
        xTranslationRandom, yTranslationRandom, zTranslationRandom,
        //[14] - LIFETIME
        lifeTimeRandom,
        //[15] - Color.r,  16 color.g  17 color.b 18 color.a
        color_r, color_g, color_b, 0);

        //                  0                                               1                               2                                        3 4               5 6              7            8 9                  10 11  12 13
        verticesbuffer.push(triangleStrippedQuad[3] / scaleX, triangleStrippedQuad[4] / scaleY, triangleStrippedQuad[5], 0, 0, 0, velocityRandom, particleType, xDestinationRandom, yDestinationRandom, zDestinationRandom, xTranslationRandom, yTranslationRandom, zTranslationRandom, lifeTimeRandom, color_r, color_g, color_b, 0);
        verticesbuffer.push(triangleStrippedQuad[6] / scaleX, triangleStrippedQuad[7] / scaleY, triangleStrippedQuad[8], 0, 0, 0, velocityRandom, particleType, xDestinationRandom, yDestinationRandom, zDestinationRandom, xTranslationRandom, yTranslationRandom, zTranslationRandom, lifeTimeRandom, color_r, color_g, color_b, 0);
        verticesbuffer.push(triangleStrippedQuad[9] / scaleX, triangleStrippedQuad[10] / scaleY, triangleStrippedQuad[11], 0, 0, 0, velocityRandom, particleType, xDestinationRandom, yDestinationRandom, zDestinationRandom, xTranslationRandom, yTranslationRandom, zTranslationRandom, lifeTimeRandom, color_r, color_g, color_b, 0);

        var idx4 = indicesIdx;
        indicesBuffer.push(indices[0] + idx4, indices[1] + idx4, indices[2] + idx4, indices[3] + idx4, indices[4] + idx4, indices[5] + idx4);
        indicesIdx += 4; //we have 4 vertices per triangle
      }

      shaderProgramP.data = {

        uTimeDelta: { location: gl.getUniformLocation(shaderProgramP, 'uTimeDelta') },
        uDelta: { location: gl.getUniformLocation(shaderProgramP, 'uDelta') },
        uCameraTranslation: { location: gl.getUniformLocation(shaderProgramP, 'uCameraTranslation') },
        uPMatrix: { location: gl.getUniformLocation(shaderProgramP, 'uPMatrix') },
        uMVMatrix: { location: gl.getUniformLocation(shaderProgramP, 'uMVMatrix') },
        uRainDelta: { location: gl.getUniformLocation(shaderProgramP, 'uRainDelta') },
        aVertexPosition: { location: gl.getAttribLocation(shaderProgramP, 'aVertexPosition') },
        aParticleInitPosition: { location: gl.getAttribLocation(shaderProgramP, 'aParticleInitPosition') },
        aParticleVelocity: { location: gl.getAttribLocation(shaderProgramP, 'aParticleVelocity') },
        aParticleType: { location: gl.getAttribLocation(shaderProgramP, 'aParticleType') },
        aParticleDestination: { location: gl.getAttribLocation(shaderProgramP, 'aParticleDestination') },
        aParticleTranslation: { location: gl.getAttribLocation(shaderProgramP, 'aParticleTranslation') },
        aParticleLifetime: { location: gl.getAttribLocation(shaderProgramP, 'aParticleLifetime') },
        aParticleColor: { location: gl.getAttribLocation(shaderProgramP, 'aParticleColor') },
        uPointLighting1Location: { location: gl.getUniformLocation(shaderProgramP, 'uPointLighting1Location') },
        uPointLighting2Location: { location: gl.getUniformLocation(shaderProgramP, 'uPointLighting2Location') },
        uAmbientLightColorIntensity: { location: gl.getUniformLocation(shaderProgramP, 'uAmbientLightColorIntensity') },
        uAmbientLightColor: { location: gl.getUniformLocation(shaderProgramP, 'uAmbientLightColor') },

        indicesStruct: {
          rainDropsCount: rainDropsTotalParticles,
          rainDropsCollisionsCount: rainDropsCollisionsTotalParticles,
          elementsCount: rainDropsTotalParticles + rainDropsCollisionsTotalParticles,
          buffer: gl.createBuffer(),
          data: new Uint16Array(indicesBuffer) //we use a suitable data type for indexes
        },
        interleavedStruct: {
          buffer: gl.createBuffer(),
          data: new Float32Array(verticesbuffer),

          //stride is
          //number of interleaved properties associated with a vertex
          //--
          //size in bytes
          //this will be used by opengl to associate the linear
          //array with the attributes passed to each vertex
          elementsDataLength: 19,
          stride: 19 * Float32Array.BYTES_PER_ELEMENT },

        userParticles: { //particles added by the user (editor)
          triangleStrippedQuad: triangleStrippedQuad,
          indices: indices,
          verticesbuffer: [],
          indicesBuffer: [],
          indicesIdx: 0,
          indicesStruct: {
            elementsCount: 0, //rainDropsTotalParticles+rainDropsCollisionsTotalParticles,
            buffer: gl.createBuffer(),
            data: null //new Uint16Array(indicesBuffer), //we use a suitable data type for indexes
          },
          interleavedStruct: {
            buffer: gl.createBuffer(),
            data: null, //new Float32Array(verticesbuffer),
            elementsDataLength: 19,
            stride: 19 * Float32Array.BYTES_PER_ELEMENT } } };



      //now we could run enableVertexAttribArray but to avoid run-time errors
      //we execute it right before drawing inside the drawcall

      SEBASTIAN.WEBGL.GLOBALS.shaderProgramP = shaderProgramP;

      //proc particles
      gl.useProgram(shaderProgram); //use default program so texture loading and buffers are bind to it
    },

    loadTextureAtlases: function (callback) {//proc loadTextureAtlases {green indent_2}
      const _seba = SEBASTIAN;
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      var atlasLayerIndex = 0;
      for (var textureSid in _seba.WEBGL.GLOBALS.tempTextures) {
        var currentTexture = _seba.WEBGL.GLOBALS.tempTextures[textureSid];
        SEBASTIAN.WEBGL.handleLoadedTextureAtlasImage(currentTexture, atlasLayerIndex);
        //console.log(_seba.WEBGL.GLOBALS.tempTextures,atlasLayerIndex);
        atlasLayerIndex++;
      }
      delete SEBASTIAN.WEBGL.GLOBALS.tempTextures;
      callback();
    },

    handleLoadedTextureAtlasImage: function (texture, layerIdx) {//proc handleLoadedTextureAtlasImage {green indent_2}
      //multitextures -> ref: https://webglfundamentals.org/webgl/webgl-2-textures.html
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
      var shaderProgram = SEBASTIAN.WEBGL.GLOBALS.shaderProgram;
      var USE_MIPMAPS = 1;

      //console.log(shaderProgram.data['uTextureSampler'+layerIdx].location);
      gl.uniform1i(shaderProgram.data['uTextureSampler' + layerIdx].location, layerIdx);
      gl.activeTexture(gl.TEXTURE0 + layerIdx);
      gl.bindTexture(gl.TEXTURE_2D, texture); //bind once - the atlas texture
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      if (USE_MIPMAPS) {
        //gl.texParameteri (gl.TEXTURE_2D,gl.TEXTURE_BASE_LEVEL,0);
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      }

      //2018-03-12 23:04:23
      //https://developer.mozilla.org/en-US/docs/Web/API/EXT_texture_filter_anisotropic
      //MAX_TEXTURE_MAX_ANISOTROPY_EXT is 16 on my card
      if (SEBASTIAN.WEBGL.GLOBALS.anisotropicFilter)
      gl.texParameteri(
      gl.TEXTURE_2D,
      SEBASTIAN.WEBGL.GLOBALS.anisotropicFilter.TEXTURE_MAX_ANISOTROPY_EXT,
      gl.getParameter(SEBASTIAN.WEBGL.GLOBALS.anisotropicFilter.MAX_TEXTURE_MAX_ANISOTROPY_EXT));


      //2018-02-11 16:26:59
      //using the 'CLAMP_TO_EDGE' setting we
      //avoid the texture bleeding phenomenon visible
      //in the edges of the textures that extend throughout
      //the width or height of the tile (tileable-type textures)
      //Note: 2018-03-11 23:03:15
      //since CLAMP_TO_EDGE only applies to the edges of the texture,
      //this setting can not solve the texture bleeding problem if we are using
      //a texture atlas

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    },
    createShaderFromScript: function (gl, scriptId) {//proc createShaderFromScript {green indent_2}
      var shaderType;
      var shaderScript = document.getElementById(scriptId);
      if (!shaderScript)
      alert(&quot;*** Error: script element not found: &quot; + scriptId);

      switch (shaderScript.type) {
        case 'x-shader/x-vertex':
          shaderType = gl.VERTEX_SHADER;
          break;
        case 'x-shader/x-fragment':
          shaderType = gl.FRAGMENT_SHADER;
          break;
        default:
          alert('webgl_createShaderFromScript error unkown type');
          break;}


      // Create the shader object
      var shader = gl.createShader(shaderType);
      // Load the shader source
      gl.shaderSource(shader, shaderScript.text);
      // Compile the shader
      gl.compileShader(shader);
      // Check the compile status
      var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
      if (!compiled) {
        // Something went wrong during compilation; get the error
        var lastError = gl.getShaderInfoLog(shader);
        console.error(&quot;*** Error compiling shader '&quot; + shader + &quot;':&quot; + lastError);
        gl.deleteShader(shader);
        return null;
      }

      return shader;
    },
    createProgram: function (gl, shaders) {//proc createProgram {green indent_2}
      var program = gl.createProgram();
      for (var ii = 0; ii < shaders.length; ++ii) {
        gl.attachShader(program, shaders[ii]);
      }
      gl.linkProgram(program);

      // Check the link status
      var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
        // something went wrong with the link
        var lastError = gl.getProgramInfoLog(program);
        console.error(&quot;Error in program linking:&quot; + lastError);
        gl.deleteProgram(program);
        return null;
      }
      return program;
    },

    project: function (x, y, z, xPos, yPos, zPos, eX, eY, eZ, pMatrix, mvMatrix) {//proc project {green indent_2}
      var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var

      var out = vec4.fromValues(x - xPos + eX, y - yPos + eY, z - zPos + eZ, 1.0);
      var pMatrixClone = mat4.clone(pMatrix);
      mat4.multiply(pMatrixClone, pMatrixClone, mvMatrix);

      //transform world to clipping coordinates
      vec4.transformMat4(out, out, pMatrixClone);

      var screenX = Math.round((out[0] / out[2] + 1) / 2.0 * gl.viewportWidth);
      var screenY = Math.round((1 - out[1] / out[2]) / 2.0 * gl.viewportHeight);
      return [screenX, screenY];
    },

    WORLD: { //proc WEBGL.WORLD {orange indent_2}
      GLOBALS: { //proc WEBGL.WORLD.GLOBALS {orange indent_3}
        //vertexPositions:null, //store dynamic terrain vertex positions
        //worldTilesData:[], //store info for every world tile (e.g textureindex)
        isCameraPositionDirty: 1, //flag used to decide whether or not it is necessary to update the translation uniforms of the shader

        //rainDelta 2018-05-30 22:07:39
        rainDelta: 0, //this value also controls the conversion of the palette. 1 means greyscale

        //tile world columns
        //these numbers determine the size of the world
        columns: 45,
        rows: 25,

        //world colors and flags
        sunLightVerticalDistance: 300, //height of sunlight (point light) relative to the y position of the sun, the greater the distance the greater the amount of radiated light
        isPointLightPositionDirty: 1,
        isAmbientLightDirty: 1,

        //def 0.0,0.0,0.0 -> ambient light, the scene has a point light (the sun),
        //this parameter indicates how bright the scene is in case the point-light does
        //not affect what we are watching
        //by setting it to 0,0,0 we get colors with greater contrast
        ambientLightColorIntensity: [0.0, 0.0, 0.0], //black

        //this color changes according to the time regardless
        //of the light intensity. This parameter allows us to specify
        //which color is the global light
        //(the point light light componente is fixed into the fragment shader for simplicity)
        ambientLightColor: [1.0, 1.0, 1.0], //1,1,1 -> white

        //ambientLightColor:[22/255,4/255,2/255], //1,1,1 -> white
        //skyLightColor:[254/255,196/255,1/255], //2018-03-17 11:06:14 discontinued
        //ambientLightColor:[171/255,60/255,45/255], //1,1,1 -> white
        //ambientLightColor:[0.01,0.01,0.01], //1,1,1 -> white

        pMatrix: mat4.create(),
        mvMatrix: mat4.create() },


      //dynamic buffers (ummovable objects)
      //static world buffers (ummovable objects)
      vertexPositionBuffer: {}, //proc vertexPositionBuffer {blue indent_3}
      vertexTextureCoordBuffer: {}, //proc vertexTextureCoordBuffer {blue indent_3}
      //---
      init: function () {//proc init {green indent_3} WEBGL.WORLD.init

      },
      setCameraTo: function (cfg) {
        var config = {
          xPos: cfg.xPos,
          yPos: cfg.yPos,
          zPos: cfg.zPos,
          pitch: cfg.pitch,
          yaw: cfg.yaw };

        SEBASTIAN.WEBGL.WORLD.GLOBALS.xPos = config.xPos;
        SEBASTIAN.WEBGL.WORLD.GLOBALS.yPos = config.yPos;
        SEBASTIAN.WEBGL.WORLD.GLOBALS.zPos = config.zPos;
        SEBASTIAN.WEBGL.WORLD.GLOBALS.pitch = config.pitch;
        SEBASTIAN.WEBGL.WORLD.GLOBALS.yaw = config.yaw;
        SEBASTIAN.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 1;
      },

      syncAllTileBuffersData: function () {//proc syncAllTileBuffersData {green indent_4}
        //console.log('synca');
        //update the dynamic buffers of all the world tiles
        var _seba = SEBASTIAN;
        var worldData = _seba.GLOBALS.worldData;
        var dWorldTileSpriteColors = _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.data;

        for (var z = 0, zEnd = worldData.world.length; z < zEnd; z++) {
          var currentWorldTile = worldData.world[z];
          var idx4 = currentWorldTile.id * 6 * 4; //added alpha component
          //console.log(z,idx4);
          //vertex colors (4 points per vertex)
          dWorldTileSpriteColors[idx4 + 0] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 1] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 2] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 3] = currentWorldTile.opacity;

          dWorldTileSpriteColors[idx4 + 4] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 5] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 6] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 7] = currentWorldTile.opacity;

          dWorldTileSpriteColors[idx4 + 8] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 9] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 10] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 11] = currentWorldTile.opacity;

          dWorldTileSpriteColors[idx4 + 12] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 13] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 14] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 15] = currentWorldTile.opacity;

          dWorldTileSpriteColors[idx4 + 16] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 17] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 18] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 19] = currentWorldTile.opacity;

          dWorldTileSpriteColors[idx4 + 20] = currentWorldTile.color1[0];
          dWorldTileSpriteColors[idx4 + 21] = currentWorldTile.color1[1];
          dWorldTileSpriteColors[idx4 + 22] = currentWorldTile.color1[2];
          dWorldTileSpriteColors[idx4 + 23] = currentWorldTile.opacity;
        }

        //update the buffer only if necessary
        _seba.GLOBALS.isWorldTilesColorsDirty = 1;

      },
      syncTileBuffersData: function (currentWorldTile) {//proc syncTileBuffersData {green indent_4}
        //console.log('syncb');
        //update the dynamic buffers of the world tiles
        //console.log('xxx',currentWorldTile.id);
        var _seba = SEBASTIAN;
        var dWorldTileSpriteColors = _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.data;
        var dWorldTileEntityProperties = _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.data;
        var dWorldTileTextureCoords = _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.data;
        var currentTexture = _seba.WEBGL.GLOBALS.textures[currentWorldTile.textureId];

        var idx4 = currentWorldTile.id * 6 * 4; //2018-05-03 17:19:15 added alpha component
        var dWorldTileEntityPropertiesIdx = currentWorldTile.id * 6 * _seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties;
        var dWorldTileTextureCoordsIdx = currentWorldTile.id * 6 * 2;
        //vertex colors (3 points per vertex)
        dWorldTileSpriteColors[idx4 + 0] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 1] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 2] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 3] = currentWorldTile.opacity;

        dWorldTileSpriteColors[idx4 + 4] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 5] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 6] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 7] = currentWorldTile.opacity;

        dWorldTileSpriteColors[idx4 + 8] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 9] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 10] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 11] = currentWorldTile.opacity;

        dWorldTileSpriteColors[idx4 + 12] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 13] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 14] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 15] = currentWorldTile.opacity;

        dWorldTileSpriteColors[idx4 + 16] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 17] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 18] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 19] = currentWorldTile.opacity;

        dWorldTileSpriteColors[idx4 + 20] = currentWorldTile.color1[0];
        dWorldTileSpriteColors[idx4 + 21] = currentWorldTile.color1[1];
        dWorldTileSpriteColors[idx4 + 22] = currentWorldTile.color1[2];
        dWorldTileSpriteColors[idx4 + 23] = currentWorldTile.opacity;

        // simply copy the the selected texture coordinates
        // into the 'slot' of the current world tile within the buffer of texture coordinates

        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 0] = currentTexture.textureCoordinates[0];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 1] = currentTexture.textureCoordinates[1];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 2] = currentTexture.textureCoordinates[2];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 3] = currentTexture.textureCoordinates[3];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 4] = currentTexture.textureCoordinates[4];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 5] = currentTexture.textureCoordinates[5];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 6] = currentTexture.textureCoordinates[6];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 7] = currentTexture.textureCoordinates[7];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 8] = currentTexture.textureCoordinates[8];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 9] = currentTexture.textureCoordinates[9];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 10] = currentTexture.textureCoordinates[10];
        dWorldTileTextureCoords[dWorldTileTextureCoordsIdx + 11] = currentTexture.textureCoordinates[11];

        dWorldTileEntityProperties[dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0]; //texture X coord
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId; //sprite layer id
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4]; //texture X1 coord
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0; //is light emitter,apply shadow attenuation,isFlippedX
        //--
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId;
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0;
        //--
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId;
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0;
        //--
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId;
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0;
        //--
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId;
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0;
        //--
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[0];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.layerId;
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
        dWorldTileEntityProperties[++dWorldTileEntityPropertiesIdx] = 0.0;

        _seba.GLOBALS.isWorldTilesColorsDirty = 1;
        _seba.GLOBALS.isWorldTilesTextureCoordsDirty = 1;
        _seba.GLOBALS.isWorldTilesPropertiesDirty = 1;

      },
      draw: function (now) {//proc DRAW! {green bold indent_3}

        const _seba = SEBASTIAN; //performance lookup
        //var lastTime=;
        //console.log(now,lastTime);
        var elapsed = now - _seba.GLOBALS.lastTime;
        if (elapsed < _seba.GLOBALS.fpsInterval)
        return;
        //console.log(elapsed);

        //BEGIN RENDER

        //console.log('frame',new Date());

        var delta = elapsed;
        if (delta > _seba.GLOBALS.fpsInterval) //do not allow overflow
          delta = _seba.GLOBALS.fpsInterval;

        _seba.GLOBALS.lastTime = now;

        //          return;

        var oDate = new Date();

        //color timekey
        var h_key, m_key;
        var hours, minutes;
        if (_seba.GLOBALS.debugLightColors === 1) {//allows setting the time manually
          var tDate = new Date();
          var unixtime = tDate.getTime();
          unixtime += _seba.GLOBALS.timeTravel * 60 * 1000;
          tDate.setTime(unixtime);
          if (SEBASTIAN.GLOBALS.useUTCTime) {
            h_key = tDate.getUTCHours();
            m_key = tDate.getUTCMinutes();
          } else {
            h_key = tDate.getHours();
            m_key = tDate.getMinutes();
          }
          hours = h_key;
          minutes = m_key;
        } else {
          if (SEBASTIAN.GLOBALS.useUTCTime) {
            h_key = oDate.getUTCHours();
            m_key = oDate.getUTCMinutes();
          } else {
            h_key = oDate.getHours();
            m_key = oDate.getMinutes();
          }
          hours = h_key;
          minutes = m_key;
        }
        //if (h_key<10)
        //  h_key='0'+h_key;
        //if (m_key<10)
        //  m_key='0'+m_key;
        var colorKey = h_key + '_' + m_key;
        var timeIdx = hours * 60 + minutes; //this allows us to index the day in minutes

        //lookups
        var shaderProgram = _seba.WEBGL.GLOBALS.shaderProgram;
        //proc particles
        var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;
        var worldVertexPositionBuffer = _seba.WEBGL.WORLD.vertexPositionBuffer;
        var worldVertexTextureCoordBuffer = _seba.WEBGL.WORLD.vertexTextureCoordBuffer;
        var gl = _seba.GLOBALS.webgl_ctx; //lookup var
        var pitch = _seba.WEBGL.WORLD.GLOBALS.pitch;
        var yaw = _seba.WEBGL.WORLD.GLOBALS.yaw;
        var pMatrix = _seba.WEBGL.WORLD.GLOBALS.pMatrix;
        var mvMatrix = _seba.WEBGL.WORLD.GLOBALS.mvMatrix;
        var xPos = _seba.WEBGL.WORLD.GLOBALS.xPos;
        var yPos = _seba.WEBGL.WORLD.GLOBALS.yPos;
        var zPos = _seba.WEBGL.WORLD.GLOBALS.zPos;
        var degToRad = _seba.UTILS.degToRad;
        var textures = _seba.WEBGL.textures;
        var worldData = _seba.GLOBALS.worldData;
        var entitiesTotalProperties = _seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties;

        //proc particles
        gl.useProgram(shaderProgram);

        if (_seba.GLOBALS.firstDraw || _seba.GLOBALS.lastTimeKey === null || _seba.GLOBALS.lastTimeKey !== colorKey) {
          //console.log(tDate);
          //update time globals
          _seba.GLOBALS.firstDraw = 0;
          _seba.GLOBALS.hours = h_key; //tDate.getHours();
          _seba.GLOBALS.minutes = m_key; //tDate.getMinutes();
          //refresh clock
          var c_h_key = tDate.getHours();
          var c_m_key = tDate.getMinutes();
          if (c_h_key < 10)
          c_h_key = '0' + c_h_key;
          if (c_m_key < 10)
          c_m_key = '0' + c_m_key;
          SEBASTIAN.GLOBALS.clock.textContent = c_h_key + ':' + c_m_key;
          //map new colors
          //console.log('map color',colorKey,SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx);

          var brotherSun = worldData.entitiesNamePointer['sun'];
          var sisterMoon = worldData.entitiesNamePointer['moon'];
          var centerX = 0;
          var centerY = -25; //let's move the moon and the sun down a little bit so that they are more visible in our horizon
          var circleRadius = 120;
          var distance = 1440; //number of minutes in a day, corresponds to our time keys.
          //We want our stars (star and satellite to be precise)
          //to describe a circle based on the current minute.
          //I want the sun to be high at midday and low at midnight.
          //for the moon I want the exact opposite, ergo set a distance of 720 minutes between them
          //720 minutes = half of the minutes in a day
          //console.log(Math.acos(1-(Math.pow(distance/circleRadiusX,2)/2)));
          //arccos( 1-(d/r)^2/2 )
          //console.log(distance/circleRadiusX,2);
          //https://stackoverflow.com/questions/17384663/canvas-move-object-in-circle
          //https://www.safaribooksonline.com/library/view/html5-canvas/9781449308032/ch05s03.html
          //console.log(Math.pow(distance/circleRadiusX,2)/2);
          //console.log(Math.acos(1-Math.pow(distance/circleRadiusX,2)/2));
          //console.log(colorKey);
          var angle1 = (SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx + 720) * Math.PI / (360 * 2);
          var angle2 = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].idx * Math.PI / (360 * 2);
          //console.log();
          brotherSun.x = centerX + Math.sin(angle1) * circleRadius;
          brotherSun.y = centerY + Math.cos(angle1) * circleRadius;
          brotherSun.angle = angle1; //used to simplify light position calculations
          //brotherSun.z=-(centerY+Math.cos(angle)*circleRadius);
          //I would say to put an opacity to the moon in order to make it disappear when it's sunny...
          sisterMoon.x = centerX + Math.sin(angle2) * circleRadius;
          sisterMoon.y = centerY + Math.cos(angle2) * circleRadius;
          _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(brotherSun);
          _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(sisterMoon);

          //console.log((2 * Math.PI/60)*oDate.getSeconds());
          //ctx.rotate(((2 * Math.PI) / 60) * oDate.getSeconds() + ((2 * Math.PI) / 60000) * oDate.getMilliseconds());

          _seba.WEBGL.WORLD.GLOBALS.ambientLightColor = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].a;
          //_seba.WEBGL.WORLD.GLOBALS.skyLightColor=SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].a;
          document.body.style.background = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey].g;
          _seba.GLOBALS.lastTimeKey = colorKey;
          //the position of the light has changed
          _seba.WEBGL.WORLD.GLOBALS.isPointLightPositionDirty = 1;
          //the color of the light has changed
          _seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty = 1;
        }

        //read the mouse coordinates from the html
        var mx = _seba.GLOBALS.mx;
        var my = _seba.GLOBALS.my;
        var oMx = _seba.GLOBALS.oMx;
        var oMy = _seba.GLOBALS.oMy;

        if (worldVertexTextureCoordBuffer === null || worldVertexPositionBuffer === null)
        return;

        if (_seba.WEBGL.WORLD.GLOBALS.isViewportDirty) {//browser window resized
          // we need to calculate the perspective
          // only if the viewport is resized
          gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
          mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 200.0);
          gl.uniformMatrix4fv(shaderProgram.data.uPMatrix.location, false, pMatrix); //apply global projection matrix
          _seba.WEBGL.WORLD.GLOBALS.isViewportDirty = 0;

          //proc particles
          gl.useProgram(shaderProgramP); //switch to particles
          gl.uniformMatrix4fv(shaderProgramP.data.uPMatrix.location, false, pMatrix); //apply global projection matrix
          gl.useProgram(shaderProgram); //back to default

        }

        if (_seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty) {// modified camera position
          gl.uniform3f(shaderProgram.data.uCameraTranslation.location, xPos, yPos, zPos); // pass the position of the camera to the vertex shader

          //proc particles
          gl.useProgram(shaderProgramP); //switch to particles
          gl.uniform3f(shaderProgramP.data.uCameraTranslation.location, xPos, yPos, zPos); // pass the position of the camera to the vertex shader
          gl.useProgram(shaderProgram); //back to default

          _seba.WEBGL.WORLD.GLOBALS.isCameraPositionDirty = 0;

          // I have to perform entity position analysis and determine who is visible
          // 0 = I do not care to reorder on z
          // 1= I'm interested in determining visibility
          // 0= I do not care to know who is under the mouse

          _seba.WEBGL.WORLD.ENTITIES.checkEntitiesDepthVisibilityMousePos(0, 1, 0);
        }

        //clear the buffers
        //ref: https://stackoverflow.com/questions/19469194/why-do-we-have-to-clear-depth-buffer-in-opengl-during-rendering/19469291#19469291
        gl.clear(gl.COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT);

        // if a different rotation is applied than the one we have stored
        // Let's do some nice calculations.
        if (_seba.WEBGL.WORLD.GLOBALS.lPitch !== pitch || _seba.WEBGL.WORLD.GLOBALS.lYaw !== yaw) {
          mat4.identity(mvMatrix);
          if (pitch !== 0)
          mat4.rotate(mvMatrix, mvMatrix, degToRad(-pitch), [1, 0, 0]);
          if (yaw !== 0)
          mat4.rotate(mvMatrix, mvMatrix, degToRad(-yaw), [0, 1, 0]);
          _seba.WEBGL.WORLD.GLOBALS.lPitch = pitch;
          _seba.WEBGL.WORLD.GLOBALS.lYaw = yaw;
          //apply global viematrix only if a rotation is applied
          gl.uniformMatrix4fv(shaderProgram.data.uMVMatrix.location, false, mvMatrix);

          //proc particles
          gl.useProgram(shaderProgramP); //switch to particles
          gl.uniformMatrix4fv(shaderProgramP.data.uMVMatrix.location, false, mvMatrix);
          gl.useProgram(shaderProgram); //back to default

        }

        var foundTileUnderMouse = 0;
        var foundEntityUnderMouse = 0;
        var searchTile = 0;
        var searchEntity = 0;

        if (_seba.WEBGL.WORLD.GLOBALS.isPointLightPositionDirty) {
          // apply light-based calculations
          // only if the position of the light has changed
          var brotherSun = worldData.entitiesNamePointer['sun'];
          var sisterMoon = worldData.entitiesNamePointer['moon'];

          // change the vertical position of the light based on the time of day,
          // this allows us, for example, to create the silhouette effect during sunset or sunrise
          var sunLightVerticalDistance = _seba.WEBGL.WORLD.GLOBALS.sunLightVerticalDistance;

          //sunset
          sunLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            parameter: sunLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 17, fromMinutes: 45,
            toHours: 18, toMinutes: 15,
            fromValue: SEBASTIAN.WEBGL.WORLD.GLOBALS.sunLightVerticalDistance,
            toValue: 0 });

          //from after sunset to midnight
          sunLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: sunLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 18, fromMinutes: 16,
            toHours: 23, toMinutes: 59,
            fromValue: SEBASTIAN.WEBGL.WORLD.GLOBALS.sunLightVerticalDistance,
            toValue: -1600 });

          // from midnight to dawn
          sunLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: sunLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 0, fromMinutes: 0,
            toHours: 5, toMinutes: 44,
            fromValue: -1600,
            toValue: -400 });

          //Sunrise
          sunLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            applyTimeBouncing: 0,
            parameter: sunLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 5, fromMinutes: 45,
            toHours: 6, toMinutes: 15,
            fromValue: -400,
            toValue: SEBASTIAN.WEBGL.WORLD.GLOBALS.sunLightVerticalDistance });


          //MOON

          var moonLightVerticalDistance = -300;
          moonLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 17, fromMinutes: 16,
            toHours: 23, toMinutes: 59,
            fromValue: 30,
            toValue: 150 });

          //from midnight to before dawn
          moonLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 0, fromMinutes: 0,
            toHours: 5, toMinutes: 44,
            fromValue: 150,
            toValue: 50 });

          moonLightVerticalDistance = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonLightVerticalDistance,
            currentHour: hours, currentMinute: minutes,
            fromHours: 5, fromMinutes: 45,
            toHours: 6, toMinutes: 0,
            fromValue: 50,
            toValue: -300 });

          //the moon 'disappears' in the light of day
          var moonOpacity = 0;
          moonOpacity = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonOpacity,
            currentHour: hours, currentMinute: minutes,
            fromHours: 18, fromMinutes: 0,
            toHours: 21, toMinutes: 0,
            fromValue: 0,
            toValue: 1 });

          moonOpacity = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonOpacity,
            currentHour: hours, currentMinute: minutes,
            fromHours: 21, fromMinutes: 1,
            toHours: 23, toMinutes: 59,
            fromValue: 1,
            toValue: 1 });

          moonOpacity = SEBASTIAN.UTILS.applyTimeCalc({
            //logInfo:1,
            applyTimeBouncing: 0,
            parameter: moonOpacity,
            currentHour: hours, currentMinute: minutes,
            fromHours: 0, fromMinutes: 0,
            toHours: 5, toMinutes: 45,
            fromValue: 1,
            toValue: 0 });


          //2018-05-31 10:41:00 fade to gray the background if needed
          //this include sun opacity status variation
          //proc rain controller {indent_4}
          _seba.UTILS.backgroundGradientFadeToGray();

          sisterMoon.opacity = moonOpacity;
          _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(sisterMoon); //update alpha

          //console.log(moonLightVerticalDistance);
          //console.log(parseFloat(t).toFixed(2),parseFloat(brotherSun.angle).toFixed(2),sunLightVerticalPosition);
          gl.uniform3f(shaderProgram.data.uPointLighting1Location.location, brotherSun.x, brotherSun.y + sunLightVerticalDistance, brotherSun.z);

          // instead of lowering the intensity of the moonlight in the vertex shader
          // make sure that the light is less high than the satellite in order to illuminate less
          gl.uniform3f(shaderProgram.data.uPointLighting2Location.location, sisterMoon.x, sisterMoon.y + moonLightVerticalDistance, sisterMoon.z);

          gl.useProgram(shaderProgramP);
          gl.uniform3f(shaderProgramP.data.uPointLighting1Location.location, brotherSun.x, brotherSun.y + sunLightVerticalDistance, brotherSun.z);
          gl.uniform3f(shaderProgramP.data.uPointLighting2Location.location, sisterMoon.x, sisterMoon.y + moonLightVerticalDistance, sisterMoon.z);
          gl.useProgram(shaderProgram);

          _seba.WEBGL.WORLD.GLOBALS.isPointLightPositionDirty = 0;
        }

        if (_seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty) {
          gl.uniform3fv(shaderProgram.data.uAmbientLightColorIntensity.location, _seba.WEBGL.WORLD.GLOBALS.ambientLightColorIntensity); //set ambient light intensity
          gl.uniform3fv(shaderProgram.data.uAmbientLightColor.location, _seba.WEBGL.WORLD.GLOBALS.ambientLightColor); //set ambient light color
          gl.uniform1f(shaderProgram.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set gray color

          gl.useProgram(shaderProgramP);
          gl.uniform1f(shaderProgramP.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
          gl.uniform3fv(shaderProgramP.data.uAmbientLightColorIntensity.location, _seba.WEBGL.WORLD.GLOBALS.ambientLightColorIntensity); //set ambient light intensity
          gl.uniform3fv(shaderProgramP.data.uAmbientLightColor.location, _seba.WEBGL.WORLD.GLOBALS.ambientLightColor); //set ambient light color
          gl.useProgram(shaderProgram);
        }

        var drawCalls = 0;

        //proc TILES {indent_4}
        //first we draw the static world, it has no transparencies
        gl.depthMask(true); //this disables alpha blending, if we were to render a texture with alpha it would have a solid background

        var skippedTiles = 0;

        var vertexPositions = _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.data;
        for (var z = 0, zEnd = worldData.world.length; z < zEnd; z++) {
          var currentWorldTile = worldData.world[z];

          //if (z===20){
          //  console.log(vertexPositions[z*6*3+2]);
          //}

          if (_seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty) {// This must be done regardless of the visibility of the tile
            var clockKey = _seba.GLOBALS.lastTimeKey;
            var colorsPoolIdx = currentWorldTile.colorsPoolIdx;
            var chosenColor = SEBASTIAN.GLOBALS.lightColorTimeMap[clockKey][colorsPoolIdx];
            currentWorldTile.color1 = chosenColor;
            currentWorldTile.oColor1 = chosenColor;
            // it makes no sense to sync one tile at a time.
            // run a single call at the end
            //_seba.WEBGL.WORLD.syncTileBuffersData(currentWorldTile);
          }

          //drawCalls++;
        }
        //          _seba.GLOBALS.isMouseDirty=0;

        //update the color of the tiles if necessary
        if (_seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty) {
          _seba.WEBGL.WORLD.syncAllTileBuffersData();
        }

        // worldtile buffers data do not change with each drawcall
        // only in the in case something changes during editing -> update them

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.buffer);
        if (_seba.GLOBALS.isWorldTilesTextureCoordsDirty) {
          gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.data, gl.DYNAMIC_DRAW);
          _seba.GLOBALS.isWorldTilesTextureCoordsDirty = 0;
        }
        gl.vertexAttribPointer(shaderProgram.data.aTextureCoord.location, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTranslations.buffer);
        gl.vertexAttribPointer(shaderProgram.data.aEntityTranslation.location, 3, gl.FLOAT, false, 0, 0);

        //replace the color buffer data once a minute (see WORLD.syncTileBuffersData)
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.buffer);
        if (_seba.GLOBALS.isWorldTilesColorsDirty) {
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.data);
          _seba.GLOBALS.isWorldTilesColorsDirty = 0;
        }
        gl.vertexAttribPointer(shaderProgram.data.aEntityColor.location, 4, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.buffer);
        if (_seba.GLOBALS.isWorldTilesPropertiesDirty) {
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.data);
          _seba.GLOBALS.isWorldTilesPropertiesDirty = 0;
        }
        gl.vertexAttribPointer(shaderProgram.data.aEntityProperties.location, entitiesTotalProperties, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.buffer);
        if (_seba.GLOBALS.isWorldTilesVerticesPositionDirty) {
          //since we allow editing of the vertices, apply them for the current drawcall if they have been modified
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.data); // this makes the position of the vertices dynamic, in case we use static terrain we can remove this line
          _seba.GLOBALS.isWorldTilesVerticesPositionDirty = 0;
        }
        gl.vertexAttribPointer(shaderProgram.data.aVertexPosition.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.count);

        //----------------------

        //proc ENTITIES {indent_4}
        //now we draw entities that have transparent PNGs as textures

        //proc particles code goes here
        gl.depthMask(false); //disabling depth mask we can have alpha objects but we have to sort them
        gl.useProgram(shaderProgramP);
        gl.uniform1f(shaderProgramP.data.uTimeDelta.location, _seba.GLOBALS.timeDelta); // pass the elapsed time
        gl.uniform1f(shaderProgramP.data.uDelta.location, delta); // pass the frame delta
        //--
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shaderProgramP.data.indicesStruct.buffer);
        if (_seba.GLOBALS.isParticlesBufferDataDirty) {
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shaderProgramP.data.indicesStruct.data, gl.DYNAMIC_DRAW);
          //time to enable attributes
          gl.enableVertexAttribArray(shaderProgramP.data.aVertexPosition.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleInitPosition.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleVelocity.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleType.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleDestination.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleTranslation.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleLifetime.location);
          gl.enableVertexAttribArray(shaderProgramP.data.aParticleColor.location);
          //--
          //console.log('dirty');
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, shaderProgramP.data.interleavedStruct.buffer);
        if (_seba.GLOBALS.isParticlesBufferDataDirty) {
          gl.bufferData(gl.ARRAY_BUFFER, shaderProgramP.data.interleavedStruct.data, gl.DYNAMIC_DRAW);
          //console.log('diana');
        }
        var stride = shaderProgramP.data.interleavedStruct.stride;
        gl.vertexAttribPointer(shaderProgramP.data.aVertexPosition.location, 3, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleInitPosition.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 3);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleVelocity.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 6);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleType.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 7);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleDestination.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 8);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleTranslation.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 11);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleLifetime.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 14);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleColor.location, 4, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 15);

        //gl.drawArrays(gl.TRIANGLES,0,4*shaderProgramP.data.interleavedStruct.elementsCount);
        //console.log(shaderProgramP.data.indicesStruct.elementsCount);
        //gl.drawElements(gl.TRIANGLES,60000,gl.UNSIGNED_SHORT,120000);

        //console.log(delta);
        var rdcc = shaderProgramP.data.indicesStruct.rainDropsCollisionsCount * _seba.WEBGL.WORLD.GLOBALS.rainDelta;
        gl.drawElements(gl.TRIANGLES, 6 * rdcc, gl.UNSIGNED_SHORT, 6 * shaderProgramP.data.indicesStruct.rainDropsCount * Uint16Array.BYTES_PER_ELEMENT);
        _seba.GLOBALS.timeDelta += 0.001 * delta;

        //necessaria solo se spostiamo codice prima del render delle entities
        gl.useProgram(shaderProgram);

        //proc particles code end

        var depths = _seba.WEBGL.WORLD.ENTITIES.GLOBALS.depthSorted;

        //writing into the depth buffer is now disabled.
        gl.depthMask(false); //disabling depth mask we can have alpha objects but we have to sort them

        for (var z = 0, zEnd = worldData.entities.length; z < zEnd; z++) {
          var currentEntity = worldData.entities[depths[z].entityId]; // obtain the ordered entities based on depth, and we use the painter algorithm to draw them

          if (currentEntity.isHidden === 1) // entities such as clusters are hidden. (in fact they are always drawn because the data is in the buffer array, but with negative x)
            continue;

          //todo: this is perhaps less expensive to do once and for all entities
          if (_seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty) {
            // update color pool if necessary
            // this same routine manages the dynamic color of the single entities dDMKCWhHp4
            if (currentEntity.hasPoolColor === 1) {
              var clockKey = _seba.GLOBALS.lastTimeKey;
              var colorsPoolIdx = currentEntity.colorsPoolIdx;
              var chosenColor = SEBASTIAN.GLOBALS.lightColorTimeMap[clockKey][colorsPoolIdx];
              currentEntity.color1 = chosenColor;
              currentEntity.oColor1 = chosenColor;
              SEBASTIAN.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
            }
          }

          _seba.WEBGL.WORLD.ENTITIES.animate(currentEntity.id, delta, timeIdx);

          if (currentEntity.isVisible === 0) // non-visible entities are still animated at position level, but not geometry
            continue;

          _seba.WEBGL.WORLD.ENTITIES.animateGeometry(currentEntity.id, delta);
        }

        //proc reset isAmbientLightDirty flag {indent_4}
        if (_seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty) {
          _seba.WEBGL.WORLD.GLOBALS.isAmbientLightDirty = 0;
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ.buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ.data);
        gl.vertexAttribPointer(shaderProgram.data.aTextureCoord.location, 2, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data);
        gl.vertexAttribPointer(shaderProgram.data.aEntityTranslation.location, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ.buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ.data);
        gl.vertexAttribPointer(shaderProgram.data.aEntityColor.location, 4, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ.buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ.data);
        gl.vertexAttribPointer(shaderProgram.data.aEntityProperties.location, entitiesTotalProperties, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.buffer);
        gl.bufferSubData(gl.ARRAY_BUFFER, 0, _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.data);
        gl.vertexAttribPointer(shaderProgram.data.aVertexPosition.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.count);

        if (_seba.GLOBALS.isEditorEnabled) {
          var colorsPoolIdx = 'p' + _seba.GLOBALS.tilesColorPool[_seba.GLOBALS.tilesColorPoolIdx];
          var chosenTileColor = SEBASTIAN.GLOBALS.lightColorTimeMap[_seba.GLOBALS.lastTimeKey][colorsPoolIdx];
          var sCol = 'rgb(' + Math.round(chosenTileColor[0] * 255) + ',' + Math.round(chosenTileColor[1] * 255) + ',' + Math.round(chosenTileColor[2] * 255) + ')';
          var sTileColor = '<div style=&quot;display:inline-block;width:10px;height:10px;background-color:' + sCol + '&quot;></div>';
          var sTileOpacity = _seba.GLOBALS.tilesOpacityPool[_seba.GLOBALS.tilesOpacityPoolIdx];
          var sTileTexture = _seba.GLOBALS.tilesTexturePool[_seba.GLOBALS.tilesTexturePoolIdx];

          var sMapEditorCurrentEntityGroup = _seba.GLOBALS.mapEntityGroups[_seba.GLOBALS.mapEntityGroupsIdx];

          //document.getElementById('debug').innerHTML='group:'+sMapEditorCurrentEntityGroup+' tileTexure:'+sTileTexture+' tileColor:'+sTileColor+' tileOpacity:'+sTileOpacity+' tile:'+_seba.GLOBALS.currentTileId+' skipped tiles:'+skippedTiles+' skipped entities:'+skippedEntities+' drawCalls:'+drawCalls;
          document.getElementById('debug').innerHTML = 'group:' + sMapEditorCurrentEntityGroup + ' tileTexure:' + sTileTexture + ' tileColor:' + sTileColor + ' tileOpacity:' + sTileOpacity + ' tile:' + _seba.GLOBALS.currentTileId;
        }

        gl.useProgram(shaderProgramP);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shaderProgramP.data.indicesStruct.buffer);
        gl.bindBuffer(gl.ARRAY_BUFFER, shaderProgramP.data.interleavedStruct.buffer);
        //var stride=shaderProgramP.data.interleavedStruct.stride;
        gl.vertexAttribPointer(shaderProgramP.data.aVertexPosition.location, 3, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleInitPosition.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 3);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleVelocity.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 6);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleType.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 7);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleDestination.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 8);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleTranslation.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 11);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleLifetime.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 14);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleColor.location, 4, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 15);
        var rdc = shaderProgramP.data.indicesStruct.rainDropsCount * _seba.WEBGL.WORLD.GLOBALS.rainDelta;
        gl.drawElements(gl.TRIANGLES, 6 * rdc, gl.UNSIGNED_SHORT, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shaderProgramP.data.userParticles.indicesStruct.buffer);
        if (_seba.GLOBALS.isParticlesBufferDataDirty) {
          if (shaderProgramP.data.userParticles.indicesStruct.elementsCount > 0) {
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, shaderProgramP.data.userParticles.indicesStruct.data, gl.DYNAMIC_DRAW);
          }
          //console.log('dirty2');
        }

        gl.bindBuffer(gl.ARRAY_BUFFER, shaderProgramP.data.userParticles.interleavedStruct.buffer);
        if (_seba.GLOBALS.isParticlesBufferDataDirty) {
          if (shaderProgramP.data.userParticles.indicesStruct.elementsCount > 0) {
            gl.bufferData(gl.ARRAY_BUFFER, shaderProgramP.data.userParticles.interleavedStruct.data, gl.DYNAMIC_DRAW);
          }
          //console.log('diana2');
          _seba.GLOBALS.isParticlesBufferDataDirty = 0;
        }

        //var stride=shaderProgramP.data.interleavedStruct.stride;
        gl.vertexAttribPointer(shaderProgramP.data.aVertexPosition.location, 3, gl.FLOAT, false, stride, 0);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleInitPosition.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 3);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleVelocity.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 6);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleType.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 7);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleDestination.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 8);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleTranslation.location, 3, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 11);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleLifetime.location, 1, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 14);
        gl.vertexAttribPointer(shaderProgramP.data.aParticleColor.location, 4, gl.FLOAT, false, stride, Float32Array.BYTES_PER_ELEMENT * 15);
        gl.drawElements(gl.TRIANGLES, 6 * shaderProgramP.data.userParticles.indicesStruct.elementsCount, gl.UNSIGNED_SHORT, 0);

        //proc particles code end

        //It was fun. ALL DONE.
      },

      load: function (callback) {//proc load WORLD/SCENE {green indent_3 bold}
        var request = new XMLHttpRequest();

        //proc sebastian {indent_5 red}

        //proc codepen {indent_5 red}

        request.open('GET', 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/1981998/scene.eiv4.json');

        //proc builder {indent_5 red}

        //proc buildercodepen {indent_5 red bviolet}

        //proc none {indent_5 red}

        request.onreadystatechange = function () {
          if (request.readyState === 4) {
            SEBASTIAN.WEBGL.WORLD.onloadHandler(request.responseText, callback);
          }
        };
        request.send();
      },

      onloadHandler: function (data, callback) {//proc onloadHandler WORLD/SCENE {green indent_3}
        var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
        var worldData = JSON.parse(data);
        var _seba = SEBASTIAN;
        _seba.GLOBALS.worldData = worldData;

        //console.log(worldData.entities.length);

        //proc USER PARTICLES {violet bold indent_4}
        //particles load init
        if (typeof worldData.userParticles !== 'undefined') {
          var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;

          //    var triangleStrippedQuad=shaderProgramP.data.userParticles.triangleStrippedQuad;
          shaderProgramP.data.userParticles.indices = worldData.userParticles.indices;
          SEBASTIAN.GLOBALS.currentSelectedParticles = worldData.userParticles.currentSelectedParticles;
          SEBASTIAN.GLOBALS.currentSelectedParticlesGIdx = worldData.userParticles.currentSelectedParticlesGIdx;
          shaderProgramP.data.userParticles.indicesIdx = worldData.userParticles.indicesIdx;
          shaderProgramP.data.userParticles.indicesStruct.elementsCount = worldData.userParticles.indicesStruct.elementsCount;
          shaderProgramP.data.userParticles.indicesBuffer = worldData.userParticles.indicesBuffer;
          shaderProgramP.data.userParticles.indicesStruct.data = new Uint16Array(shaderProgramP.data.userParticles.indicesBuffer);
          shaderProgramP.data.userParticles.verticesbuffer = worldData.userParticles.verticesbuffer;
          shaderProgramP.data.userParticles.interleavedStruct.data = new Float32Array(shaderProgramP.data.userParticles.verticesbuffer);
          _seba.GLOBALS.currentSelectedParticlesIdx = SEBASTIAN.GLOBALS.currentSelectedParticles.length - 1;

          //update buffers
          _seba.GLOBALS.isParticlesBufferDataDirty = 1; //force particles buffer data mapping
          //SEBASTIAN.GLOBALS.currentSelectedParticles.push(currentSelectedParticles);
          //SEBASTIAN.GLOBALS.currentSelectedParticlesGIdx=currentSelectedParticlesGIdx;
          //_seba.GLOBALS.currentSelectedParticlesIdx=SEBASTIAN.GLOBALS.currentSelectedParticles.length-1;
          var particleSelectionColor = _seba.GLOBALS.particleSelectionColor;
          _seba.WEBGL.WORLD.PARTICLES.updateCurrentSelectedGroup({ r: particleSelectionColor[0], g: particleSelectionColor[1], b: particleSelectionColor[2] });
          //particles load end
        }

        //proc WORLD ENTITIES {violet bold indent_4}
        for (var z = 0, zEnd = worldData.entities.length; z < zEnd; z++) {
          worldData.entities[z].id = z;
          worldData.entities[z].x = parseFloat(worldData.entities[z].x);
          worldData.entities[z].y = parseFloat(worldData.entities[z].y);
          worldData.entities[z].z = parseFloat(worldData.entities[z].z);
          //handle undef neeeded props
          if (typeof worldData.entities[z].isLivingBeing === 'undefined')
          worldData.entities[z].isLivingBeing = 0;
          if (typeof worldData.entities[z].color1 === 'undefined')
          worldData.entities[z].color1 = [1.0, 1.0, 1.0];
          worldData.entities[z].oColor1 = worldData.entities[z].color1; //original color1
          if (typeof worldData.entities[z].speed === 'undefined') {
            worldData.entities[z].speed = 0;
          }

          worldData.entities[z].oTextureId = worldData.entities[z].textureId; // save the original texture without animations, we need it to save the scene
          worldData.entities[z].oY = worldData.entities[z].y; // save the original Y
          // init of the entities read from file
          SEBASTIAN.WEBGL.WORLD.ENTITIES.define(z);
          //SEBASTIAN.WEBGL.WORLD.dynamicVertexTextureCoordBuffers[z]=worldVertexTextureCoordBuffer;
        }

        // after the define cycle we have the actual number of existing entities
        //console.log(worldData.entities.length);

        //init buffers
        _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositions = {};

        // create buffers for Z sorting
        // the vertex coordinate buffer exists in two forms:
        // not ordered and ordered in z
        // for the representation of the entities we use the z-sorted buffer
        _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ = {
          buffer: gl.createBuffer(),
          data: new Float32Array(worldData.entities.length * 6 * 2) };

        //--
        _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ = { // identical to entitiesVertexPositions but sorted into z, we keep the unordered buffer to access the original coordinates of the entities
          buffer: gl.createBuffer(),
          data: new Float32Array(worldData.entities.length * 6 * 3),
          count: 6 * worldData.entities.length };

        //--
        _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ = {
          buffer: gl.createBuffer(),
          data: new Float32Array(worldData.entities.length * 6 * 3) };

        //--
        _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ = {
          buffer: gl.createBuffer(),
          data: new Float32Array(worldData.entities.length * 6 * 4) };

        //--
        _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ = {
          buffer: gl.createBuffer(),
          data: new Float32Array(worldData.entities.length * 6 * _seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties) //3 propriet per ogni entity
        };

        //
        var bEntitiesVertexPositions = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositions;
        bEntitiesVertexPositions.data = new Float32Array(worldData.entities.length * 6 * 3);

        //fill entities buffer data
        var bEntitiesVertexPositionsIdx = 0;
        for (var z = 0, zEnd = worldData.entities.length; z < zEnd; z++) {
          var currentEntity = worldData.entities[z];

          var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.oTextureId];
          if (typeof currentTexture === 'undefined') {
            currentTexture = _seba.WEBGL.GLOBALS.textures['pavement_01'];
            console.log(currentEntity.oTextureId, '->', 'pavement_01');
          }

          if (currentEntity.isStanding === 1) {
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 0] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 1] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 2] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 3] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 4] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 5] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 6] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 7] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 8] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 9] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 10] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 11] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 12] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 13] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 14] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 15] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 16] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 17] = 0.0;

            //if (currentEntity.oTextureId.indexOf('grass')!==-1){
            //  console.log(currentEntity.oTextureId,currentEntity.scale,currentTexture.scaleX);
            //}

          } else {//entities such as water

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 0] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 1] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 2] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 3] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 4] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 5] = 1.0 * currentEntity.scale * currentTexture.scaleY;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 6] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 7] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 8] = 1.0 * currentEntity.scale * currentTexture.scaleY;;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 9] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 10] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 11] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 12] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 13] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 14] = 0.0;

            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 15] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 16] = 0.0;
            bEntitiesVertexPositions.data[bEntitiesVertexPositionsIdx + 17] = 1.0 * currentEntity.scale * currentTexture.scaleY;
          }

          bEntitiesVertexPositionsIdx += 18;

        }

        //Once the buffers are created, sort them by the z by position
        //of the entities
        SEBASTIAN.WEBGL.WORLD.ENTITIES.sortZBuffersByEntityPosition();

        //proc WORLD TILES {violet bold indent_4}

        //proc PARSE WORLD FILE > STATIC VERTEX DATA {yellow indent_4}
        //---------
        //STATIC WORLD DATA
        //vertices that can not move
        //--

        var wordlTileColumns = SEBASTIAN.WEBGL.WORLD.GLOBALS.columns;
        var wordlTileTotalTiles = wordlTileColumns * SEBASTIAN.WEBGL.WORLD.GLOBALS.rows;
        var offsetX = 0;
        var offsetZ = 0;
        var tileScale = 1;
        var currentTexture; //pointer to the texture applied to the tile

        //2018-03-22 13:13:51 add dynamic colors to world tiles
        var tileDefaultPoolColor = 'C1'; //proc default tile color {violet indent_5}
        //--

        var h_key = SEBASTIAN.GLOBALS.hours; //=tDate.getUTCHours();
        var m_key = SEBASTIAN.GLOBALS.minutes; //=tDate.getUTCMinutes();
        var colorKey = h_key + '_' + m_key;
        var colorsPoolIdx = 'p' + tileDefaultPoolColor;
        var chosenTileColor = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey][colorsPoolIdx];

        var counter = 0;
        var initOffsetX = offsetX;
        if (typeof worldData.world === 'undefined')
        worldData.world = [];

        //init buffers
        _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords = {};
        _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions = {};
        _seba.WEBGL.GLOBALS.buffers.worldTileTranslations = {};
        _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors = {};
        _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties = {};
        var bWorldTileTextureCoords = _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords;
        var bWorldTileVertexPositions = _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions;
        var bWorldTileTranslations = _seba.WEBGL.GLOBALS.buffers.worldTileTranslations;
        var bWorldTileSpriteColors = _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors;
        var bWorldTileEntityProperties = _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties;
        //--
        var bWorldTileTextureCoordsIdx = 0;
        var bWorldTileVertexPositionsIdx = 0;
        var bWorldTileTranslationsIdx = 0;
        var bWorldTileSpriteColorsIdx = 0;
        var bWorldTileEntityPropertiesIdx = 0;

        // for textures we need two coordinates for each vertex of the two triangles
        // the two triangles make 6 vertices in total
        bWorldTileTextureCoords.data = new Float32Array(wordlTileTotalTiles * 6 * 2);
        //for the buffer of the vertices we need 3 coordinates for each vertex of the two triangles
        //then 3 coordinates (x, y, z) for each of the 6 vertices = 6 * 3
        bWorldTileVertexPositions.data = new Float32Array(wordlTileTotalTiles * 6 * 3);
        bWorldTileTranslations.data = new Float32Array(wordlTileTotalTiles * 6 * 3);
        bWorldTileSpriteColors.data = new Float32Array(wordlTileTotalTiles * 6 * 4); //2018-05-03 16:48:33 added alpha r,g,b,a
        bWorldTileEntityProperties.data = new Float32Array(wordlTileTotalTiles * 6 * _seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties);

        if (SEBASTIAN.GLOBALS.loadSavedScene) {
          //load the scene.json file

          for (var z = 0, zEnd = worldData.world.length; z < zEnd; z++) {
            var currentWorldTile = worldData.world[z];
            //handle undef neeeded props
            if (typeof currentWorldTile.color1 === 'undefined')
            currentWorldTile.color1 = [1.0, 1.0, 1.0];
            currentWorldTile.oColor1 = currentWorldTile.color1; //original color
            currentWorldTile.oTextureId = currentWorldTile.textureId; //original texture so we are able able to change it during selection and saving
          }

          //set camera from scene
          if (typeof worldData.camera !== 'undefined') {
            SEBASTIAN.WEBGL.WORLD.GLOBALS.yPos = worldData.camera.yPos;
            SEBASTIAN.WEBGL.WORLD.GLOBALS.xPos = worldData.camera.xPos;
            SEBASTIAN.WEBGL.WORLD.GLOBALS.zPos = worldData.camera.zPos;
            SEBASTIAN.WEBGL.WORLD.GLOBALS.pitch = worldData.camera.pitch;
            SEBASTIAN.WEBGL.WORLD.GLOBALS.yaw = worldData.camera.yaw;
          }

          //set random camera
          if (
          typeof SEBASTIAN.GLOBALS.chooseRandomCameraKeyPoint !== 'undefined' &amp;&amp;
          SEBASTIAN.GLOBALS.chooseRandomCameraKeyPoint)
          {
            var cameraKeyPointsLen = SEBASTIAN.GLOBALS.cameraKeyPoints.length;
            var randomCameraKeyPoint = SEBASTIAN.GLOBALS.cameraKeyPoints[Math.floor(Math.random() * cameraKeyPointsLen)]; //https://stackoverflow.com/questions/4550505/getting-a-random-value-from-a-javascript-array
            SEBASTIAN.WEBGL.WORLD.setCameraTo(randomCameraKeyPoint);
          } else {
            SEBASTIAN.WEBGL.WORLD.setCameraTo(SEBASTIAN.GLOBALS.cameraKeyPoints[0]);
          }

          //set random weather
          if (typeof _seba.GLOBALS.chooseRandomWeather !== 'undefined' &amp;&amp; _seba.GLOBALS.chooseRandomWeather) {
            var chanceOfRain = _seba.GLOBALS.chanceOfRain;
            var dice = Math.random();
            //console.log('the dice',dice);
            if (dice <= chanceOfRain) {
              _seba.WEBGL.WORLD.GLOBALS.rainDelta = Math.random() + 0.3;
              if (_seba.WEBGL.WORLD.GLOBALS.rainDelta > 1)
              _seba.WEBGL.WORLD.GLOBALS.rainDelta = 1;
              var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
              var shaderProgram = _seba.WEBGL.GLOBALS.shaderProgram;
              var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;
              gl.useProgram(shaderProgram);
              gl.uniform1f(shaderProgram.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
              gl.useProgram(shaderProgramP);
              gl.uniform1f(shaderProgramP.data.uRainDelta.location, _seba.WEBGL.WORLD.GLOBALS.rainDelta); //set ambient light color
              _seba.UTILS.backgroundGradientFadeToGray();
            }

          }

          //restore vertices position into the typed Array
          bWorldTileVertexPositions.data.set(worldData.worldTilesVertices);
        }

        for (var z = 0; z < wordlTileTotalTiles; z++) {

          //set default tile data
          if (typeof worldData.world[z] === 'undefined')
          worldData.world[z] = {};

          var currentWorldTile = worldData.world[z];

          currentWorldTile.id = z;

          if (!SEBASTIAN.GLOBALS.loadSavedScene) {

            currentWorldTile.color1 = [1.0, 1.0, 1.0];
            currentWorldTile.opacity = 1.0;
            currentWorldTile.oColor1 = worldData.world[z].color1;
            currentWorldTile.textureId = 'pavement_01';
            currentWorldTile.oTextureId = worldData.world[z].textureId; //saved so we can 'select' a tile by switching textures
            currentWorldTile.colorsPoolIdx = colorsPoolIdx; //set colorPool index
            currentTexture = _seba.WEBGL.GLOBALS.textures[currentWorldTile.textureId];

            //vertices         texture coordinates
            // 0.0  0.0  0.0   0.0  1.0   //a  0, 1, 2
            // 0.0  0.0  1.0   0.0  0.0   //b  3, 4, 5
            // 1.0  0.0  1.0   1.0  0.0   //c  6, 7, 8
            //
            // 0.0  0.0  0.0   0.0  1.0   //d  9,10,11
            // 1.0  0.0  0.0   1.0  1.0   //e 12,13,14
            // 1.0  0.0  1.0   1.0  0.0   //f 15,16,17

            //vertexPositions
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 0] = 0.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 1] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 2] = 0.0 * tileScale * currentTexture.scaleY + offsetZ;

            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 3] = 0.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 4] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 5] = 1.0 * tileScale * currentTexture.scaleY + offsetZ;

            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 6] = 1.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 7] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 8] = 1.0 * tileScale * currentTexture.scaleY + offsetZ;

            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 9] = 0.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 10] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 11] = 0.0 * tileScale * currentTexture.scaleY + offsetZ;

            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 12] = 1.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 13] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 14] = 0.0 * tileScale * currentTexture.scaleY + offsetZ;

            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 15] = 1.0 * tileScale * currentTexture.scaleX + offsetX;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 16] = 0.0;
            bWorldTileVertexPositions.data[bWorldTileVertexPositionsIdx + 17] = 1.0 * tileScale * currentTexture.scaleY + offsetZ;
            bWorldTileVertexPositionsIdx += 18;
          } else {
            //if we do not load a scene, we just need to set the current texture
            currentTexture = _seba.WEBGL.GLOBALS.textures[currentWorldTile.textureId];
          }
          if (typeof currentWorldTile.textureId === 'undefined') {
            currentWorldTile.textureId = 'pavement_01';
            currentTexture = _seba.WEBGL.GLOBALS.textures[currentWorldTile.textureId];
          }

          //copy the coordinates of the selected texture into
          //the current world tile slot in the texture coordinate buffer
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 0] = currentTexture.textureCoordinates[0];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 1] = currentTexture.textureCoordinates[1];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 2] = currentTexture.textureCoordinates[2];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 3] = currentTexture.textureCoordinates[3];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 4] = currentTexture.textureCoordinates[4];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 5] = currentTexture.textureCoordinates[5];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 6] = currentTexture.textureCoordinates[6];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 7] = currentTexture.textureCoordinates[7];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 8] = currentTexture.textureCoordinates[8];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 9] = currentTexture.textureCoordinates[9];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 10] = currentTexture.textureCoordinates[10];
          bWorldTileTextureCoords.data[bWorldTileTextureCoordsIdx + 11] = currentTexture.textureCoordinates[11];
          bWorldTileTextureCoordsIdx += 12;

          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 0] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 1] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 2] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 3] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 4] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 5] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 6] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 7] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 8] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 9] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 10] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 11] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 12] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 13] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 14] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 15] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 16] = 0.0;
          bWorldTileTranslations.data[bWorldTileTranslationsIdx + 17] = 0.0;
          bWorldTileTranslationsIdx += 18;

          //colors

          //we do not need to specify an initial color because
          //the first draw will automatically determine the color of the tiles based
          //on their colorDynamic property
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 0] = 1.0; //r
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 1] = 1.0; //g
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 2] = 1.0; //b
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 3] = currentWorldTile.opacity; //a

          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 4] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 5] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 6] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 7] = currentWorldTile.opacity;

          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 8] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 9] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 10] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 11] = currentWorldTile.opacity;

          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 12] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 13] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 14] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 15] = currentWorldTile.opacity;

          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 16] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 17] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 18] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 19] = currentWorldTile.opacity;

          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 20] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 21] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 22] = 1.0;
          bWorldTileSpriteColors.data[bWorldTileSpriteColorsIdx + 23] = currentWorldTile.opacity;
          bWorldTileSpriteColorsIdx += 24;

          //proc TILES.PROPERTIES.FLAGS {violet bold indent_4}
          bWorldTileEntityProperties.data[bWorldTileEntityPropertiesIdx] = currentTexture.oX; //texture coord x
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId; //sprite layer id
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4]; //texture coord x1
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0; //is light emitter, apply shadow attenuation, is x flipped
          //--
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.oX;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0;
          //--
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.oX;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0;
          //--
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.oX;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0;
          //--
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.oX;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0;
          //--
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.oX;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.layerId;
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = currentTexture.textureCoordinates[4];
          bWorldTileEntityProperties.data[++bWorldTileEntityPropertiesIdx] = 0.0;
          bWorldTileEntityPropertiesIdx++;

          counter++;
          offsetX += tileScale * 1;
          if (counter % wordlTileColumns === 0) {
            offsetX = initOffsetX;
            offsetZ += tileScale;
          }

        }

        //create the buffers for the worldtiles

        _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTextureCoords.data, gl.DYNAMIC_DRAW);

        _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.data, gl.DYNAMIC_DRAW);
        _seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.count = wordlTileTotalTiles * 6;
        //console.log(_seba.WEBGL.GLOBALS.buffers.worldTileVertexPositions.data,wordlTileTotalTiles);

        _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileSpriteColors.data, gl.DYNAMIC_DRAW);

        _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileEntityProperties.data, gl.DYNAMIC_DRAW);

        //the position of the world tiles never change
        //so set the buffer data just once
        _seba.WEBGL.GLOBALS.buffers.worldTileTranslations.buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTranslations.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.worldTileTranslations.data, gl.STATIC_DRAW); //2018-02-22 08:58:06 opz. avevo messo worldTileVertexPositions al posto di worldTileTranslations e tutti i tile venivano ovviamente cannati....

        callback();
      },

      PARTICLES: { //proc PARTICLES {orange indent_3} WEBGL.WORLD.PARTICLES
        updateCurrentSelectedGroup: function (cfg) {//proc updateCurrentSelectedGroup {orange indent_4}
          var config = {};
          var xx = 0;
          var yy = 0;
          var zz = 0;
          var translate = 0;
          var bSelectSingle = 0;
          var _seba = SEBASTIAN;
          var resetOnly = 0;

          if (!_seba.GLOBALS.isEditorEnabled)
          return;

          if (_seba.GLOBALS.particleSelEnableSingle)
          bSelectSingle = 1;
          var selectSingle = _seba.GLOBALS.currentSelectedParticleIdx;

          if (typeof cfg.resetOnly !== 'undefined')
          resetOnly = cfg.resetOnly;

          if (typeof cfg.x !== 'undefined') {
            xx = cfg.x;
            translate = 1;
          }
          if (typeof cfg.y !== 'undefined')
          yy = cfg.y;
          if (typeof cfg.z !== 'undefined')
          zz = cfg.z;

          var R, G, B;
          var modColor = 0;
          if (typeof cfg.r !== 'undefined') {
            R = cfg.r;
            modColor = 1;
          }
          if (typeof cfg.g !== 'undefined')
          G = cfg.g;
          if (typeof cfg.b !== 'undefined')
          B = cfg.b;

          var pIdx = _seba.GLOBALS.currentSelectedParticlesIdx;
          var shaderProgramP = _seba.WEBGL.GLOBALS.shaderProgramP;
          //var strideElements=18;
          var elementsDataLength = shaderProgramP.data.userParticles.interleavedStruct.elementsDataLength;

          //console.log('st',stride);

          if (typeof _seba.GLOBALS.currentSelectedParticles[pIdx] !== 'undefined') {

            var pGroup = _seba.GLOBALS.currentSelectedParticles[pIdx];
            var verticesbuffer = shaderProgramP.data.userParticles.verticesbuffer;
            //console.log(shaderProgramP.data.userParticles.stride);

            //reset color
            var rr = 0.9;
            var gg = 0.9;
            var bb = 0.9;

            for (var w = 0, wEnd = _seba.GLOBALS.currentSelectedParticles.length; w < wEnd; w++) {
              var cpGroup = _seba.GLOBALS.currentSelectedParticles[w];
              for (var z = 0, zEnd = cpGroup.length; z < zEnd; z++) {
                var currentRelIndex = cpGroup[z];

                //console.log(currentRelIndex+elementsDataLength*0+15);

                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 15] = rr;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 15] = rr;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 15] = rr;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 15] = rr;
                //--
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 16] = gg;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 16] = gg;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 16] = gg;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 16] = gg;
                //--
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 17] = bb;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 17] = bb;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 17] = bb;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 17] = bb;

                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 18] = 0;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 18] = 0;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 18] = 0;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 18] = 0;

              }
            }

            //prendiamo le coordinate di traslazioni attuali
            //currentSelectedParticlesGX

            if (resetOnly)
            return;

            //var shaderProgramP=_seba.WEBGL.GLOBALS.shaderProgramP;
            //console.log(verticesbuffer);
            for (var z = 0, zEnd = pGroup.length; z < zEnd; z++) {
              var currentRelIndex = pGroup[z];

              if (z === 0) {
                _seba.GLOBALS.currentSelectedParticlesGX = verticesbuffer[currentRelIndex + elementsDataLength * 0 + 11];
                _seba.GLOBALS.currentSelectedParticlesGY = verticesbuffer[currentRelIndex + elementsDataLength * 0 + 12];
              }

              if (bSelectSingle) {
                if (z !== selectSingle)
                continue;
              }

              if (translate) {
                //x
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 11] += xx;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 11] += xx;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 11] += xx;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 11] += xx;

                //y
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 12] += yy;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 12] += yy;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 12] += yy;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 12] += yy;

                //z
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 13] += zz;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 13] += zz;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 13] += zz;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 13] += zz;
              }

              if (modColor) {

                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 15] = R;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 15] = R;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 15] = R;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 15] = R;
                //--
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 16] = G;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 16] = G;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 16] = G;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 16] = G;
                //--
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 17] = B;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 17] = B;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 17] = B;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 17] = B;
                //--
                verticesbuffer[currentRelIndex + elementsDataLength * 0 + 18] = 2;
                verticesbuffer[currentRelIndex + elementsDataLength * 1 + 18] = 2;
                verticesbuffer[currentRelIndex + elementsDataLength * 2 + 18] = 2;
                verticesbuffer[currentRelIndex + elementsDataLength * 3 + 18] = 2;

              }

            }
            _seba.GLOBALS.isParticlesBufferDataDirty = 1; //force particles buffer data mapping
            shaderProgramP.data.userParticles.interleavedStruct.data = null;
            shaderProgramP.data.userParticles.interleavedStruct.data = new Float32Array(verticesbuffer);
          }
        } },


      ENTITIES: { //proc ENTITIES {orange indent_3}
        GLOBALS: { //proc WEBGL.WORLD.ENTITIES.GLOBALS {orange indent_4}
          depthSorted: [], //array with list of entity ids sorted by camera to be drawn with the painter's algorithm
          //NOTE: it is not possible to have a vertextattibute with dim greather than 4 {indent_4}
          //      ref: http://docs.gl/gl3/glVertexAttribPointer -> errors

          totalProperties: 4 },

        init: function () {//proc init {green indent_4}
          var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
          //define a polygon -> vertical 1x1 square at offset 0,0
          var vertexPositions = [
          0.0, 1.0, 0.0,
          0.0, 0.0, 0.0,
          1.0, 0.0, 0.0,

          0.0, 1.0, 0.0,
          1.0, 1.0, 0.0,
          1.0, 0.0, 0.0];

          var vertexTextureCoords = [
          0.0, 1.0,
          0.0, 0.0,
          1.0, 0.0,

          0.0, 1.0,
          1.0, 1.0,
          1.0, 0.0];

          //all entities share the same texture geometry
          SEBASTIAN.WEBGL.WORLD.ENTITIES.GLOBALS.vertexPositions = vertexPositions;
          SEBASTIAN.WEBGL.WORLD.ENTITIES.GLOBALS.vertexTextureCoords = vertexTextureCoords;
          var aVertexTextureCoords = new Float32Array(vertexTextureCoords);
          SEBASTIAN.WEBGL.WORLD.ENTITIES.GLOBALS.aVertexTextureCoords = aVertexTextureCoords;
        },

        add: function (cfg) {//proc add {green indent_4}
          cfg = cfg ? cfg : {};

          var config = {
            isBot: cfg.isBot || 0,
            x: cfg.x || 0,
            y: cfg.y || 0,
            z: cfg.z || 0,
            rx: cfg.rx || 0,
            ry: cfg.ry || 0,
            rz: cfg.rz || 0,
            scale: cfg.scale,
            color1: cfg.color1 || [1.0, 1.0, 1.0],
            colorDynamic: cfg.colorDynamic || '', //2018-03-22 12:11:51 allows to color the entity with a color that varies depending on the time
            speed: cfg.speed || 0,
            textureId: cfg.textureId || 'sel_02',
            opacity: cfg.opacity || 1,
            isLivingBeing: cfg.isLivingBeing || 0,
            isLightEmitter: cfg.isLightEmitter || 0,
            hasShadowMitigation: cfg.hasShadowMitigation || 0,
            attachToCurrentTile: cfg.attachToCurrentTile || 0,
            isFlippedX: cfg.isFlippedX || 0 };

          var _seba = SEBASTIAN;
          var worldData = _seba.GLOBALS.worldData;
          var newEntityId = worldData.entities.length;

          worldData.entities.push(config);
          worldData.entities[newEntityId].id = newEntityId;

          return newEntityId;
        },
        bootBot: function (idx, cloneIdx) {//proc bootBot {green indent_4}
          var worldData = SEBASTIAN.GLOBALS.worldData;
          var currentEntity = worldData.entities[idx];
          var resetSingleEntity = false;
          if (typeof cloneIdx !== 'undefined')
          resetSingleEntity = true;

          if (typeof currentEntity.isCluster !== 'undefined' &amp;&amp; currentEntity.isCluster || resetSingleEntity) {
            if (typeof currentEntity.cloneOf !== 'undefined')
            currentEntity = worldData.entities[currentEntity.cloneOf]; // take the parent entity of the current clone
            var nClones = currentEntity.clusterInfo.clones;
            var ooX = currentEntity.clusterInfo.xRange[0];
            var ooY = currentEntity.clusterInfo.yRange[0];
            var ooZ = currentEntity.clusterInfo.zRange[0];
            var yStep = currentEntity.clusterInfo.yStep;
            var stepX = (currentEntity.clusterInfo.xRange[1] - currentEntity.clusterInfo.xRange[0]) / nClones;
            var stepY = (currentEntity.clusterInfo.yRange[1] - currentEntity.clusterInfo.yRange[0]) / nClones;
            var stepZ = (currentEntity.clusterInfo.zRange[1] - currentEntity.clusterInfo.zRange[0]) / nClones;
            var xLimit = currentEntity.clusterInfo.xRange[1];
            var minSpeed = currentEntity.clusterInfo.speedRange[0];
            var maxSpeed = currentEntity.clusterInfo.speedRange[1];
            var minY = currentEntity.clusterInfo.yRange[0];
            var maxY = currentEntity.clusterInfo.yRange[1];
            var minZ = currentEntity.clusterInfo.zRange[0];
            var maxZ = currentEntity.clusterInfo.zRange[1];
            var minOpacity = currentEntity.clusterInfo.opacityRange[0];
            var maxOpacity = currentEntity.clusterInfo.opacityRange[1];
            var minScale = currentEntity.clusterInfo.scaleRange[0];
            var maxScale = currentEntity.clusterInfo.scaleRange[1];
            var behaviorId = currentEntity.clusterInfo.behaviorId;
            var clusterScatter = currentEntity.clusterInfo.scatter;
            var colors = currentEntity.clusterInfo.colors;
            var colorDynamic = currentEntity.colorDynamic;
            var isStanding = currentEntity.isStanding;

            var colorsPool = currentEntity.clusterInfo.colorsPool;
            var isLightEmitter = currentEntity.isLightEmitter;
            var isFlippedX = currentEntity.isFlippedX;
            var hasShadowMitigation = currentEntity.hasShadowMitigation;

            if (typeof clusterScatter === 'undefined')
            clusterScatter = 1;
            if (resetSingleEntity)
            nClones = 1;
            for (var z = 0, zEnd = nClones; z < zEnd; z++) {
              //var textureId=currentEntity.clusterInfo.textures[Math.floor(Math.random()*currentEntity.clusterInfo.textures.length)];
              var textureId = currentEntity.clusterInfo.textures[Math.floor(Math.random() * currentEntity.clusterInfo.textures.length)];
              var speed = Math.random() * (maxSpeed - minSpeed) + minSpeed;
              var opacity = Math.random() * (maxOpacity - minOpacity) + minOpacity;
              var scale = Math.random() * (maxScale - minScale) + minScale;
              //console.log(speed);
              ooZ = Math.random() * (maxZ - minZ) + minZ;
              ooY = Math.random() * (maxY - minY) + minY;
              if (typeof yStep !== 'undefined') {//per il tronco dell'albero
                if (typeof currentEntity.currentAutoY === 'undefined')
                currentEntity.currentAutoY = currentEntity.clusterInfo.yRange[0];
                ooY = currentEntity.currentAutoY;
                currentEntity.currentAutoY += yStep;
              }
              var newEntityId;
              if (!resetSingleEntity) {
                newEntityId = SEBASTIAN.WEBGL.WORLD.ENTITIES.add({});
                SEBASTIAN.GLOBALS.worldData.entities[newEntityId].cloneOf = idx;
              } else {
                newEntityId = idx;
              }
              var theEntity = SEBASTIAN.GLOBALS.worldData.entities[newEntityId];

              theEntity.behaviorId = behaviorId;
              theEntity.isBot = 1;
              theEntity.x = ooX;
              theEntity.y = ooY;
              theEntity.z = ooZ;
              theEntity.textureId = textureId;
              theEntity.oTextureId = theEntity.textureId;
              theEntity.oY = theEntity.y;
              theEntity.speed = speed;
              theEntity.opacity = opacity;
              theEntity.scale = scale;
              theEntity.isIdle = 0;
              theEntity.isLightEmitter = isLightEmitter;
              theEntity.hasShadowMitigation = hasShadowMitigation;
              theEntity.isFlippedX = isFlippedX;
              if (theEntity.speed !== 0)
              theEntity.xLimit = xLimit;
              if (typeof colors !== 'undefined') {
                var chosenColor = currentEntity.clusterInfo.colors[Math.floor(Math.random() * currentEntity.clusterInfo.colors.length)];
                theEntity.color1 = [chosenColor[0] / 255, chosenColor[1] / 255, chosenColor[2] / 255];
              }
              if (typeof colorDynamic !== 'undefined') {// 2018-03-22 15:05:03 dynamic color applied to an entire group of clones clusters

                var h_key = SEBASTIAN.GLOBALS.hours;
                var m_key = SEBASTIAN.GLOBALS.minutes;
                var colorKey = h_key + '_' + m_key;
                var colorsPoolIdx = 'p' + colorDynamic;
                var chosenColor = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey][colorsPoolIdx];
                theEntity.hasPoolColor = 1;
                theEntity.colorsPoolIdx = colorsPoolIdx;
                theEntity.color1 = chosenColor;
              }
              if (typeof colorsPool !== 'undefined') {// 2018-03-21 01:21:41 select a random color from the corresponding pool

                var h_key = SEBASTIAN.GLOBALS.hours;
                var m_key = SEBASTIAN.GLOBALS.minutes;
                var colorKey = h_key + '_' + m_key;
                //get a random value from the color pool
                var max = 5;
                var min = 1;
                var rnd = Math.floor(Math.random() * (max - min + 1)) + min; //ref: https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
                //console.log('p'+colorsPool+rnd);
                var colorsPoolIdx = 'p' + colorsPool + rnd;
                var chosenColor = SEBASTIAN.GLOBALS.lightColorTimeMap[colorKey][colorsPoolIdx];
                theEntity.hasPoolColor = 1;
                theEntity.colorsPoolIdx = colorsPoolIdx;
                theEntity.color1 = chosenColor;
                //console.log(theEntity.color1);
              }
              theEntity.oColor1 = theEntity.color1;
              //define geometry and stuff
              SEBASTIAN.WEBGL.WORLD.ENTITIES.define(newEntityId);
              if (clusterScatter) {// if 1 spread the clones around (eg clouds)
                ooX += stepX;
                ooY += stepY;
              }
            }
          }
        },
        setLivingCreatureBehaviors: function (currentEntity) {//proc setLivingBehaviors {green indent_4}

          var _seba = SEBASTIAN;
          var h_key = _seba.GLOBALS.hours;
          var m_key = _seba.GLOBALS.minutes;
          var timeIdx = h_key * 60 + m_key;

          var bedtime_hours = 20;
          var bedtime_minutes = 30;
          var waketime_hours = 7;
          var waketime_minutes = 30;

          //2018-04-30 19:33:25
          // add calculation taking into account daylight saving time and offset
          var ddd = new Date();
          var offsetHours = ddd.getTimezoneOffset() / 60;
          bedtime_hours -= -offsetHours;
          waketime_hours -= -offsetHours;
          //console.log('bed',bedtime_hours,'wake',waketime_hours);

          var bedtime_idx = bedtime_hours * 60 + bedtime_minutes;
          var waketime_idx = waketime_hours * 60 + waketime_minutes;
          //set a random bedtime/waketime interval
          var max = 20;
          var min = 0;
          var rnd = Math.floor(Math.random() * (max - min + 1)) + min; //https://stackoverflow.com/questions/1527803/generating-random-whole-numbers-in-javascript-in-a-specific-range
          currentEntity.bedtime = bedtime_idx + rnd;
          var rnd = Math.floor(Math.random() * (max - min + 1)) + min;
          currentEntity.waketime = waketime_idx + rnd;
          //console.log('bedtime',currentEntity.bedtime,'waketime',currentEntity.waketime);

          if (currentEntity.isAwake === 1) {//do not allow to set wake alarms on the past
            if (timeIdx < currentEntity.waketime)
            currentEntity.waketime = timeIdx - 1;
          }

        },
        define: function (idx) {//proc define {green indent_4}
          var _seba = SEBASTIAN;
          var worldData = _seba.GLOBALS.worldData;
          var currentEntity = worldData.entities[idx];

          if (typeof currentEntity.isCluster !== 'undefined' &amp;&amp; currentEntity.isCluster) {
            _seba.WEBGL.WORLD.ENTITIES.bootBot(idx);
            // The cluster is an invisible 'master' that is cloned
            currentEntity.isHidden = 1;
            currentEntity.x = -5000; //'hide' geometry
          } else {
            // if the entity is not of type cluster,
            // create the lookup of entities by name
            //console.log(currentEntity.name);
            if (typeof currentEntity.name !== 'undefined') {
              if (typeof currentEntity.isBot === 'undefined' || !currentEntity.isBot) {
                if (typeof worldData.entitiesNamePointer === 'undefined')
                worldData.entitiesNamePointer = {};
                worldData.entitiesNamePointer[currentEntity.name] = worldData.entities[idx];
                //console.log(currentEntity.name,SEBASTIAN.GLOBALS.worldData.entitiesNamePointer);
              }
            }
          }

          if (typeof currentEntity.isStanding === 'undefined')
          currentEntity.isStanding = 1;

          if (typeof currentEntity.isLightEmitter === 'undefined')
          currentEntity.isLightEmitter = 0;
          if (typeof currentEntity.hasShadowMitigation === 'undefined')
          currentEntity.hasShadowMitigation = 0;
          if (typeof currentEntity.isFlippedX === 'undefined')
          currentEntity.isFlippedX = 0;

          if (currentEntity.isLivingBeing) {
            _seba.WEBGL.WORLD.ENTITIES.setLivingCreatureBehaviors(currentEntity);
          }

          if (typeof currentEntity.colorDynamic !== 'undefined' &amp;&amp; currentEntity.colorDynamic !== '') {//dDMKCWhHp4
            //var tDate=new Date();
            //var h_key=tDate.getHours();
            //var m_key=tDate.getMinutes();
            var h_key = _seba.GLOBALS.hours;
            var m_key = _seba.GLOBALS.minutes;
            var colorKey = h_key + '_' + m_key;
            var colorsPoolIdx = 'p' + currentEntity.colorDynamic;
            //var chosenColor=_seba.GLOBALS.lightColorTimeMap[colorKey][colorsPoolIdx];
            currentEntity.hasPoolColor = 1;
            currentEntity.colorsPoolIdx = colorsPoolIdx;
          }

          var isFloatingOnWater = 0;
          //proc geometry animation behavior INIT {yellow indent_5}
          switch (currentEntity.behaviorId) {
            case 1: //proc taraxacum {bold indent_6} and other vegetation geometry deform (windflow-like)

              var minRand = 0.022;
              var maxRand = 0.028;
              var randValue = Math.random() * (maxRand - minRand) + minRand;
              breathDeformLimit = randValue;

              var minRand = 0.09;
              var maxRand = 0.14;
              var randValue = Math.random() * (maxRand - minRand) + minRand;
              breatheSlowness = randValue;

              //if (typeof currentEntity.breathDeformLimit!=='undefined')
              //  breathDeformLimit=currentEntity.breathDeformLimit;
              //if (typeof currentEntity.breatheSlowness!=='undefined')
              //  breatheSlowness=currentEntity.breatheSlowness;
              currentEntity.breathDeformLimit = breathDeformLimit;
              currentEntity.breatheSlowness = breatheSlowness;

              break;
            case 2: //breath geometry deform (organic-life-like)

              var breathDeformLimit = 0.028;
              var breatheSlowness = 0.12;
              if (typeof currentEntity.breathDeformLimit !== 'undefined')
              breathDeformLimit = currentEntity.breathDeformLimit;
              if (typeof currentEntity.breatheSlowness !== 'undefined')
              breatheSlowness = currentEntity.breatheSlowness;
              currentEntity.breathDeformLimit = breathDeformLimit;
              currentEntity.breatheSlowness = breatheSlowness;

              //console.log(currentEntity.name,currentEntity.breathDeformLimit,currentEntity.breatheSlowness);

              if (currentEntity.isFloatingOnWater === 1)
              isFloatingOnWater = 1;
              break;
            case 3: //water geometry deform (windflow-like)

              var minDeformSpeed = 0.00003;
              var maxDeformSpeed = 0.00005;
              var deformSpeed = Math.random() * (maxDeformSpeed - minDeformSpeed) + minDeformSpeed;
              //var deformSpeed=0.0001;
              currentEntity.counterDeltaIncrement = deformSpeed;
              break;
            case 4: // objects that float in the water
              isFloatingOnWater = 1;
              break;}


          if (isFloatingOnWater) {
            //WIRED G9YjdnHuAK
            currentEntity.onWaterYMovementSlowness = 0.3; //counterDeltaYIncrement
            currentEntity.onWaterYMovementDistance = 0.05; //counterYTotalDistance
          }

          //SEBASTIAN.GLOBALS.worldData.entities[
          //console.log(idx,SEBASTIAN.GLOBALS.worldData.entities[idx].scale);
          SEBASTIAN.WEBGL.WORLD.ENTITIES.setGeometry(idx);
        },
        checkEntitiesDepthVisibilityMousePos(updateDepth, updateVisibility, applyMouseDetection) {//proc checkEntitiesDepthVisibilityMousePos {green indent_4}
          //cycle on all entities, check their visibility,calculate their depth
          //and update the zdepth array

          // if updateDepth is 1 updates the position z of all entities

          // we need it for
          // - reorder the zbuffer if necessary
          // - determine the entity under the mouse
          // - to determine if an entity is visible (if invisible we do not animate geometry)

          var _seba = SEBASTIAN;
          var vertexPositions = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.data;
          var worldData = _seba.GLOBALS.worldData;
          var depths = _seba.WEBGL.WORLD.ENTITIES.GLOBALS.depthSorted;
          var xPos = _seba.WEBGL.WORLD.GLOBALS.xPos;
          var yPos = _seba.WEBGL.WORLD.GLOBALS.yPos;
          var zPos = _seba.WEBGL.WORLD.GLOBALS.zPos;
          var pMatrix = _seba.WEBGL.WORLD.GLOBALS.pMatrix;
          var mvMatrix = _seba.WEBGL.WORLD.GLOBALS.mvMatrix;
          var gl = _seba.GLOBALS.webgl_ctx; //lookup var
          var mx = _seba.GLOBALS.mx;
          var my = _seba.GLOBALS.my;

          var skippedEntities = 0;
          var foundEntityUnderMouse = 0;

          var isMouseOverCurrentEntity = 0;
          var isCurrentEntityVisible = 1;
          var currentEntity = worldData.entities[_seba.GLOBALS.currentEntityId];
          var cx = currentEntity.x;
          var cy = currentEntity.y;
          var cz = currentEntity.z;
          //console.log(currentEntity.textureId);
          var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];
          var aa = _seba.WEBGL.project(0, currentEntity.scale * currentTexture.scaleY, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix, 1, sid);
          var ff = _seba.WEBGL.project(currentEntity.scale * currentTexture.scaleX, 0, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix);
          if (ff[0] < -100 || aa[0] > gl.viewportWidth + 100 || ff[1] < -100 || aa[1] > gl.viewportHeight + 100)
          isCurrentEntityVisible = 0;
          var ee = _seba.WEBGL.project(currentEntity.scale * currentTexture.scaleX, currentEntity.scale * currentTexture.scaleY, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix);
          if (isCurrentEntityVisible) {
            if (mx >= aa[0] &amp;&amp; mx < ee[0]) {
              if (my >= aa[1] &amp;&amp; my < ff[1]) {
                isMouseOverCurrentEntity = 1;
              }
            }
          }

          for (var z = 0, zEnd = worldData.entities.length; z < zEnd; z++) {
            var currentEntity = worldData.entities[z];
            var cx = currentEntity.x;
            var cy = currentEntity.y;
            var cz = currentEntity.z;

            var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];

            if (updateVisibility) {
              currentEntity.isVisible = 1;

              var idx = z * 6 * 3; //the entities have ids based on their creation
              if (vertexPositions[idx + 2] + currentEntity.z > zPos) {
                currentEntity.isVisible = 0;
                skippedEntities++;
              } else {
                var sid = '';

                var aa = _seba.WEBGL.project(0, currentEntity.scale * currentTexture.scaleY, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix);
                var ff = _seba.WEBGL.project(currentEntity.scale * currentTexture.scaleX, 0, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix);
                if (ff[0] < -100 || aa[0] > gl.viewportWidth + 100 || ff[1] < -100 || aa[1] > gl.viewportHeight + 100)
                currentEntity.isVisible = 0;
              }

              if (
              applyMouseDetection &amp;&amp; _seba.GLOBALS.isMouseDirty &amp;&amp; currentEntity.isVisible
              //&amp;&amp; currentEntity.isLivingBeing //nuovo , non ci serve editing di oggetti 2018-05-15 00:14:37
              ) {
                  //var ee=_seba.WEBGL.project(vertexPositions[idx+12]/currentEntity.scale*currentTexture.scaleX,vertexPositions[idx+13]/currentEntity.scale*currentTexture.scaleY,vertexPositions[idx+14],xPos,yPos,zPos,cx,cy,cz,pMatrix,mvMatrix);
                  var ee = _seba.WEBGL.project(currentEntity.scale * currentTexture.scaleX, currentEntity.scale * currentTexture.scaleY, 0, xPos, yPos, zPos, cx, cy, cz, pMatrix, mvMatrix);

                  //if (currentEntity.name==='moai_1'){
                  //  console.log('x',aa[0],'y',aa[1]);
                  //}
                  if (mx >= aa[0] &amp;&amp; mx < ee[0]) {
                    if (my >= aa[1] &amp;&amp; my < ff[1]) {

                      //console.log('mao',_seba.GLOBALS.currentEntityId);
                      var testEntity = worldData.entities[_seba.GLOBALS.currentEntityId];
                      //console.log('test',testEntity.z,'vs',currentEntity.z,'ise mouse over',testEntity.z,'?',isMouseOverCurrentEntity);
                      if (!isMouseOverCurrentEntity || testEntity.z < currentEntity.z) {
                        //console.log('under mouse',currentEntity.name);
                        foundEntityUnderMouse = 1;
                        //currentEntity.color1=_seba.GLOBALS.entitySelectionColor;
                        //_seba.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity); // since we have changed a property we have to update the buffers
                        if (_seba.GLOBALS.currentEntityId !== z) {
                          //selected entity is different -> reset particles group offset
                          _seba.GLOBALS.currentSelectedParticlesGX = 0;
                          _seba.GLOBALS.currentSelectedParticlesGY = 0;
                        }
                        _seba.GLOBALS.currentEntityId = z;
                      }
                      //_seba.GLOBALS.isMouseDirty=0;
                    }
                  }
                }
            }

            if (updateDepth) {
              depths[currentEntity.id] = {

                //make a calculation to determine the z-index of the current Entity
                //A bit Approximate but functional. Enough for our simplified 3d simulated world.
                //for our simulation simplified 3d
                //depth:_seba.WEBGL.getDepth(xPos,yPos,zPos,quat4,currentEntity.x,currentEntity.y,currentEntity.z)
                // Performance trick
                //if we consider that we will never make particular
                //rotations for rendering, we just need to use z as a depth factor ...

                depth: currentEntity.z,
                entityId: currentEntity.id };

            }
          }

          if (updateDepth) {
            depths.sort(function (a, b) {//sort by depth, painter's algorithm.
              return a.depth - b.depth;
            });
          }

          if (foundEntityUnderMouse) {
            var currentEntity = worldData.entities[_seba.GLOBALS.currentEntityId];
            currentEntity.color1 = _seba.GLOBALS.entitySelectionColor;
            _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity); // since we have changed a property we have to update the buffers
            _seba.GLOBALS.isMouseDirty = 0;
          }

          if (applyMouseDetection)
          return [foundEntityUnderMouse, skippedEntities];
        },

        sortZBuffersByEntityPosition() {//proc sortZBuffersByEntityPosition {green indent_4}
          //very similar to syncBuffersData but for all entities
          //after Z sorting
          var _seba = SEBASTIAN;
          var worldData = _seba.GLOBALS.worldData;
          var depths = _seba.WEBGL.WORLD.ENTITIES.GLOBALS.depthSorted;
          var gl = _seba.GLOBALS.webgl_ctx; //lookup var

          //we need only the z position of the entities -> exclude the rest
          _seba.WEBGL.WORLD.ENTITIES.checkEntitiesDepthVisibilityMousePos(1, 0, 0);

          //var dEntitiesTextureCoords=_seba.WEBGL.GLOBALS.buffers.entitiesTextureCoords.data;
          var dEntitiesVertexPositions = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositions.data;
          //var dEntitiesTranslations=_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data;
          //var dEntitiesSpriteColors=_seba.WEBGL.GLOBALS.buffers.entitiesSpriteColors.data;
          //var dEntitiesSpriteAlphas=_seba.WEBGL.GLOBALS.buffers.entitiesSpriteAlphas.data;
          //--
          var dEntitiesTextureCoordsZ = _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ.data;
          var dEntitiesVertexPositionsZ = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.data;
          var dEntitiesTranslationsZ = _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data;
          var dEntitiesSpriteColorsZ = _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ.data;
          //var dEntitiesSpriteAlphasZ=_seba.WEBGL.GLOBALS.buffers.entitiesSpriteAlphasZ.data;
          //var dEntitiesTextureLayerIndexesZ=_seba.WEBGL.GLOBALS.buffers.entitiesTextureLayerIndexesZ.data;
          var dEntitiesPropertiesZ = _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ.data;

          var dEntitiesVertexPositionsZIdx = 0;
          var dEntitiesTextureCoordsZIdx = 0;
          var dEntitiesTranslationsZIdx = 0;
          var dEntitiesSpriteColorsZIdx = 0;
          //var dEntitiesSpriteAlphasZIdx=0;
          //var dEntitiesTextureLayerIndexesZIdx=0;
          var dEntitiesPropertiesZIdx = 0;
          for (var z = 0, zEnd = worldData.entities.length; z < zEnd; z++) {
            var currentEntity = worldData.entities[depths[z].entityId]; //we obtain the ordered entities based on depth, and we use the painter algorithm to draw them
            currentEntity.depthId = z;
            //var idx0=currentEntity.id*6;
            //var idx2=currentEntity.id*6*2;
            var idx3 = currentEntity.id * 6 * 3;

            var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];
            if (typeof currentTexture === 'undefined') {
              currentTexture = _seba.WEBGL.GLOBALS.textures['pavement_01'];
              //console.log(currentEntity.oTextureId,'->','pavement_01');
            }

            //texture coordinates (2 points per vertex)
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 0] = currentTexture.textureCoordinates[0];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 1] = currentTexture.textureCoordinates[1];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 2] = currentTexture.textureCoordinates[2];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 3] = currentTexture.textureCoordinates[3];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 4] = currentTexture.textureCoordinates[4];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 5] = currentTexture.textureCoordinates[5];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 6] = currentTexture.textureCoordinates[6];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 7] = currentTexture.textureCoordinates[7];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 8] = currentTexture.textureCoordinates[8];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 9] = currentTexture.textureCoordinates[9];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 10] = currentTexture.textureCoordinates[10];
            dEntitiesTextureCoordsZ[dEntitiesTextureCoordsZIdx + 11] = currentTexture.textureCoordinates[11];
            dEntitiesTextureCoordsZIdx += 12;
            //vertex positions (3 points per vertex)
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 0] = dEntitiesVertexPositions[idx3 + 0];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 1] = dEntitiesVertexPositions[idx3 + 1];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 2] = dEntitiesVertexPositions[idx3 + 2];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 3] = dEntitiesVertexPositions[idx3 + 3];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 4] = dEntitiesVertexPositions[idx3 + 4];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 5] = dEntitiesVertexPositions[idx3 + 5];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 6] = dEntitiesVertexPositions[idx3 + 6];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 7] = dEntitiesVertexPositions[idx3 + 7];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 8] = dEntitiesVertexPositions[idx3 + 8];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 9] = dEntitiesVertexPositions[idx3 + 9];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 10] = dEntitiesVertexPositions[idx3 + 10];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 11] = dEntitiesVertexPositions[idx3 + 11];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 12] = dEntitiesVertexPositions[idx3 + 12];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 13] = dEntitiesVertexPositions[idx3 + 13];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 14] = dEntitiesVertexPositions[idx3 + 14];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 15] = dEntitiesVertexPositions[idx3 + 15];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 16] = dEntitiesVertexPositions[idx3 + 16];
            dEntitiesVertexPositionsZ[dEntitiesVertexPositionsZIdx + 17] = dEntitiesVertexPositions[idx3 + 17];
            dEntitiesVertexPositionsZIdx += 18;
            //vertex translations (3 points per vertex)
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 0] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 1] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 2] = currentEntity.z;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 3] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 4] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 5] = currentEntity.z;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 6] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 7] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 8] = currentEntity.z;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 9] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 10] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 11] = currentEntity.z;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 12] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 13] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 14] = currentEntity.z;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 15] = currentEntity.x;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 16] = currentEntity.y;
            dEntitiesTranslationsZ[dEntitiesTranslationsZIdx + 17] = currentEntity.z;
            dEntitiesTranslationsZIdx += 18;
            //vertex colors (4 points per vertex)
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 0] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 1] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 2] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 3] = currentEntity.opacity;

            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 4] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 5] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 6] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 7] = currentEntity.opacity;

            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 8] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 9] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 10] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 11] = currentEntity.opacity;

            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 12] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 13] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 14] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 15] = currentEntity.opacity;

            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 16] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 17] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 18] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 19] = currentEntity.opacity;

            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 20] = currentEntity.color1[0];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 21] = currentEntity.color1[1];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 22] = currentEntity.color1[2];
            dEntitiesSpriteColorsZ[dEntitiesSpriteColorsZIdx + 23] = currentEntity.opacity;
            dEntitiesSpriteColorsZIdx += 24;

            dEntitiesPropertiesZ[dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            //pack flags
            //http://theinstructionlimit.com/encoding-boolean-flags-into-a-float-in-hlsl
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            //proc ENTITIES.PROPERTIES.FLAGS {violet bold indent_5}
            //     the properties are mutually exclusive
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            //--
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            //--
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            //--
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            //--
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            //--
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.oX;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.layerId;
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentTexture.textureCoordinates[4];
            dEntitiesPropertiesZ[++dEntitiesPropertiesZIdx] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
            dEntitiesPropertiesZIdx++;
          }

          gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, dEntitiesPropertiesZ, gl.DYNAMIC_DRAW);

          gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, dEntitiesSpriteColorsZ, gl.DYNAMIC_DRAW);

          gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, dEntitiesTranslationsZ, gl.DYNAMIC_DRAW);

          gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, dEntitiesVertexPositionsZ, gl.DYNAMIC_DRAW);

          gl.bindBuffer(gl.ARRAY_BUFFER, _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ.buffer);
          gl.bufferData(gl.ARRAY_BUFFER, dEntitiesTextureCoordsZ, gl.DYNAMIC_DRAW);

        },

        syncBuffersData: function (currentEntity) {//proc syncBuffersData {green indent_4}
          //since we have abandoned the simplicity of having a drawcall
          //for each entity I am forced to update all the buffers to keep
          //the properties of the entity coupled to the data that are used by opengl to draw it

          //we synchronize the Zbuffers according to the entity status
          var _seba = SEBASTIAN;
          var gl = _seba.GLOBALS.webgl_ctx; //lookup var

          var zIdx0 = currentEntity.depthId * 6;
          var zIdx2 = currentEntity.depthId * 6 * 2;
          var zIdx3 = currentEntity.depthId * 6 * 3;
          var zIdx4 = currentEntity.depthId * 6 * 4; //2018-05-03 17:20:45
          //console.log(_seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties);
          var zIdxProp = currentEntity.depthId * 6 * _seba.WEBGL.WORLD.ENTITIES.GLOBALS.totalProperties;

          //--
          var dEntitiesTextureCoordsZ = _seba.WEBGL.GLOBALS.buffers.entitiesTextureCoordsZ.data;
          var dEntitiesTranslationsZ = _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data;
          var dEntitiesSpriteColorsZ = _seba.WEBGL.GLOBALS.buffers.entitiesSpriteColorsZ.data;

          var dEntitiesPropertiesZ = _seba.WEBGL.GLOBALS.buffers.entitiesPropertiesZ.data;

          var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];
          if (typeof currentTexture === 'undefined') {
            currentTexture = _seba.WEBGL.GLOBALS.textures['pavement_01'];
            //console.log(currentEntity.oTextureId,'->','pavement_01');
          }

          dEntitiesTextureCoordsZ[zIdx2 + 0] = currentTexture.textureCoordinates[0];
          dEntitiesTextureCoordsZ[zIdx2 + 1] = currentTexture.textureCoordinates[1];
          dEntitiesTextureCoordsZ[zIdx2 + 2] = currentTexture.textureCoordinates[2];
          dEntitiesTextureCoordsZ[zIdx2 + 3] = currentTexture.textureCoordinates[3];
          dEntitiesTextureCoordsZ[zIdx2 + 4] = currentTexture.textureCoordinates[4];
          dEntitiesTextureCoordsZ[zIdx2 + 5] = currentTexture.textureCoordinates[5];
          dEntitiesTextureCoordsZ[zIdx2 + 6] = currentTexture.textureCoordinates[6];
          dEntitiesTextureCoordsZ[zIdx2 + 7] = currentTexture.textureCoordinates[7];
          dEntitiesTextureCoordsZ[zIdx2 + 8] = currentTexture.textureCoordinates[8];
          dEntitiesTextureCoordsZ[zIdx2 + 9] = currentTexture.textureCoordinates[9];
          dEntitiesTextureCoordsZ[zIdx2 + 10] = currentTexture.textureCoordinates[10];
          dEntitiesTextureCoordsZ[zIdx2 + 11] = currentTexture.textureCoordinates[11];

          //vertex translations (3 points per vertex)
          dEntitiesTranslationsZ[zIdx3 + 0] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 1] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 2] = currentEntity.z;
          dEntitiesTranslationsZ[zIdx3 + 3] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 4] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 5] = currentEntity.z;
          dEntitiesTranslationsZ[zIdx3 + 6] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 7] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 8] = currentEntity.z;
          dEntitiesTranslationsZ[zIdx3 + 9] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 10] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 11] = currentEntity.z;
          dEntitiesTranslationsZ[zIdx3 + 12] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 13] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 14] = currentEntity.z;
          dEntitiesTranslationsZ[zIdx3 + 15] = currentEntity.x;
          dEntitiesTranslationsZ[zIdx3 + 16] = currentEntity.y;
          dEntitiesTranslationsZ[zIdx3 + 17] = currentEntity.z;

          //vertex colors (3 points per vertex)
          dEntitiesSpriteColorsZ[zIdx4 + 0] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 1] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 2] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 3] = currentEntity.opacity;

          dEntitiesSpriteColorsZ[zIdx4 + 4] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 5] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 6] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 7] = currentEntity.opacity;

          dEntitiesSpriteColorsZ[zIdx4 + 8] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 9] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 10] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 11] = currentEntity.opacity;

          dEntitiesSpriteColorsZ[zIdx4 + 12] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 13] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 14] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 15] = currentEntity.opacity;

          dEntitiesSpriteColorsZ[zIdx4 + 16] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 17] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 18] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 19] = currentEntity.opacity;

          dEntitiesSpriteColorsZ[zIdx4 + 20] = currentEntity.color1[0];
          dEntitiesSpriteColorsZ[zIdx4 + 21] = currentEntity.color1[1];
          dEntitiesSpriteColorsZ[zIdx4 + 22] = currentEntity.color1[2];
          dEntitiesSpriteColorsZ[zIdx4 + 23] = currentEntity.opacity;

          dEntitiesPropertiesZ[zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          //proc ENTITIES.PROPERTIES.FLAGS {violet bold indent_5}
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          //console.log(currentEntity.hasShadowMitigation+10*currentEntity.isLightEmitter+20*currentEntity.isFlippedX);
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX; //poors man bitwise...
          //--
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
          //--
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
          //--
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
          //--
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;
          //--
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.oX;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.layerId;
          dEntitiesPropertiesZ[++zIdxProp] = currentTexture.textureCoordinates[4]; //currentEntity.isLightEmitter;
          dEntitiesPropertiesZ[++zIdxProp] = currentEntity.hasShadowMitigation + 10 * currentEntity.isLightEmitter + 20 * currentEntity.isFlippedX;

        },
        setScale: function (currentEntity) {//proc setScale {green indent_4}

          var _seba = SEBASTIAN;

          var entitiesVertPosZdata = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.data;
          var entitiesVertPosdata = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositions.data;
          var currentEntityVertexZIndex = currentEntity.depthId * 6 * 3;
          var currentEntityVertexIndex = currentEntity.id * 6 * 3;
          //--
          var currentTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];
          if (typeof currentTexture === 'undefined') {
            currentTexture = _seba.WEBGL.GLOBALS.textures['pavement_01'];
            //console.log(currentEntity.oTextureId,'->','pavement_01');
          }
          //console.log(currentEntity.scale);

          if (currentEntity.isStanding === 1) {
            entitiesVertPosdata[currentEntityVertexIndex + 0] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 1] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 2] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 3] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 4] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 5] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 6] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 7] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 8] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 9] = 0.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 10] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 11] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 12] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 13] = 1.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 14] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 15] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 16] = 0.0 * currentEntity.scale * currentTexture.scaleY;
            entitiesVertPosdata[currentEntityVertexIndex + 17] = 0.0;

            //--
            entitiesVertPosZdata[currentEntityVertexZIndex + 0] = entitiesVertPosdata[currentEntityVertexIndex];
            entitiesVertPosZdata[currentEntityVertexZIndex + 1] = entitiesVertPosdata[currentEntityVertexIndex + 1];
            entitiesVertPosZdata[currentEntityVertexZIndex + 2] = entitiesVertPosdata[currentEntityVertexIndex + 2];

            entitiesVertPosZdata[currentEntityVertexZIndex + 3] = entitiesVertPosdata[currentEntityVertexIndex + 3];
            entitiesVertPosZdata[currentEntityVertexZIndex + 4] = entitiesVertPosdata[currentEntityVertexIndex + 4];
            entitiesVertPosZdata[currentEntityVertexZIndex + 5] = entitiesVertPosdata[currentEntityVertexIndex + 5];

            entitiesVertPosZdata[currentEntityVertexZIndex + 6] = entitiesVertPosdata[currentEntityVertexIndex + 6];
            entitiesVertPosZdata[currentEntityVertexZIndex + 7] = entitiesVertPosdata[currentEntityVertexIndex + 7];
            entitiesVertPosZdata[currentEntityVertexZIndex + 8] = entitiesVertPosdata[currentEntityVertexIndex + 8];

            entitiesVertPosZdata[currentEntityVertexZIndex + 9] = entitiesVertPosdata[currentEntityVertexIndex + 9];
            entitiesVertPosZdata[currentEntityVertexZIndex + 10] = entitiesVertPosdata[currentEntityVertexIndex + 10];
            entitiesVertPosZdata[currentEntityVertexZIndex + 11] = entitiesVertPosdata[currentEntityVertexIndex + 11];

            entitiesVertPosZdata[currentEntityVertexZIndex + 12] = entitiesVertPosdata[currentEntityVertexIndex + 12];
            entitiesVertPosZdata[currentEntityVertexZIndex + 13] = entitiesVertPosdata[currentEntityVertexIndex + 13];
            entitiesVertPosZdata[currentEntityVertexZIndex + 14] = entitiesVertPosdata[currentEntityVertexIndex + 14];

            entitiesVertPosZdata[currentEntityVertexZIndex + 15] = entitiesVertPosdata[currentEntityVertexIndex + 15];
            entitiesVertPosZdata[currentEntityVertexZIndex + 16] = entitiesVertPosdata[currentEntityVertexIndex + 16];
            entitiesVertPosZdata[currentEntityVertexZIndex + 17] = entitiesVertPosdata[currentEntityVertexIndex + 17];

            //if (currentEntity.oTextureId.indexOf('grass')!==-1){
            //  console.log(currentEntity.oTextureId,currentEntity.scale,currentTexture.scaleX);
            //}

          } else {// entity such as water

            entitiesVertPosdata[currentEntityVertexIndex + 0] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 1] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 2] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 3] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 4] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 5] = 1.0 * currentEntity.scale * currentTexture.scaleY;

            entitiesVertPosdata[currentEntityVertexIndex + 6] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 7] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 8] = 1.0 * currentEntity.scale * currentTexture.scaleY;;

            entitiesVertPosdata[currentEntityVertexIndex + 9] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 10] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 11] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 12] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 13] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 14] = 0.0;

            entitiesVertPosdata[currentEntityVertexIndex + 15] = 1.0 * currentEntity.scale * currentTexture.scaleX;
            entitiesVertPosdata[currentEntityVertexIndex + 16] = 0.0;
            entitiesVertPosdata[currentEntityVertexIndex + 17] = 1.0 * currentEntity.scale * currentTexture.scaleY;

            //--------

            entitiesVertPosZdata[currentEntityVertexZIndex + 0] = entitiesVertPosdata[currentEntityVertexIndex];
            entitiesVertPosZdata[currentEntityVertexZIndex + 1] = entitiesVertPosdata[currentEntityVertexIndex + 1];
            entitiesVertPosZdata[currentEntityVertexZIndex + 2] = entitiesVertPosdata[currentEntityVertexIndex + 2];

            entitiesVertPosZdata[currentEntityVertexZIndex + 3] = entitiesVertPosdata[currentEntityVertexIndex + 3];
            entitiesVertPosZdata[currentEntityVertexZIndex + 4] = entitiesVertPosdata[currentEntityVertexIndex + 4];
            entitiesVertPosZdata[currentEntityVertexZIndex + 5] = entitiesVertPosdata[currentEntityVertexIndex + 5];

            entitiesVertPosZdata[currentEntityVertexZIndex + 6] = entitiesVertPosdata[currentEntityVertexIndex + 6];
            entitiesVertPosZdata[currentEntityVertexZIndex + 7] = entitiesVertPosdata[currentEntityVertexIndex + 7];
            entitiesVertPosZdata[currentEntityVertexZIndex + 8] = entitiesVertPosdata[currentEntityVertexIndex + 8];

            entitiesVertPosZdata[currentEntityVertexZIndex + 9] = entitiesVertPosdata[currentEntityVertexIndex + 9];
            entitiesVertPosZdata[currentEntityVertexZIndex + 10] = entitiesVertPosdata[currentEntityVertexIndex + 10];
            entitiesVertPosZdata[currentEntityVertexZIndex + 11] = entitiesVertPosdata[currentEntityVertexIndex + 11];

            entitiesVertPosZdata[currentEntityVertexZIndex + 12] = entitiesVertPosdata[currentEntityVertexIndex + 12];
            entitiesVertPosZdata[currentEntityVertexZIndex + 13] = entitiesVertPosdata[currentEntityVertexIndex + 13];
            entitiesVertPosZdata[currentEntityVertexZIndex + 14] = entitiesVertPosdata[currentEntityVertexIndex + 14];

            entitiesVertPosZdata[currentEntityVertexZIndex + 15] = entitiesVertPosdata[currentEntityVertexIndex + 15];
            entitiesVertPosZdata[currentEntityVertexZIndex + 16] = entitiesVertPosdata[currentEntityVertexIndex + 16];
            entitiesVertPosZdata[currentEntityVertexZIndex + 17] = entitiesVertPosdata[currentEntityVertexIndex + 17];

          }
        },

        animate: function (idx, delta, timeIdx) {//proc animate {green indent_4}
          var worldData = SEBASTIAN.GLOBALS.worldData;
          var currentEntity = worldData.entities[idx];
          var _seba = SEBASTIAN;
          var currentEntityVertexZIndex = currentEntity.depthId * 6 * 3; // index of the first vertex of the entity in the zbuffer array

          //behavior
          //sleep animation
          if (currentEntity.isLivingBeing) {
            if (currentEntity.currentAnimation !== 'sleep') {
              if (timeIdx >= currentEntity.bedtime || timeIdx <= currentEntity.waketime) {
                currentEntity.currentAnimation = 'sleep';
                currentEntity.currentAnimationFrameIdx = 0;
                currentEntity.isPlayingAnim = 1;
                currentEntity.hasEnteredFrame = 0;
                currentEntity.saved_textureId = currentEntity.oTextureId; // save the current texture
                currentEntity.isAwake = 0;
                //console.log(currentEntity.name,'is sleeping at',currentEntity.bedtime);
              }
            } else {
              if (currentEntity.isAwake === 0) {
                if (timeIdx > currentEntity.waketime &amp;&amp; timeIdx < currentEntity.bedtime) {
                  currentEntity.isPlayingAnim = 0;
                  currentEntity.isAwake = 1;
                  currentEntity.textureId = currentEntity.oTextureId; // save the current texture
                  //console.log(timeIdx,1440-timeIdx,currentEntity.waketime,currentEntity.bedtime,currentEntity.name,'is awake');
                  //set random sleep/wake time
                  SEBASTIAN.WEBGL.WORLD.ENTITIES.setLivingCreatureBehaviors(currentEntity);
                  //console.log(currentEntity.name,'is awake at',currentEntity.waketime);
                }
              }
            }
          }

          //movement
          //speed X animation
          //---------------

          if (currentEntity.speed !== 0) {// We update the x position only if the speed of the entity is different from 0 (clouds)
            currentEntity.x += currentEntity.speed * delta;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 0] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+1]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+2]=currentEntity.x;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 3] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+4]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+5]=currentEntity.x;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 6] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+7]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+8]=currentEntity.x;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 9] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+10]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+11]=currentEntity.x;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 12] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+13]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+14]=currentEntity.x;
            _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 15] = currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+16]=currentEntity.x;
            //_seba.WEBGL.GLOBALS.buffers.entitiesTranslations.data[currentEntity.id*6*3+17]=currentEntity.x;

            if (currentEntity.isBot) {
              if (currentEntity.x > currentEntity.xLimit) {
                currentEntity.x = 0 - currentEntity.speed;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 0] = currentEntity.x;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 3] = currentEntity.x;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 6] = currentEntity.x;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 9] = currentEntity.x;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 12] = currentEntity.x;
                _seba.WEBGL.GLOBALS.buffers.entitiesTranslationsZ.data[currentEntityVertexZIndex + 15] = currentEntity.x;
                //--
                SEBASTIAN.WEBGL.WORLD.ENTITIES.bootBot(currentEntity.id, currentEntity.id);
                SEBASTIAN.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
              }
            }

          }

          //aspect
          if (typeof currentEntity.animations !== 'undefined') {
            //console.log(currentEntity.name,'has animations');
            //idle animation
            if (currentEntity.isPlayingAnim !== 1) {
              if (typeof currentEntity.animations.idle !== 'undefined') {
                // we get a random element from the array of available idle animations
                var randomIdleAnimId = currentEntity.animations.idle.animations[Math.floor(Math.random() * currentEntity.animations.idle.animations.length)];
                //console.log(randomIdleAnimId);
                currentEntity.currentAnimation = randomIdleAnimId;
                currentEntity.currentAnimationFrameIdx = 0;
                currentEntity.isPlayingAnim = 1;
                currentEntity.hasEnteredFrame = 0;
                currentEntity.saved_textureId = currentEntity.textureId; //salviamo la texture corrente
                _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
              }
            } else {// animation execution in progress

              if (typeof currentEntity.animations[currentEntity.currentAnimation] !== 'undefined') {
                if (currentEntity.hasEnteredFrame !== 1) {
                  var currentAnim = currentEntity.animations[currentEntity.currentAnimation];
                  var currentAnimFrameIdx = currentEntity.currentAnimationFrameIdx;
                  var chance = Math.random(); //0 inclusive 1 exclusive
                  //console.log(currentAnim.probability_range[0],chance,currentAnim.probability_range[1]);
                  if (typeof currentAnim.probability_range === 'undefined' || chance > currentAnim.probability_range[0] &amp;&amp; chance < currentAnim.probability_range[1]) {
                    currentEntity.textureId = currentAnim.frames[currentAnimFrameIdx].textureId;
                    _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
                    currentEntity.hasEnteredFrame = 1;
                    currentEntity.frameTimer = 0;
                    if (typeof currentAnim.frames[currentAnimFrameIdx].duration_range !== 'undefined') {
                      var frameDurationMin = currentAnim.frames[currentAnimFrameIdx].duration_range[0];
                      var frameDurationMax = currentAnim.frames[currentAnimFrameIdx].duration_range[1];
                      currentEntity.frameDisplayDuration = Math.random() * (frameDurationMax - frameDurationMin) + frameDurationMin;
                    } else {
                      currentEntity.frameDisplayDuration = Infinity; //unlimited duration
                    }
                    //console.log('dur',currentEntity.frameDisplayDuration,frameDurationMin,frameDurationMax);
                  } else {
                    //console.log(currentEntity.currentAnimation,'failed',chance);
                    currentEntity.isPlayingAnim = 0; // the animation has not been launched -> return to idle state
                  }
                } else {//we are inside the current animation frame

                  if (currentEntity.frameDisplayDuration !== Infinity) {
                    var currentAnim = currentEntity.animations[currentEntity.currentAnimation];
                    currentEntity.frameTimer += 0.001 * delta;
                    //console.log('ft',currentEntity.frameTimer);
                    if (currentEntity.frameTimer > currentEntity.frameDisplayDuration) {
                      currentEntity.currentAnimationFrameIdx++;
                      if (currentEntity.currentAnimationFrameIdx >= currentAnim.frames.length) {
                        // we have reached the total number of frames for this animation, return to idle
                        currentEntity.textureId = currentEntity.saved_textureId;
                        _seba.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
                        currentEntity.isPlayingAnim = 0;
                      } else {// there are still other frames for this animation
                        currentEntity.hasEnteredFrame = 0;
                        currentEntity.currentAnimationFrameIdx = 0; // reset the current frame
                      }
                    }
                  }

                }
              }

            }

          }

        },
        animateGeometry: function (idx, delta) {//proc animateGeometry {green indent_4}

          var _seba = SEBASTIAN;
          var worldData = SEBASTIAN.GLOBALS.worldData;
          var currentEntity = worldData.entities[idx];

          var entitiesVertPosZdata = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositionsZ.data;
          var entitiesVertPosdata = _seba.WEBGL.GLOBALS.buffers.entitiesVertexPositions.data;
          var currentEntityVertexZIndex = currentEntity.depthId * 6 * 3;
          var currentEntityVertexIndex = currentEntity.id * 6 * 3;

          //proc geometry animation behavior RUN {yellow indent_5}
          //tJYHTOX5az breath formula
          if (currentEntity.behaviorId === 2) {//breath geometry deform (organic-life-like)
            var ms = _seba.GLOBALS.timeDelta % (currentEntity.breatheSlowness * delta); //currentEntity.deformDelta;
            var norm = ms / (currentEntity.breatheSlowness * delta);
            //console.log(norm);
            ms = Math.sin(norm * Math.PI * 2) * currentEntity.breathDeformLimit;
            //console.log(ms);

            //if (currentEntity.name==='drutt'){
            //  console.log(ms,Math.sin(norm*6.28),currentEntity.breathDeformLimit);
            //}

            entitiesVertPosZdata[currentEntityVertexZIndex + 0] = entitiesVertPosdata[currentEntityVertexIndex + 0] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 9] = entitiesVertPosdata[currentEntityVertexIndex + 9] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 12] = entitiesVertPosdata[currentEntityVertexIndex + 12] - ms;

            entitiesVertPosZdata[currentEntityVertexZIndex + 1] = entitiesVertPosdata[currentEntityVertexIndex + 1] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 10] = entitiesVertPosdata[currentEntityVertexIndex + 10] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 13] = entitiesVertPosdata[currentEntityVertexIndex + 13] - ms;

          }

          if (currentEntity.behaviorId === 1) {//taraxacum geometry deform (windflow-like)
            //var ms=currentEntity.deformDelta;

            var ms = _seba.GLOBALS.timeDelta % (currentEntity.breatheSlowness * delta); //currentEntity.deformDelta;
            var norm = ms / (currentEntity.breatheSlowness * delta);
            //console.log(norm);
            ms = Math.sin(norm * Math.PI * 2) * currentEntity.breathDeformLimit;

            //if(currentEntity.id===500){
            //  console.log(delta);
            //}

            entitiesVertPosZdata[currentEntityVertexZIndex + 0] = entitiesVertPosdata[currentEntityVertexIndex + 0] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 9] = entitiesVertPosdata[currentEntityVertexIndex + 9] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 12] = entitiesVertPosdata[currentEntityVertexIndex + 12] - ms;

          }

          if (currentEntity.behaviorId === 3) {//water geometry deform (windflow-like)
            var ms = currentEntity.deformDelta;

            entitiesVertPosZdata[currentEntityVertexZIndex + 0] = entitiesVertPosdata[currentEntityVertexIndex + 0] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 3] = entitiesVertPosdata[currentEntityVertexIndex + 3] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 9] = entitiesVertPosdata[currentEntityVertexIndex + 9] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 12] = entitiesVertPosdata[currentEntityVertexIndex + 12] + ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 15] = entitiesVertPosdata[currentEntityVertexIndex + 15] + ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 6] = entitiesVertPosdata[currentEntityVertexIndex + 6] + ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 2] = entitiesVertPosdata[currentEntityVertexIndex + 2] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 11] = entitiesVertPosdata[currentEntityVertexIndex + 11] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 14] = entitiesVertPosdata[currentEntityVertexIndex + 14] - ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 5] = entitiesVertPosdata[currentEntityVertexIndex + 5] + ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 8] = entitiesVertPosdata[currentEntityVertexIndex + 8] + ms;
            entitiesVertPosZdata[currentEntityVertexZIndex + 17] = entitiesVertPosdata[currentEntityVertexIndex + 17] + ms;

            currentEntity.deformDelta = currentEntity.counterDelta;
            if (!currentEntity.isIdle) {
              if (!currentEntity.backCounter)
              currentEntity.counterDelta += currentEntity.counterDeltaIncrement * delta;else

              currentEntity.counterDelta -= currentEntity.counterDeltaIncrement * delta;
              if (currentEntity.counterDelta < 0 &amp;&amp; currentEntity.backCounter) {
                currentEntity.counterDelta = 0;
                currentEntity.backCounter = 0;
                //--
                currentEntity.isIdle = 1;
                currentEntity.idleCounter = 0;
                currentEntity.idleWait = 0.2;
              }
              if (currentEntity.counterDelta > 0.20) {//deformation limit
                currentEntity.backCounter = 1;
                //--
                currentEntity.isIdle = 1;
                currentEntity.idleCounter = 0;
                currentEntity.idleWait = 0.2;
              }
            } else {
              currentEntity.idleCounter += 0.001 * delta;
              if (currentEntity.idleCounter > currentEntity.idleWait) {
                currentEntity.isIdle = 0;
                currentEntity.idleCounter = 0;
              }
            }

          }

          //position 2018-04-30 18:55:57
          if (currentEntity.behaviorId === 4 || currentEntity.isFloatingOnWater === 1) {//on water movement
            //it is not necessary to update this kind of position animation
            //for non-visible elements
            //so it goes inside the animateGeometry function even if it does not animate the geometry
            var ms = _seba.GLOBALS.timeDelta % (currentEntity.onWaterYMovementSlowness * delta); //currentEntity.deformDelta;
            var norm = ms / (currentEntity.onWaterYMovementSlowness * delta);

            ms = Math.sin(norm * Math.PI * 2) * currentEntity.onWaterYMovementDistance;
            currentEntity.y = currentEntity.oY + ms; // *Math.sign(1+norm2*-2);// *Math.sign(-1+norm*2);

            SEBASTIAN.WEBGL.WORLD.ENTITIES.syncBuffersData(currentEntity);
          }

        },

        setGeometry: function (idx) {//proc setGeometry {green indent_4}
          //var DYNAMIC_ENTITY_GEOMETRY=1;
          var _seba = SEBASTIAN;
          var gl = SEBASTIAN.GLOBALS.webgl_ctx; //lookup var
          var worldData = SEBASTIAN.GLOBALS.worldData;
          var currentEntity = worldData.entities[idx];
          var currentEntityTexture;
          currentEntityTexture = _seba.WEBGL.GLOBALS.textures[currentEntity.textureId];
          if (typeof currentEntityTexture === 'undefined') {
            console.log('undefined texture', currentEntity.textureId);
            currentEntityTexture = _seba.WEBGL.GLOBALS.textures['pavement_01'];
          }

          if (SEBASTIAN.GLOBALS.dynamicEntitiesGeometry) {
            //define vertext animation params
            currentEntity.deformDelta = 0;
            currentEntity.counterDelta = 0;
            currentEntity.backCounter = 0;
          }

        } } } } };





SEBASTIAN.init(); //LET'S START THE SHOW

function hideInfo() {
  document.getElementById('help_box').style.display = '';
  if (document.getElementById('gdpr_box') !== null)
  document.getElementById('gdpr_box').style.display = '';
  if (document.getElementById('copyright_box') !== null)
  document.getElementById('copyright_box').style.display = '';
  if (document.getElementById('license_box') !== null)
  document.getElementById('license_box').style.display = '';
  SEBASTIAN.GLOBALS.prevBox = null;
}

function showInfo(o) {
  var id = o.id + '_box';
  var savePrev = SEBASTIAN.GLOBALS.prevBox;
  hideInfo();
  SEBASTIAN.GLOBALS.prevBox = savePrev;
  if (SEBASTIAN.GLOBALS.prevBox === id) {
    document.getElementById(id).style.display = '';
    SEBASTIAN.GLOBALS.prevBox = null;
  } else {
    document.getElementById(id).style.display = 'block';
    SEBASTIAN.GLOBALS.prevBox = id;
  }
  return false;
}
//# sourceURL=pen.js
    </script>

  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>

  </div>
	 
	 
   <!---FIREWORKS--->

    <iframe data-visible-from="07-04" data-visible-to="07-04" style="z-index:0;position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />


  
  <title>CodePen - Firework Simulator v3</title>
  <meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot;>
<meta name=&quot;mobile-web-app-capable&quot; content=&quot;yes&quot;>
<meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;>
<meta name=&quot;theme-color&quot; content=&quot;#000000&quot;>
<link rel=&quot;shortcut icon&quot; type=&quot;image/png&quot; href=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon-v2.png&quot;>
<link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon-v2.png&quot;>
<link rel=&quot;apple-touch-icon-precomposed&quot; href=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon-v2.png&quot;>
<meta name=&quot;msapplication-TileColor&quot; content=&quot;#000000&quot;>
<meta name=&quot;msapplication-TileImage&quot; content=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/firework-burst-icon-v2.png&quot;>
<link href=&quot;https://fonts.googleapis.com/css?family=Russo+One&quot; rel=&quot;stylesheet&quot;>
  <link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/meyer-reset/2.0/reset.min.css&quot;>

  
  
<style>
* {
  position: relative;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
}

body {
  overflow: hidden;
  color: rgba(255, 255, 255, 0.5);
  font-family: &quot;Russo One&quot;, arial, sans-serif;
  line-height: 1.25;
  letter-spacing: 0.06em;
}

.hide {
  opacity: 0;
  visibility: hidden;
}

.remove {
  display: none !important;
}

.blur {
  filter: blur(12px);
}

.container {
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

.loading-init {
  width: 100%;
  align-self: center;
  text-align: center;
  text-transform: uppercase;
}
.loading-init__header {
  font-size: 2.2em;
}
.loading-init__status {
  margin-top: 1em;
  font-size: 0.8em;
  opacity: 0.75;
}

.stage-container {
  overflow: hidden;
  box-sizing: initial;
  border: 1px solid #222;
  margin: -1px;
}
@media (max-width: 840px) {
  .stage-container {
    border: none;
    margin: 0;
  }
}

.canvas-container {
  width: 100%;
  height: 100%;
  transition: filter 0.3s;
}
.canvas-container canvas {
  position: absolute;
  mix-blend-mode: lighten;
  transform: translateZ(0);
}

.controls {
  position: absolute;
  top: 0;
  width: 100%;
  padding-bottom: 50px;
  display: flex;
  justify-content: space-between;
  transition: opacity 0.3s, visibility 0.3s;
}
@media (min-width: 840px) {
  .controls {
    visibility: visible;
  }
  .controls.hide:hover {
    opacity: 1;
  }
}

.menu {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background-color: rgba(0, 0, 0, 0.42);
  transition: opacity 0.3s, visibility 0.3s;
}
.menu__inner-wrap {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  transition: opacity 0.3s;
}
.menu__header {
  margin-top: auto;
  margin-bottom: 8px;
  padding-top: 16px;
  font-size: 2em;
  text-transform: uppercase;
}
.menu__subheader {
  margin-bottom: auto;
  padding-bottom: 12px;
  font-size: 0.86em;
  opacity: 0.8;
}
.menu form {
  width: 100%;
  max-width: 400px;
  padding: 0 10px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.menu .form-option {
  display: flex;
  align-items: center;
  margin: 16px 0;
  transition: opacity 0.3s;
}
.menu .form-option label {
  display: block;
  width: 50%;
  padding-right: 12px;
  text-align: right;
  text-transform: uppercase;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
}
.menu .form-option--select select {
  display: block;
  width: 50%;
  height: 30px;
  font-size: 1rem;
  font-family: &quot;Russo One&quot;, arial, sans-serif;
  color: rgba(255, 255, 255, 0.5);
  letter-spacing: 0.06em;
  background-color: transparent;
  border: 1px solid rgba(255, 255, 255, 0.5);
}
.menu .form-option--select select option {
  background-color: black;
}
.menu .form-option--checkbox input {
  display: block;
  width: 26px;
  height: 26px;
  margin: 0;
  opacity: 0.5;
}
@media (max-width: 840px) {
  .menu .form-option select, .menu .form-option input {
    outline: none;
  }
}

.close-menu-btn {
  position: absolute;
  top: 0;
  right: 0;
}

.btn {
  opacity: 0.16;
  width: 50px;
  height: 50px;
  display: flex;
  -webkit-user-select: none;
     -moz-user-select: none;
      -ms-user-select: none;
          user-select: none;
  cursor: default;
  transition: opacity 0.3s;
}
.btn--bright {
  opacity: 0.5;
}
@media (min-width: 840px) {
  .btn:hover {
    opacity: 0.32;
  }
  .btn--bright:hover {
    opacity: 0.75;
  }
}
.btn svg {
  display: block;
  margin: auto;
}

.credits {
  margin-top: auto;
  margin-bottom: 10px;
  padding-top: 6px;
  font-size: 0.8em;
  opacity: 0.75;
}
.credits a {
  color: rgba(255, 255, 255, 0.5);
  text-decoration: none;
}
.credits a:hover, .credits a:active {
  color: rgba(255, 255, 255, 0.75);
  text-decoration: underline;
}

.help-modal {
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  visibility: hidden;
  transition-property: visibility;
  transition-duration: 0.25s;
}
.help-modal__overlay {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  opacity: 0;
  transition-property: opacity;
  transition-timing-function: ease-in;
  transition-duration: 0.25s;
}
.help-modal__dialog {
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 400px;
  max-height: calc(100vh - 100px);
  margin: 10px;
  padding: 20px;
  border-radius: 0.3em;
  background-color: rgba(0, 0, 0, 0.4);
  opacity: 0;
  transform: scale(0.9, 0.9);
  transition-property: opacity, transform;
  transition-timing-function: ease-in;
  transition-duration: 0.25s;
}
@media (min-width: 840px) {
  .help-modal__dialog {
    font-size: 1.25rem;
    max-width: 500px;
  }
}
.help-modal__header {
  font-size: 1.75em;
  text-transform: uppercase;
  text-align: center;
}
.help-modal__body {
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  margin: 1em 0;
  padding: 1em 0;
  border-top: 1px solid rgba(255, 255, 255, 0.25);
  border-bottom: 1px solid rgba(255, 255, 255, 0.25);
  line-height: 1.5;
  color: rgba(255, 255, 255, 0.75);
}
.help-modal__close-btn {
  flex-shrink: 0;
  outline: none;
  border: none;
  border-radius: 2px;
  padding: 0.25em 0.75em;
  margin-top: 0.36em;
  font-family: &quot;Russo One&quot;, arial, sans-serif;
  font-size: 1em;
  color: rgba(255, 255, 255, 0.5);
  text-transform: uppercase;
  letter-spacing: 0.06em;
  background-color: rgba(255, 255, 255, 0.25);
  transition: color 0.3s, background-color 0.3s;
}
.help-modal__close-btn:hover, .help-modal__close-btn:active, .help-modal__close-btn:focus {
  color: #FFF;
  background-color: #09F;
}
.help-modal.active {
  visibility: visible;
  transition-duration: 0.4s;
}
.help-modal.active .help-modal__overlay {
  opacity: 1;
  transition-timing-function: ease-out;
  transition-duration: 0.4s;
}
.help-modal.active .help-modal__dialog {
  opacity: 1;
  transform: scale(1, 1);
  transition-timing-function: ease-out;
  transition-duration: 0.4s;
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <script src=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/fscreen%401.0.1.js&quot;></script>
<script src=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/Stage%400.1.4.js&quot;></script>
<script src=&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/MyMath.js&quot;></script>
<!-- SVG Spritesheet -->
<div style=&quot;height: 0; width: 0; position: absolute; visibility: hidden;&quot;>
	<svg xmlns=&quot;http://www.w3.org/2000/svg&quot;>
		<symbol id=&quot;icon-play&quot; viewBox=&quot;0 0 24 24&quot;>
			<path d=&quot;M8 5v14l11-7z&quot;/>
		</symbol>
		<symbol id=&quot;icon-pause&quot; viewBox=&quot;0 0 24 24&quot;>
			<path d=&quot;M6 19h4V5H6v14zm8-14v14h4V5h-4z&quot;/>
		</symbol>
		<symbol id=&quot;icon-sound-on&quot; viewBox=&quot;0 0 24 24&quot;>
			<path d=&quot;M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z&quot;/>
		</symbol>
		<symbol id=&quot;icon-sound-off&quot; viewBox=&quot;0 0 24 24&quot;>
			<path d=&quot;M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z&quot;/>
		</symbol>
	</svg>
</div>

<!-- App -->
<div class=&quot;container&quot;>
	<div class=&quot;loading-init&quot;>
		<div class=&quot;loading-init__header&quot;>Loading</div>
		<div class=&quot;loading-init__status&quot;>Assembling Shells</div>
	</div>
	<div class=&quot;stage-container remove&quot;>
		<div class=&quot;canvas-container&quot;>
			<canvas id=&quot;trails-canvas&quot;></canvas>
			<canvas id=&quot;main-canvas&quot;></canvas>
		</div>
		<div class=&quot;controls&quot;>
			<div class=&quot;btn pause-btn&quot;>
				<svg fill=&quot;white&quot; width=&quot;24&quot; height=&quot;24&quot;><use href=&quot;#icon-pause&quot; xlink:href=&quot;#icon-pause&quot;></use></svg>
			</div>
			<div class=&quot;btn sound-btn&quot;>
				<svg fill=&quot;white&quot; width=&quot;24&quot; height=&quot;24&quot;><use href=&quot;#icon-sound-off&quot; xlink:href=&quot;#icon-sound-off&quot;></use></svg>
			</div>
			<div class=&quot;btn settings-btn&quot;>
				<svg fill=&quot;white&quot; width=&quot;24&quot; height=&quot;24&quot;><use href=&quot;#icon-settings&quot; xlink:href=&quot;#icon-settings&quot;></use></svg>
			</div>
		</div>
		<div class=&quot;menu hide&quot;>
			<div class=&quot;menu__inner-wrap&quot;>
				<div class=&quot;btn btn--bright close-menu-btn&quot;>
					<svg fill=&quot;white&quot; width=&quot;24&quot; height=&quot;24&quot;><use href=&quot;#icon-close&quot; xlink:href=&quot;#icon-close&quot;></use></svg>
				</div>
				<div class=&quot;menu__header&quot;>Settings</div>
				<div class=&quot;menu__subheader&quot;>For more info, click any label.</div>
				<form>
					<div class=&quot;form-option form-option--select&quot;>
						<label class=&quot;shell-type-label&quot;>Shell Type</label>
						<select class=&quot;shell-type&quot;></select>
					</div>
					<div class=&quot;form-option form-option--select&quot;>
						<label class=&quot;shell-size-label&quot;>Shell Size</label>
						<select class=&quot;shell-size&quot;></select>
					</div>
					<div class=&quot;form-option form-option--select&quot;>
						<label class=&quot;quality-ui-label&quot;>Quality</label>
						<select class=&quot;quality-ui&quot;></select>
					</div>
					<div class=&quot;form-option form-option--select&quot;>
						<label class=&quot;sky-lighting-label&quot;>Sky Lighting</label>
						<select class=&quot;sky-lighting&quot;></select>
					</div>
					<div class=&quot;form-option form-option--select&quot;>
						<label class=&quot;scaleFactor-label&quot;>Scale</label>
						<select class=&quot;scaleFactor&quot;></select>
					</div>
					<div class=&quot;form-option form-option--checkbox&quot;>
						<label class=&quot;auto-launch-label&quot;>Auto Fire</label>
						<input class=&quot;auto-launch&quot; type=&quot;checkbox&quot; />
					</div>
					<div class=&quot;form-option form-option--checkbox form-option--finale-mode&quot;>
						<label class=&quot;finale-mode-label&quot;>Finale Mode</label>
						<input class=&quot;finale-mode&quot; type=&quot;checkbox&quot; />
					</div>
					<div class=&quot;form-option form-option--checkbox&quot;>
						<label class=&quot;hide-controls-label&quot;>Hide Controls</label>
						<input class=&quot;hide-controls&quot; type=&quot;checkbox&quot; />
					</div>
					<div class=&quot;form-option form-option--checkbox form-option--fullscreen&quot;>
						<label class=&quot;fullscreen-label&quot;>Fullscreen</label>
						<input class=&quot;fullscreen&quot; type=&quot;checkbox&quot; />
					</div>
					<div class=&quot;form-option form-option--checkbox&quot;>
						<label class=&quot;long-exposure-label&quot;>Open Shutter</label>
						<input class=&quot;long-exposure&quot; type=&quot;checkbox&quot; />
					</div>
				</form>
				<div class=&quot;credits&quot;>
					Passionately built by <a href=&quot;https://cmiller.tech/&quot; target=&quot;_blank&quot;>Caleb Miller</a>.
				</div>
			</div>
		</div>
	</div>
	<div class=&quot;help-modal&quot;>
		<div class=&quot;help-modal__overlay&quot;></div>
		<div class=&quot;help-modal__dialog&quot;>
			<div class=&quot;help-modal__header&quot;></div>
			<div class=&quot;help-modal__body&quot;></div>
			<button type=&quot;button&quot; class=&quot;help-modal__close-btn&quot;>Close</button>
		</div>
	</div>
</div>
<script>
	'use strict';
console.clear();

// This is a prime example of what starts out as a simple project
// and snowballs way beyond its intended size. It's a little clunky
// reading/working on this single file, but here it is anyways :)

const IS_MOBILE = window.innerWidth <= 640;
const IS_DESKTOP = window.innerWidth > 800;
const IS_HEADER = IS_DESKTOP &amp;&amp; window.innerHeight < 300;
// Detect high end devices. This will be a moving target.
const IS_HIGH_END_DEVICE = (() => {
	const hwConcurrency = navigator.hardwareConcurrency;
	if (!hwConcurrency) {
		return false;
	}
	// Large screens indicate a full size computer, which often have hyper threading these days.
	// So a quad core desktop machine has 8 cores. We'll place a higher min threshold there.
	const minCount = window.innerWidth <= 1024 ? 4 : 8;
	return hwConcurrency >= minCount;
})();
// Prevent canvases from getting too large on ridiculous screen sizes.
// 8K - can restrict this if needed
const MAX_WIDTH = 7680;
const MAX_HEIGHT = 4320;
const GRAVITY = 0.9; // Acceleration in px/s
let simSpeed = 1;

function getDefaultScaleFactor() {
	if (IS_MOBILE) return 0.9;
	if (IS_HEADER) return 0.75;
	return 1;
}

// Width/height values that take scale into account.
// USE THESE FOR DRAWING POSITIONS
let stageW, stageH;

// All quality globals will be overwritten and updated via `configDidUpdate`.
let quality = 3;
let isLowQuality = false;
let isNormalQuality = true;
let isHighQuality = false;

const QUALITY_LOW = 1;
const QUALITY_NORMAL = 2;
const QUALITY_HIGH = 3;

const SKY_LIGHT_NONE = 0;
const SKY_LIGHT_DIM = 1;
const SKY_LIGHT_NORMAL = 2;

const COLOR = {
	Red: '#ff0043',
	Green: '#14fc56',
	Blue: '#1e7fff',
	Purple: '#e60aff',
	Gold: '#ffbf36',
	White: '#ffffff'
};

// Special invisible color (not rendered, and therefore not in COLOR map)
const INVISIBLE = '_INVISIBLE_';

const PI_2 = Math.PI * 2;
const PI_HALF = Math.PI * 0.5;

// Stage.disableHighDPI = true;
const trailsStage = new Stage('trails-canvas');
const mainStage = new Stage('main-canvas');
const stages = [
	trailsStage,
	mainStage
];



// Fullscreen helpers, using Fscreen for prefixes.
function fullscreenEnabled() {
	return fscreen.fullscreenEnabled;
}

// Note that fullscreen state is synced to store, and the store should be the source
// of truth for whether the app is in fullscreen mode or not.
function isFullscreen() {
	return !!fscreen.fullscreenElement;
}

// Attempt to toggle fullscreen mode.
function toggleFullscreen() {
	if (fullscreenEnabled()) {
		if (isFullscreen()) {
			fscreen.exitFullscreen();
		} else {
			fscreen.requestFullscreen(document.documentElement);
		}
	}
}

// Sync fullscreen changes with store. An event listener is necessary because the user can
// toggle fullscreen mode directly through the browser, and we want to react to that.
fscreen.addEventListener('fullscreenchange', () => {
	store.setState({ fullscreen: isFullscreen() });
});




// Simple state container; the source of truth.
const store = {
	_listeners: new Set(),
	_dispatch(prevState) {
		this._listeners.forEach(listener => listener(this.state, prevState))
	},
	
	state: {
		// will be unpaused in init()
		paused: true,
		soundEnabled: false,
		menuOpen: false,
		openHelpTopic: null,
		fullscreen: isFullscreen(),
		// Note that config values used for <select>s must be strings, unless manually converting values to strings
		// at render time, and parsing on change.
		config: {
			quality: String(IS_HIGH_END_DEVICE ? QUALITY_HIGH : QUALITY_NORMAL), // will be mirrored to a global variable named `quality` in `configDidUpdate`, for perf.
			shell: 'Random',
			size: IS_DESKTOP
				? '3' // Desktop default
				: IS_HEADER 
					? '1.2' // Profile header default (doesn't need to be an int)
					: '2', // Mobile default
			autoLaunch: true,
			finale: false,
			skyLighting: SKY_LIGHT_DIM + '',
			hideControls: IS_HEADER,
			longExposure: false,
			scaleFactor: getDefaultScaleFactor()
		}
	},
	
	setState(nextState) {
		const prevState = this.state;
		this.state = Object.assign({}, this.state, nextState);
		this._dispatch(prevState);
		this.persist();
	},
	
	subscribe(listener) {
		this._listeners.add(listener);
		return () => this._listeners.remove(listener);
	},
	
	// Load / persist select state to localStorage
	// Mutates state because `store.load()` should only be called once immediately after store is created, before any subscriptions.
	load() {
		const serializedData = localStorage.getItem('cm_fireworks_data');
		if (serializedData) {
			const {
				schemaVersion,
				data
			} = JSON.parse(serializedData);
			
			const config = this.state.config;
			switch(schemaVersion) {
				case '1.1':
					config.quality = data.quality;
					config.size = data.size;
					config.skyLighting = data.skyLighting;
					break;
				case '1.2':
					config.quality = data.quality;
					config.size = data.size;
					config.skyLighting = data.skyLighting;
					config.scaleFactor = data.scaleFactor;
					break;
				default:
					throw new Error('version switch should be exhaustive');
			}
			console.log(`Loaded config (schema version ${schemaVersion})`);
		}
		// Deprecated data format. Checked with care (it's not namespaced).
		else if (localStorage.getItem('schemaVersion') === '1') {
			let size;
			// Attempt to parse data, ignoring if there is an error.
			try {
				const sizeRaw = localStorage.getItem('configSize');
				size = typeof sizeRaw === 'string' &amp;&amp; JSON.parse(sizeRaw);
			}
			catch(e) {
				console.log('Recovered from error parsing saved config:');
				console.error(e);
				return;
			}
			// Only restore validated values
			const sizeInt = parseInt(size, 10);
			if (sizeInt >= 0 &amp;&amp; sizeInt <= 4) {
				this.state.config.size = String(sizeInt);
			}
		}
	},
	
	persist() {
		const config = this.state.config;
		localStorage.setItem('cm_fireworks_data', JSON.stringify({
			schemaVersion: '1.2',
			data: {
				quality: config.quality,
				size: config.size,
				skyLighting: config.skyLighting,
				scaleFactor: config.scaleFactor
			}
		}));
	}
};


if (!IS_HEADER) {
	store.load();
}

// Actions
// ---------

function togglePause(toggle) {
	const paused = store.state.paused;
	let newValue;
	if (typeof toggle === 'boolean') {
		newValue = toggle;
	} else {
		newValue = !paused;
	}

	if (paused !== newValue) {
		store.setState({ paused: newValue });
	}
}

function toggleSound(toggle) {
	if (typeof toggle === 'boolean') {
		store.setState({ soundEnabled: toggle });
	} else {
		store.setState({ soundEnabled: !store.state.soundEnabled });
	}
}

function toggleMenu(toggle) {
	if (typeof toggle === 'boolean') {
		store.setState({ menuOpen: toggle });
	} else {
		store.setState({ menuOpen: !store.state.menuOpen });
	}
}

function updateConfig(nextConfig) {
	nextConfig = nextConfig || getConfigFromDOM();
	store.setState({
		config: Object.assign({}, store.state.config, nextConfig)
	});
	
	configDidUpdate();
}

// Map config to various properties &amp; apply side effects
function configDidUpdate() {
	const config = store.state.config;
	
	quality = qualitySelector();
	isLowQuality = quality === QUALITY_LOW;
	isNormalQuality = quality === QUALITY_NORMAL;
	isHighQuality = quality === QUALITY_HIGH;
	
	if (skyLightingSelector() === SKY_LIGHT_NONE) {
		appNodes.canvasContainer.style.backgroundColor = '#000';
	}
	
	Spark.drawWidth = quality === QUALITY_HIGH ? 0.75 : 1;
}

// Selectors
// -----------

const isRunning = (state=store.state) => !state.paused &amp;&amp; !state.menuOpen;
// Whether user has enabled sound.
const soundEnabledSelector = (state=store.state) => state.soundEnabled;
// Whether any sounds are allowed, taking into account multiple factors.
const canPlaySoundSelector = (state=store.state) => isRunning(state) &amp;&amp; soundEnabledSelector(state);
// Convert quality to number.
const qualitySelector = () => +store.state.config.quality;
const shellNameSelector = () => store.state.config.shell;
// Convert shell size to number.
const shellSizeSelector = () => +store.state.config.size;
const finaleSelector = () => store.state.config.finale;
const skyLightingSelector = () => +store.state.config.skyLighting;
const scaleFactorSelector = () => store.state.config.scaleFactor;



// Help Content
const helpContent = {
	shellType: {
		header: 'Shell Type',
		body: 'The type of firework that will be launched. Select &quot;Random&quot; for a nice assortment!'
	},
	shellSize: {
		header: 'Shell Size',
		body: 'The size of the fireworks. Modeled after real firework shell sizes, larger shells have bigger bursts with more stars, and sometimes more complex effects. However, larger shells also require more processing power and may cause lag.'
	},
	quality: {
		header: 'Quality',
		body: 'Overall graphics quality. If the animation is not running smoothly, try lowering the quality. High quality greatly increases the amount of sparks rendered and may cause lag.'
	},
	skyLighting: {
		header: 'Sky Lighting',
		body: 'Illuminates the background as fireworks explode. If the background looks too bright on your screen, try setting it to &quot;Dim&quot; or &quot;None&quot;.'
	},
	scaleFactor: {
		header: 'Scale',
		body: 'Allows scaling the size of all fireworks, essentially moving you closer or farther away. For larger shell sizes, it can be convenient to decrease the scale a bit, especially on phones or tablets.'
	},
	autoLaunch: {
		header: 'Auto Fire',
		body: 'Launches sequences of fireworks automatically. Sit back and enjoy the show, or disable to have full control.'
	},
	finaleMode: {
		header: 'Finale Mode',
		body: 'Launches intense bursts of fireworks. May cause lag. Requires &quot;Auto Fire&quot; to be enabled.'
	},
	hideControls: {
		header: 'Hide Controls',
		body: 'Hides the translucent controls along the top of the screen. Useful for screenshots, or just a more seamless experience. While hidden, you can still tap the top-right corner to re-open this menu.'
	},
	fullscreen: {
		header: 'Fullscreen',
		body: 'Toggles fullscreen mode.'
	},
	longExposure: {
		header: 'Open Shutter',
		body: 'Experimental effect that preserves long streaks of light, similar to leaving a camera shutter open.'
	}
};

const nodeKeyToHelpKey = {
	shellTypeLabel: 'shellType',
	shellSizeLabel: 'shellSize',
	qualityLabel: 'quality',
	skyLightingLabel: 'skyLighting',
	scaleFactorLabel: 'scaleFactor',
	autoLaunchLabel: 'autoLaunch',
	finaleModeLabel: 'finaleMode',
	hideControlsLabel: 'hideControls',
	fullscreenLabel: 'fullscreen',
	longExposureLabel: 'longExposure'
};


// Render app UI / keep in sync with state
const appNodes = {
	stageContainer: '.stage-container',
	canvasContainer: '.canvas-container',
	controls: '.controls',
	menu: '.menu',
	menuInnerWrap: '.menu__inner-wrap',
	pauseBtn: '.pause-btn',
	pauseBtnSVG: '.pause-btn use',
	soundBtn: '.sound-btn',
	soundBtnSVG: '.sound-btn use',
	shellType: '.shell-type',
	shellTypeLabel: '.shell-type-label',
	shellSize: '.shell-size',
	shellSizeLabel: '.shell-size-label',
	quality: '.quality-ui',
	qualityLabel: '.quality-ui-label',
	skyLighting: '.sky-lighting',
	skyLightingLabel: '.sky-lighting-label',
	scaleFactor: '.scaleFactor',
	scaleFactorLabel: '.scaleFactor-label',
	autoLaunch: '.auto-launch',
	autoLaunchLabel: '.auto-launch-label',
	finaleModeFormOption: '.form-option--finale-mode',
	finaleMode: '.finale-mode',
	finaleModeLabel: '.finale-mode-label',
	hideControls: '.hide-controls',
	hideControlsLabel: '.hide-controls-label',
	fullscreenFormOption: '.form-option--fullscreen',
	fullscreen: '.fullscreen',
	fullscreenLabel: '.fullscreen-label',
	longExposure: '.long-exposure',
	longExposureLabel: '.long-exposure-label',
	
	// Help UI
	helpModal: '.help-modal',
	helpModalOverlay: '.help-modal__overlay',
	helpModalHeader: '.help-modal__header',
	helpModalBody: '.help-modal__body',
	helpModalCloseBtn: '.help-modal__close-btn'
};

// Convert appNodes selectors to dom nodes
Object.keys(appNodes).forEach(key => {
	appNodes[key] = document.querySelector(appNodes[key]);
});

// Remove fullscreen control if not supported.
if (!fullscreenEnabled()) {
	appNodes.fullscreenFormOption.classList.add('remove');
}

// First render is called in init()
function renderApp(state) {
	const pauseBtnIcon = `#icon-${state.paused ? 'play' : 'pause'}`;
	const soundBtnIcon = `#icon-sound-${soundEnabledSelector() ? 'on' : 'off'}`;
	appNodes.pauseBtnSVG.setAttribute('href', pauseBtnIcon);
	appNodes.pauseBtnSVG.setAttribute('xlink:href', pauseBtnIcon);
	appNodes.soundBtnSVG.setAttribute('href', soundBtnIcon);
	appNodes.soundBtnSVG.setAttribute('xlink:href', soundBtnIcon);
	appNodes.controls.classList.toggle('hide', state.menuOpen || state.config.hideControls);
	appNodes.canvasContainer.classList.toggle('blur', state.menuOpen);
	appNodes.menu.classList.toggle('hide', !state.menuOpen);
	appNodes.finaleModeFormOption.style.opacity = state.config.autoLaunch ? 1 : 0.32;
	
	appNodes.quality.value = state.config.quality;
	appNodes.shellType.value = state.config.shell;
	appNodes.shellSize.value = state.config.size;
	appNodes.autoLaunch.checked = state.config.autoLaunch;
	appNodes.finaleMode.checked = state.config.finale;
	appNodes.skyLighting.value = state.config.skyLighting;
	appNodes.hideControls.checked = state.config.hideControls;
	appNodes.fullscreen.checked = state.fullscreen;
	appNodes.longExposure.checked = state.config.longExposure;
	appNodes.scaleFactor.value = state.config.scaleFactor.toFixed(2);
	
	appNodes.menuInnerWrap.style.opacity = state.openHelpTopic ? 0.12 : 1;
	appNodes.helpModal.classList.toggle('active', !!state.openHelpTopic);
	if (state.openHelpTopic) {
		const { header, body } = helpContent[state.openHelpTopic];
		appNodes.helpModalHeader.textContent = header;
		appNodes.helpModalBody.textContent = body;
	}
}

store.subscribe(renderApp);

// Perform side effects on state changes
function handleStateChange(state, prevState) {
	const canPlaySound = canPlaySoundSelector(state);
	const canPlaySoundPrev = canPlaySoundSelector(prevState);
	
	if (canPlaySound !== canPlaySoundPrev) {
		if (canPlaySound) {
			soundManager.resumeAll();
		} else {
			soundManager.pauseAll();
		}
	}
}

store.subscribe(handleStateChange);


function getConfigFromDOM() {
	return {
		quality: appNodes.quality.value,
		shell: appNodes.shellType.value,
		size: appNodes.shellSize.value,
		autoLaunch: appNodes.autoLaunch.checked,
		finale: appNodes.finaleMode.checked,
		skyLighting: appNodes.skyLighting.value,
		longExposure: appNodes.longExposure.checked,
		hideControls: appNodes.hideControls.checked,
		// Store value as number.
		scaleFactor: parseFloat(appNodes.scaleFactor.value)
	};
};

const updateConfigNoEvent = () => updateConfig();
appNodes.quality.addEventListener('input', updateConfigNoEvent);
appNodes.shellType.addEventListener('input', updateConfigNoEvent);
appNodes.shellSize.addEventListener('input', updateConfigNoEvent);
appNodes.autoLaunch.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.finaleMode.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.skyLighting.addEventListener('input', updateConfigNoEvent);
appNodes.longExposure.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.hideControls.addEventListener('click', () => setTimeout(updateConfig, 0));
appNodes.fullscreen.addEventListener('click', () => setTimeout(toggleFullscreen, 0));
// Changing scaleFactor requires triggering resize handling code as well.
appNodes.scaleFactor.addEventListener('input', () => {
	updateConfig();
	handleResize();
});

Object.keys(nodeKeyToHelpKey).forEach(nodeKey => {
	const helpKey = nodeKeyToHelpKey[nodeKey];
	appNodes[nodeKey].addEventListener('click', () => {
		store.setState({ openHelpTopic: helpKey });
	});
});

appNodes.helpModalCloseBtn.addEventListener('click', () => {
	store.setState({ openHelpTopic: null });
});

appNodes.helpModalOverlay.addEventListener('click', () => {
	store.setState({ openHelpTopic: null });
});



// Constant derivations
const COLOR_NAMES = Object.keys(COLOR);
const COLOR_CODES = COLOR_NAMES.map(colorName => COLOR[colorName]);
// Invisible stars need an indentifier, even through they won't be rendered - physics still apply.
const COLOR_CODES_W_INVIS = [...COLOR_CODES, INVISIBLE];
// Map of color codes to their index in the array. Useful for quickly determining if a color has already been updated in a loop.
const COLOR_CODE_INDEXES = COLOR_CODES_W_INVIS.reduce((obj, code, i) => {
	obj[code] = i;
	return obj;
}, {});
// Tuples is a map keys by color codes (hex) with values of { r, g, b } tuples (still just objects).
const COLOR_TUPLES = {};
COLOR_CODES.forEach(hex => {
	COLOR_TUPLES[hex] = {
		r: parseInt(hex.substr(1, 2), 16),
		g: parseInt(hex.substr(3, 2), 16),
		b: parseInt(hex.substr(5, 2), 16),
	};
});

// Get a random color.
function randomColorSimple() {
	return COLOR_CODES[Math.random() * COLOR_CODES.length | 0];
}

// Get a random color, with some customization options available.
let lastColor;
function randomColor(options) {
	const notSame = options &amp;&amp; options.notSame;
	const notColor = options &amp;&amp; options.notColor;
	const limitWhite = options &amp;&amp; options.limitWhite;
	let color = randomColorSimple();
	
	// limit the amount of white chosen randomly
	if (limitWhite &amp;&amp; color === COLOR.White &amp;&amp; Math.random() < 0.6) {
		color = randomColorSimple();
	}
	
	if (notSame) {
		while (color === lastColor) {
			color = randomColorSimple();
		}
	}
	else if (notColor) {
		while (color === notColor) {
			color = randomColorSimple();
		}
	}
	
	lastColor = color;
	return color;
}

function whiteOrGold() {
	return Math.random() < 0.5 ? COLOR.Gold : COLOR.White;
}


// Shell helpers
function makePistilColor(shellColor) {
	return (shellColor === COLOR.White || shellColor === COLOR.Gold) ? randomColor({ notColor: shellColor }) : whiteOrGold();
}

// Unique shell types
const crysanthemumShell = (size=1) => {
	const glitter = Math.random() < 0.25;
	const singleColor = Math.random() < 0.72;
	const color = singleColor ? randomColor({ limitWhite: true }) : [randomColor(), randomColor({ notSame: true })];
	const pistil = singleColor &amp;&amp; Math.random() < 0.42;
	const pistilColor = pistil &amp;&amp; makePistilColor(color);
	const secondColor = singleColor &amp;&amp; (Math.random() < 0.2 || color === COLOR.White) ? pistilColor || randomColor({ notColor: color, limitWhite: true }) : null;
	const streamers = !pistil &amp;&amp; color !== COLOR.White &amp;&amp; Math.random() < 0.42;
	let starDensity = glitter ? 1.1 : 1.25;
	if (isLowQuality) starDensity *= 0.8;
	if (isHighQuality) starDensity = 1.2;
	return {
		shellSize: size,
		spreadSize: 300 + size * 100,
		starLife: 900 + size * 200,
		starDensity,
		color,
		secondColor,
		glitter: glitter ? 'light' : '',
		glitterColor: whiteOrGold(),
		pistil,
		pistilColor,
		streamers
	};
};


const ghostShell = (size=1) => {
	// Extend crysanthemum shell
	const shell = crysanthemumShell(size);
	// Ghost effect can be fast, so extend star life
	shell.starLife *= 1.5;
	// Ensure we always have a single color other than white
	let ghostColor = randomColor({ notColor: COLOR.White });
	// Always use streamers, and sometimes a pistil
	shell.streamers = true;
	const pistil = Math.random() < 0.42;
	const pistilColor = pistil &amp;&amp; makePistilColor(ghostColor);
	// Ghost effect - transition from invisible to chosen color
	shell.color = INVISIBLE;
	shell.secondColor = ghostColor;
	// We don't want glitter to be spewed by invisible stars, and we don't currently
	// have a way to transition glitter state. So we'll disable it.
	shell.glitter = '';
	
	return shell;
};


const strobeShell = (size=1) => {
	const color = randomColor({ limitWhite: true });
	return {
		shellSize: size,
		spreadSize: 280 + size * 92,
		starLife: 1100 + size * 200,
		starLifeVariation: 0.40,
		starDensity: 1.1,
		color,
		glitter: 'light',
		glitterColor: COLOR.White,
		strobe: true,
		strobeColor: Math.random() < 0.5 ? COLOR.White : null,
		pistil: Math.random() < 0.5,
		pistilColor: makePistilColor(color)
	};
};


const palmShell = (size=1) => {
	const color = randomColor();
	const thick = Math.random() < 0.5;
	return {
		shellSize: size,
		color,
		spreadSize: 250 + size * 75,
		starDensity: thick ? 0.15 : 0.4,
		starLife: 1800 + size * 200,
		glitter: thick ? 'thick' : 'heavy'
	};
};

const ringShell = (size=1) => {
	const color = randomColor();
	const pistil = Math.random() < 0.75;
	return {
		shellSize: size,
		ring: true,
		color,
		spreadSize: 300 + size * 100,
		starLife: 900 + size * 200,
		starCount: 2.2 * PI_2 * (size+1),
		pistil,
		pistilColor: makePistilColor(color),
		glitter: !pistil ? 'light' : '',
		glitterColor: color === COLOR.Gold ? COLOR.Gold : COLOR.White,
		streamers: Math.random() < 0.3
	};
	// return Object.assign({}, defaultShell, config);
};

const crossetteShell = (size=1) => {
	const color = randomColor({ limitWhite: true });
	return {
		shellSize: size,
		spreadSize: 300 + size * 100,
		starLife: 750 + size * 160,
		starLifeVariation: 0.4,
		starDensity: 0.85,
		color,
		crossette: true,
		pistil: Math.random() < 0.5,
		pistilColor: makePistilColor(color)
	};
};

const floralShell = (size=1) => ({
	shellSize: size,
	spreadSize: 300 + size * 120,
	starDensity: 0.12,
	starLife: 500 + size * 50,
	starLifeVariation: 0.5,
	color: Math.random() < 0.65 ? 'random' : (Math.random() < 0.15 ? randomColor() : [randomColor(), randomColor({ notSame: true })]),
	floral: true
});

const fallingLeavesShell = (size=1) => ({
	shellSize: size,
	color: INVISIBLE,
	spreadSize: 300 + size * 120,
	starDensity: 0.12,
	starLife: 500 + size * 50,
	starLifeVariation: 0.5,
	glitter: 'medium',
	glitterColor: COLOR.Gold,
	fallingLeaves: true
});

const willowShell = (size=1) => ({
	shellSize: size,
	spreadSize: 300 + size * 100,
	starDensity: 0.6,
	starLife: 3000 + size * 300,
	glitter: 'willow',
	glitterColor: COLOR.Gold,
	color: INVISIBLE
});

const crackleShell = (size=1) => {
	// favor gold
	const color = Math.random() < 0.75 ? COLOR.Gold : randomColor();
	return {
		shellSize: size,
		spreadSize: 380 + size * 75,
		starDensity: isLowQuality ? 0.65 : 1,
		starLife: 600 + size * 100,
		starLifeVariation: 0.32,
		glitter: 'light',
		glitterColor: COLOR.Gold,
		color,
		crackle: true,
		pistil: Math.random() < 0.65,
		pistilColor: makePistilColor(color)
	};
};

const horsetailShell = (size=1) => {
	const color = randomColor();
	return {
		shellSize: size,
		horsetail: true,
		color,
		spreadSize: 250 + size * 38,
		starDensity: 0.9,
		starLife: 2500 + size * 300,
		glitter: 'medium',
		glitterColor: Math.random() < 0.5 ? whiteOrGold() : color,
		// Add strobe effect to white horsetails, to make them more interesting
		strobe: color === COLOR.White
	};
};

function randomShellName() {
	return Math.random() < 0.5 ? 'Crysanthemum' : shellNames[(Math.random() * (shellNames.length - 1) + 1) | 0 ];
}

function randomShell(size) {
	// Special selection for codepen header.
	if (IS_HEADER) return randomFastShell()(size);
	// Normal operation
	return shellTypes[randomShellName()](size);
}

function shellFromConfig(size) {
	return shellTypes[shellNameSelector()](size);
}

// Get a random shell, not including processing intensive varients
// Note this is only random when &quot;Random&quot; shell is selected in config.
// Also, this does not create the shell, only returns the factory function.
const fastShellBlacklist = ['Falling Leaves', 'Floral', 'Willow'];
function randomFastShell() {
	const isRandom = shellNameSelector() === 'Random';
	let shellName = isRandom ? randomShellName() : shellNameSelector();
	if (isRandom) {
		while (fastShellBlacklist.includes(shellName)) {
			shellName = randomShellName();
		}
	}
	return shellTypes[shellName];
}


const shellTypes = {
	'Random': randomShell,
	'Crackle': crackleShell,
	'Crossette': crossetteShell,
	'Crysanthemum': crysanthemumShell,
	'Falling Leaves': fallingLeavesShell,
	'Floral': floralShell,
	'Ghost': ghostShell,
	'Horse Tail': horsetailShell,
	'Palm': palmShell,
	'Ring': ringShell,
	'Strobe': strobeShell,
	'Willow': willowShell
};

const shellNames = Object.keys(shellTypes);

function init() {
	// Remove loading state
	document.querySelector('.loading-init').remove();
	appNodes.stageContainer.classList.remove('remove');
	
	// Populate dropdowns
	function setOptionsForSelect(node, options) {
		node.innerHTML = options.reduce((acc, opt) => acc += `<option value=&quot;${opt.value}&quot;>${opt.label}</option>`, '');
	}

	// shell type
	let options = '';
	shellNames.forEach(opt => options += `<option value=&quot;${opt}&quot;>${opt}</option>`);
	appNodes.shellType.innerHTML = options;
	// shell size
	options = '';
	['3&quot;', '4&quot;', '6&quot;', '8&quot;', '12&quot;', '16&quot;'].forEach((opt, i) => options += `<option value=&quot;${i}&quot;>${opt}</option>`);
	appNodes.shellSize.innerHTML = options;
	
	setOptionsForSelect(appNodes.quality, [
		{ label: 'Low', value: QUALITY_LOW },
		{ label: 'Normal', value: QUALITY_NORMAL },
		{ label: 'High', value: QUALITY_HIGH }
	]);
	
	setOptionsForSelect(appNodes.skyLighting, [
		{ label: 'None', value: SKY_LIGHT_NONE },
		{ label: 'Dim', value: SKY_LIGHT_DIM },
		{ label: 'Normal', value: SKY_LIGHT_NORMAL }
	]);
	
	// 0.9 is mobile default
	setOptionsForSelect(
		appNodes.scaleFactor,
		[0.5, 0.62, 0.75, 0.9, 1.0, 1.5, 2.0]
		.map(value => ({ value: value.toFixed(2), label: `${value*100}%` }))
	);
	
	// Begin simulation
	togglePause(false);
	
	// initial render
	renderApp(store.state);
	
	// Apply initial config
	configDidUpdate();
}


function fitShellPositionInBoundsH(position) {
	const edge = 0.18;
	return (1 - edge*2) * position + edge;
}

function fitShellPositionInBoundsV(position) {
	return position * 0.75;
}

function getRandomShellPositionH() {
	return fitShellPositionInBoundsH(Math.random());
}

function getRandomShellPositionV() {
	return fitShellPositionInBoundsV(Math.random());
}

function getRandomShellSize() {
	const baseSize = shellSizeSelector();
	const maxVariance = Math.min(2.5, baseSize);
	const variance = Math.random() * maxVariance;
	const size = baseSize - variance;
	const height = maxVariance === 0 ? Math.random() : 1 - (variance / maxVariance);
	const centerOffset = Math.random() * (1 - height * 0.65) * 0.5;
	const x = Math.random() < 0.5 ? 0.5 - centerOffset : 0.5 + centerOffset;
	return {
		size,
		x: fitShellPositionInBoundsH(x),
		height: fitShellPositionInBoundsV(height)
	};
}


// Launches a shell from a user pointer event, based on state.config
function launchShellFromConfig(event) {
	const shell = new Shell(shellFromConfig(shellSizeSelector()));
	const w = mainStage.width;
	const h = mainStage.height;
	
	shell.launch(
		event ? event.x / w : getRandomShellPositionH(),
		event ? 1 - event.y / h : getRandomShellPositionV()
	);
}


// Sequences
// -----------

function seqRandomShell() {
	const size = getRandomShellSize();
	const shell = new Shell(shellFromConfig(size.size));
	shell.launch(size.x, size.height);
	
	let extraDelay = shell.starLife;
	if (shell.fallingLeaves) {
		extraDelay = 1;
	}
	
	return 1 + Math.random() * 400 + extraDelay;
}

function seqRandomFastShell() {
	const shellType = randomFastShell();
	const size = getRandomShellSize();
	const shell = new Shell(shellType(size.size));
	shell.launch(size.x, size.height);
	
	let extraDelay = shell.starLife;
	
	return 9 + Math.random() * 6 + extraDelay;
}

function seqTwoRandom() {
	const size1 = getRandomShellSize();
	const size2 = getRandomShellSize();
	const shell1 = new Shell(shellFromConfig(size1.size));
	const shell2 = new Shell(shellFromConfig(size2.size));
	const leftOffset = Math.random() * 0.2 - 0.1;
	const rightOffset = Math.random() * 0.2 - 0.1;
	shell1.launch(0.3 + leftOffset, size1.height);
	setTimeout(() => {
		shell2.launch(0.7 + rightOffset, size2.height);
	}, 10);
	
	let extraDelay = Math.max(shell1.starLife, shell2.starLife);
	if (shell1.fallingLeaves || shell2.fallingLeaves) {
		extraDelay = 1;
	}
	
	return 1 + Math.random() * 600 + extraDelay;
}

function seqTriple() {
	const shellType = randomFastShell();
	const baseSize = shellSizeSelector();
	const smallSize = Math.max(0, baseSize - 1.25);
	
	const offset = Math.random() * 0.08 - 0.04;
	const shell1 = new Shell(shellType(baseSize));
	shell1.launch(0.5 + offset, 0.7);
	
	const leftDelay = 1 + Math.random() * 400;
	const rightDelay = 1 + Math.random() * 400;
	
	setTimeout(() => {
		const offset = Math.random() * 0.08 - 0.04;
		const shell2 = new Shell(shellType(smallSize));
		shell2.launch(0.2 + offset, 0.1);
	}, leftDelay);
	
	setTimeout(() => {
		const offset = Math.random() * 0.08 - 0.04;
		const shell3 = new Shell(shellType(smallSize));
		shell3.launch(0.8 + offset, 0.1);
	}, rightDelay);
	
	return 40;
}

function seqPyramid() {
	const barrageCountHalf = IS_DESKTOP ? 7 : 4;
	const largeSize = shellSizeSelector();
	const smallSize = Math.max(0, largeSize - 3);
	const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;
	const randomSpecialShell = randomShell;

	function launchShell(x, useSpecial) {
		const isRandom = shellNameSelector() === 'Random';
		let shellType = isRandom
			? useSpecial ? randomSpecialShell : randomMainShell
			: shellTypes[shellNameSelector()];
		const shell = new Shell(shellType(useSpecial ? largeSize : smallSize));
		const height = x <= 0.5 ? x / 0.5 : (1 - x) / 0.5;
		shell.launch(x, useSpecial ? 0.75 : height * 0.42);
	}
	
	let count = 0;
	let delay = 0;
	while(count <= barrageCountHalf) {
		if (count === barrageCountHalf) {
			setTimeout(() => {
				launchShell(0.5, true);
			}, delay);
		} else {
			const offset = count / barrageCountHalf * 0.5;
			const delayOffset = Math.random() * 30 + 30;
			setTimeout(() => {
				launchShell(offset, false);
			}, delay);
			setTimeout(() => {
				launchShell(1 - offset, false);
			}, delay + delayOffset);
		}
		
		count++;
		delay += 200;
	}
	
	return 1 + barrageCountHalf * 1;
}

function seqSmallBarrage() {
	seqSmallBarrage.lastCalled = Date.now();
	const barrageCount = IS_DESKTOP ? 11 : 5;
	const specialIndex = IS_DESKTOP ? 3 : 1;
	const shellSize = Math.max(0, shellSizeSelector() - 2);
	const randomMainShell = Math.random() < 0.78 ? crysanthemumShell : ringShell;
	const randomSpecialShell = randomFastShell();
	
	// (cos(x*5+0.5)+1)/2 is a custom wave bounded by 0 and 1 used to set varying launch heights
	function launchShell(x, useSpecial) {
		const isRandom = shellNameSelector() === 'Random';
		let shellType = isRandom
			? useSpecial ? randomSpecialShell : randomMainShell
			: shellTypes[shellNameSelector()];
		const shell = new Shell(shellType(shellSize));
		const height = (Math.cos(x*5*Math.PI + PI_HALF) + 1) / 2;
		shell.launch(x, height * 0.75);
	}
	
	let count = 0;
	let delay = 0;
	while(count < barrageCount) {
		if (count === 0) {
			launchShell(0.5, false)
			count += 1;
		}
		else {
			const offset = (count + 1) / barrageCount / 2;
			const delayOffset = Math.random() * 30 + 30;
			const useSpecial = count === specialIndex;
			setTimeout(() => {
				launchShell(0.5 + offset, useSpecial);
			}, delay);
			setTimeout(() => {
				launchShell(0.5 - offset, useSpecial);
			}, delay + delayOffset);
			count += 2;
		}
		delay += 200;
	}
	
	return 1 + barrageCount * 1;
}
seqSmallBarrage.cooldown = 10;
seqSmallBarrage.lastCalled = Date.now();


const sequences = [
	seqRandomShell,
	seqTwoRandom,
	seqTriple,
	seqPyramid,
	seqSmallBarrage
];


let isFirstSeq = true;
const finaleCount = 32;
let currentFinaleCount = 0;
function startSequence() {
	if (isFirstSeq) {
		isFirstSeq = false;
		if (IS_HEADER) {
			return seqTwoRandom();
		}
		else {
			const shell = new Shell(crysanthemumShell(shellSizeSelector()));
			shell.launch(0.5, 0.5);
			return 2400;
		}
	}
	
	if (finaleSelector()) {
		seqRandomFastShell();
		if (currentFinaleCount < finaleCount) {
			currentFinaleCount++;
			return 170;
		}
		else {
			currentFinaleCount = 0;
			return 6000;
		}
	}
	
	const rand = Math.random();
	
	if (rand < 0.08 &amp;&amp; Date.now() - seqSmallBarrage.lastCalled > seqSmallBarrage.cooldown) {
		return seqSmallBarrage();
	}
	
	if (rand < 0.1) {
		return seqPyramid();
	}
	
	if (rand < 0.6 &amp;&amp; !IS_HEADER) {
		return seqRandomShell();
	}
	else if (rand < 0.8) {
		return seqTwoRandom();
	}
	else if (rand < 1) {
		return seqTriple();
	}
}


let activePointerCount = 0;
let isUpdatingSpeed = false;

function handlePointerStart(event) {
	activePointerCount++;
	const btnSize = 50;
	
	if (event.y < btnSize) {
		if (event.x < btnSize) {
			togglePause();
			return;
		}
		if (event.x > mainStage.width/2 - btnSize/2 &amp;&amp; event.x < mainStage.width/2 + btnSize/2) {
			toggleSound();
			return;
		}
		if (event.x > mainStage.width - btnSize) {
			toggleMenu();
			return;
		}
	}
	
	if (!isRunning()) return;
	
	if (updateSpeedFromEvent(event)) {
		isUpdatingSpeed = true;
	}
	else if (event.onCanvas) {
		launchShellFromConfig(event);
	}
}

function handlePointerEnd(event) {
	activePointerCount--;
	isUpdatingSpeed = false;
}

function handlePointerMove(event) {
	if (!isRunning()) return;
	
	if (isUpdatingSpeed) {
		updateSpeedFromEvent(event);
	}
}

function handleKeydown(event) {
	// P
	if (event.keyCode === 80) {
		togglePause();
	}
	// O
	else if (event.keyCode === 79) {
		toggleMenu();
	}
	// Esc
	else if (event.keyCode === 27) {
		toggleMenu(false);
	}
}

mainStage.addEventListener('pointerstart', handlePointerStart);
mainStage.addEventListener('pointerend', handlePointerEnd);
mainStage.addEventListener('pointermove', handlePointerMove);
window.addEventListener('keydown', handleKeydown);


// Account for window resize and custom scale changes.
function handleResize() {
	const w = window.innerWidth;
	const h = window.innerHeight;
	// Try to adopt screen size, heeding maximum sizes specified
	const containerW = Math.min(w, MAX_WIDTH);
	// On small screens, use full device height
	const containerH = w <= 420 ? h : Math.min(h, MAX_HEIGHT);
	appNodes.stageContainer.style.width = containerW + 'px';
	appNodes.stageContainer.style.height = containerH + 'px';
	stages.forEach(stage => stage.resize(containerW, containerH));
	// Account for scale
	const scaleFactor = scaleFactorSelector();
	stageW = containerW / scaleFactor;
	stageH = containerH / scaleFactor;
}

// Compute initial dimensions
handleResize();

window.addEventListener('resize', handleResize);


// Dynamic globals
let currentFrame = 0;
let speedBarOpacity = 0;
let autoLaunchTime = 0;

function updateSpeedFromEvent(event) {
	if (isUpdatingSpeed || event.y >= mainStage.height - 44) {
		// On phones it's hard to hit the edge pixels in order to set speed at 0 or 1, so some padding is provided to make that easier.
		const edge = 16;
		const newSpeed = (event.x - edge) / (mainStage.width - edge * 2);
		simSpeed = Math.min(Math.max(newSpeed, 0), 1);
		// show speed bar after an update
		speedBarOpacity = 1;
		// If we updated the speed, return true
		return true;
	}
	// Return false if the speed wasn't updated
	return false;
}


// Extracted function to keep `update()` optimized
function updateGlobals(timeStep, lag) {
	currentFrame++;
	
	// Always try to fade out speed bar
	if (!isUpdatingSpeed) {
	speedBarOpacity -= lag / 30; // half a second
		if (speedBarOpacity < 0) {
			speedBarOpacity = 0;
		}
	}
	
	// auto launch shells
	if (store.state.config.autoLaunch) {
		autoLaunchTime -= timeStep;
		if (autoLaunchTime <= 0) {
			autoLaunchTime = startSequence() * 1.25;
		}
	}
}


function update(frameTime, lag) {
	if (!isRunning()) return;
	
	const width = stageW;
	const height = stageH;
	const timeStep = frameTime * simSpeed;
	const speed = simSpeed * lag;
	
	updateGlobals(timeStep, lag);
	
	const starDrag = 1 - (1 - Star.airDrag) * speed;
	const starDragHeavy = 1 - (1 - Star.airDragHeavy) * speed;
	const sparkDrag = 1 - (1 - Spark.airDrag) * speed;
	const gAcc = timeStep / 1000 * GRAVITY;
	COLOR_CODES_W_INVIS.forEach(color => {
		// Stars
		const stars = Star.active[color];
		for (let i=stars.length-1; i>=0; i=i-1) {
			const star = stars[i];
			// Only update each star once per frame. Since color can change, it's possible a star could update twice without this, leading to a &quot;jump&quot;.
			if (star.updateFrame === currentFrame) {
				continue;
			}
			star.updateFrame = currentFrame;
			
			star.life -= timeStep;
			if (star.life <= 0) {
				stars.splice(i, 1);
				Star.returnInstance(star);
			} else {
				const burnRate = Math.pow(star.life / star.fullLife, 0.5);
				const burnRateInverse = 1 - burnRate;

				star.prevX = star.x;
				star.prevY = star.y;
				star.x += star.speedX * speed;
				star.y += star.speedY * speed;
				// Apply air drag if star isn't &quot;heavy&quot;. The heavy property is used for the shell comets.
				if (!star.heavy) {
					star.speedX *= starDrag;
					star.speedY *= starDrag;
				}
				else {
					star.speedX *= starDragHeavy;
					star.speedY *= starDragHeavy;
				}
				star.speedY += gAcc;
				
				if (star.spinRadius) {
					star.spinAngle += star.spinSpeed * speed;
					star.x += Math.sin(star.spinAngle) * star.spinRadius * speed;
					star.y += Math.cos(star.spinAngle) * star.spinRadius * speed;
				}
				
				if (star.sparkFreq) {
					star.sparkTimer -= timeStep;
					while (star.sparkTimer < 0) {
						star.sparkTimer += star.sparkFreq * 0.75 + star.sparkFreq * burnRateInverse * 4;
						Spark.add(
							star.x,
							star.y,
							star.sparkColor,
							Math.random() * PI_2,
							Math.random() * star.sparkSpeed * burnRate,
							star.sparkLife * 0.8 + Math.random() * star.sparkLifeVariation * star.sparkLife
						);
					}
				}
				
				// Handle star transitions
				if (star.life < star.transitionTime) {
					if (star.secondColor &amp;&amp; !star.colorChanged) {
						star.colorChanged = true;
						star.color = star.secondColor;
						stars.splice(i, 1);
						Star.active[star.secondColor].push(star);
						if (star.secondColor === INVISIBLE) {
							star.sparkFreq = 0;
						}
					}
					
					if (star.strobe) {
						// Strobes in the following pattern: on:off:off:on:off:off in increments of `strobeFreq` ms.
						star.visible = Math.floor(star.life / star.strobeFreq) % 3 === 0;
					}
				}
			}
		}
											
		// Sparks
		const sparks = Spark.active[color];
		for (let i=sparks.length-1; i>=0; i=i-1) {
			const spark = sparks[i];
			spark.life -= timeStep;
			if (spark.life <= 0) {
				sparks.splice(i, 1);
				Spark.returnInstance(spark);
			} else {
				spark.prevX = spark.x;
				spark.prevY = spark.y;
				spark.x += spark.speedX * speed;
				spark.y += spark.speedY * speed;
				spark.speedX *= sparkDrag;
				spark.speedY *= sparkDrag;
				spark.speedY += gAcc;
			}
		}
	});
	
	render(speed);
}

function render(speed) {
	const { dpr } = mainStage;
	const width = stageW;
	const height = stageH;
	const trailsCtx = trailsStage.ctx;
	const mainCtx = mainStage.ctx;
	
	if (skyLightingSelector() !== SKY_LIGHT_NONE) {
		colorSky(speed);
	}
	
	// Account for high DPI screens, and custom scale factor.
	const scaleFactor = scaleFactorSelector();
	trailsCtx.scale(dpr * scaleFactor, dpr * scaleFactor);
	mainCtx.scale(dpr * scaleFactor, dpr * scaleFactor);
	
	trailsCtx.globalCompositeOperation = 'source-over';
	trailsCtx.fillStyle = `rgba(0, 0, 0, ${store.state.config.longExposure ? 0.0025 : 0.175 * speed})`;
	trailsCtx.fillRect(0, 0, width, height);
	
	mainCtx.clearRect(0, 0, width, height);
	
	// Draw queued burst flashes
	// These must also be drawn using source-over due to Safari. Seems rendering the gradients using lighten draws large black boxes instead.
	// Thankfully, these burst flashes look pretty much the same either way.
	while (BurstFlash.active.length) {
		const bf = BurstFlash.active.pop();
		
		const burstGradient = trailsCtx.createRadialGradient(bf.x, bf.y, 0, bf.x, bf.y, bf.radius);
		burstGradient.addColorStop(0.024, 'rgba(255, 255, 255, 1)');
		burstGradient.addColorStop(0.125, 'rgba(255, 160, 20, 0.2)');
		burstGradient.addColorStop(0.32, 'rgba(255, 140, 20, 0.11)');
		burstGradient.addColorStop(1, 'rgba(255, 120, 20, 0)');
		trailsCtx.fillStyle = burstGradient;
		trailsCtx.fillRect(bf.x - bf.radius, bf.y - bf.radius, bf.radius * 2, bf.radius * 2);
		
		BurstFlash.returnInstance(bf);
	}
	
	// Remaining drawing on trails canvas will use 'lighten' blend mode
	trailsCtx.globalCompositeOperation = 'lighten';
	
	// Draw stars
	trailsCtx.lineWidth = Star.drawWidth;
	trailsCtx.lineCap = isLowQuality ? 'square' : 'round';
	mainCtx.strokeStyle = '#fff';
 &nbsp;mainCtx.lineWidth = 1;
	mainCtx.beginPath();
	COLOR_CODES.forEach(color => {
		const stars = Star.active[color];
		trailsCtx.strokeStyle = color;
		trailsCtx.beginPath();
		stars.forEach(star => {
			if (star.visible) {
				trailsCtx.moveTo(star.x, star.y);
				trailsCtx.lineTo(star.prevX, star.prevY);
				mainCtx.moveTo(star.x, star.y);
				mainCtx.lineTo(star.x - star.speedX * 1.6, star.y - star.speedY * 1.6);
			}
		});
		trailsCtx.stroke();
	});
	mainCtx.stroke();

	// Draw sparks
	trailsCtx.lineWidth = Spark.drawWidth;
	trailsCtx.lineCap = 'butt';
	COLOR_CODES.forEach(color => {
		const sparks = Spark.active[color];
		trailsCtx.strokeStyle = color;
		trailsCtx.beginPath();
		sparks.forEach(spark => {
			trailsCtx.moveTo(spark.x, spark.y);
			trailsCtx.lineTo(spark.prevX, spark.prevY);
		});
		trailsCtx.stroke();
	});
	
	
	// Render speed bar if visible
	if (speedBarOpacity) {
		const speedBarHeight = 6;
		mainCtx.globalAlpha = speedBarOpacity;
		mainCtx.fillStyle = COLOR.Blue;
		mainCtx.fillRect(0, height - speedBarHeight, width * simSpeed, speedBarHeight);
		mainCtx.globalAlpha = 1;
	}
	
	
	trailsCtx.setTransform(1, 0, 0, 1, 0, 0);
	mainCtx.setTransform(1, 0, 0, 1, 0, 0);
}


// Draw colored overlay based on combined brightness of stars (light up the sky!)
// Note: this is applied to the canvas container's background-color, so it's behind the particles
const currentSkyColor = { r: 0, g: 0, b: 0 };
const targetSkyColor = { r: 0, g: 0, b: 0 };
function colorSky(speed) {
	// The maximum r, g, or b value that will be used (255 would represent no maximum)
	const maxSkySaturation = skyLightingSelector() * 15;
	// How many stars are required in total to reach maximum sky brightness
	const maxStarCount = 500;
	let totalStarCount = 0;
	// Initialize sky as black
	targetSkyColor.r = 0;
	targetSkyColor.g = 0;
	targetSkyColor.b = 0;
	// Add each known color to sky, multiplied by particle count of that color. This will put RGB values wildly out of bounds, but we'll scale them back later.
	// Also add up total star count.
	COLOR_CODES.forEach(color => {
		const tuple = COLOR_TUPLES[color];
		const count =  Star.active[color].length;
		totalStarCount += count;
		targetSkyColor.r += tuple.r * count;
		targetSkyColor.g += tuple.g * count;
		targetSkyColor.b += tuple.b * count;
	});
	
	// Clamp intensity at 1.0, and map to a custom non-linear curve. This allows few stars to perceivably light up the sky, while more stars continue to increase the brightness but at a lesser rate. This is more inline with humans' non-linear brightness perception.
	const intensity = Math.pow(Math.min(1, totalStarCount / maxStarCount), 0.3);
	// Figure out which color component has the highest value, so we can scale them without affecting the ratios.
	// Prevent 0 from being used, so we don't divide by zero in the next step.
	const maxColorComponent = Math.max(1, targetSkyColor.r, targetSkyColor.g, targetSkyColor.b);
	// Scale all color components to a max of `maxSkySaturation`, and apply intensity.
	targetSkyColor.r = targetSkyColor.r / maxColorComponent * maxSkySaturation * intensity;
	targetSkyColor.g = targetSkyColor.g / maxColorComponent * maxSkySaturation * intensity;
	targetSkyColor.b = targetSkyColor.b / maxColorComponent * maxSkySaturation * intensity;
	
	// Animate changes to color to smooth out transitions.
	const colorChange = 10;
	currentSkyColor.r += (targetSkyColor.r - currentSkyColor.r) / colorChange * speed;
	currentSkyColor.g += (targetSkyColor.g - currentSkyColor.g) / colorChange * speed;
	currentSkyColor.b += (targetSkyColor.b - currentSkyColor.b) / colorChange * speed;
	
	appNodes.canvasContainer.style.backgroundColor = `rgb(${currentSkyColor.r | 0}, ${currentSkyColor.g | 0}, ${currentSkyColor.b | 0})`;
}

mainStage.addEventListener('ticker', update);


// Helper used to semi-randomly spread particles over an arc
// Values are flexible - `start` and `arcLength` can be negative, and `randomness` is simply a multiplier for random addition.
function createParticleArc(start, arcLength, count, randomness, particleFactory) {
	const angleDelta = arcLength / count;
	// Sometimes there is an extra particle at the end, too close to the start. Subtracting half the angleDelta ensures that is skipped.
	// Would be nice to fix this a better way.
	const end = start + arcLength - (angleDelta * 0.5);
	
	if (end > start) {
		// Optimization: `angle=angle+angleDelta` vs. angle+=angleDelta
		// V8 deoptimises with let compound assignment
		for (let angle=start; angle<end; angle=angle+angleDelta) {
			particleFactory(angle + Math.random() * angleDelta * randomness);
		}
	} else {
		for (let angle=start; angle>end; angle=angle+angleDelta) {
			particleFactory(angle + Math.random() * angleDelta * randomness);
		}
	}
}


/**
 * Helper used to create a spherical burst of particles.
 *
 * @param  {Number} count               The desired number of stars/particles. This value is a suggestion, and the
 *                                      created burst may have more particles. The current algorithm can't perfectly
 *                                      distribute a specific number of points evenly on a sphere's surface.
 * @param  {Function} particleFactory   Called once per star/particle generated. Passed two arguments:
 *                                        `angle`: The direction of the star/particle.
 *                                        `speed`: A multipler for the particle speed, from 0.0 to 1.0.
 * @param  {Number} startAngle=0        For segmented bursts, you can generate only a partial arc of particles. This
 *                                      allows setting the starting arc angle (radians).
 * @param  {Number} arcLength=TAU       The length of the arc (radians). Defaults to a full circle.
 *
 * @return {void}              Returns nothing; it's up to `particleFactory` to use the given data.
 */
function createBurst(count, particleFactory, startAngle=0, arcLength=PI_2) {
	// Assuming sphere with surface area of `count`, calculate various
	// properties of said sphere (unit is stars).
	// Radius
	const R = 0.5 * Math.sqrt(count/Math.PI);
	// Circumference
	const C = 2 * R * Math.PI;
	// Half Circumference
	const C_HALF = C / 2;
	
	// Make a series of rings, sizing them as if they were spaced evenly
	// along the curved surface of a sphere.
	for (let i=0; i<=C_HALF; i++) {
		const ringAngle = i / C_HALF * PI_HALF;
		const ringSize = Math.cos(ringAngle);
		const partsPerFullRing = C * ringSize;
		const partsPerArc = partsPerFullRing * (arcLength / PI_2);
		
		const angleInc = PI_2 / partsPerFullRing;
		const angleOffset = Math.random() * angleInc + startAngle;
		// Each particle needs a bit of randomness to improve appearance.
		const maxRandomAngleOffset = angleInc * 0.33;
		
		for (let i=0; i<partsPerArc; i++) {
			const randomAngleOffset = Math.random() * maxRandomAngleOffset;
			let angle = angleInc * i + angleOffset + randomAngleOffset;
			particleFactory(angle, ringSize);
		}
	}
}




// Various star effects.
// These are designed to be attached to a star's `onDeath` event.

// Crossette breaks star into four same-color pieces which branch in a cross-like shape.
function crossetteEffect(star) {
	const startAngle = Math.random() * PI_HALF;
	createParticleArc(startAngle, PI_2, 4, 0.5, (angle) => {
		Star.add(
			star.x,
			star.y,
			star.color,
			angle,
			Math.random() * 0.6 + 0.75,
			600
		);
	});
}

// Flower is like a mini shell
function floralEffect(star) {
	const count = 12 + 6 * quality;
	createBurst(count, (angle, speedMult) => {
		Star.add(
			star.x,
			star.y,
			star.color,
			angle,
			speedMult * 2.4,
			1000 + Math.random() * 300,
			star.speedX,
			star.speedY
		);
	});
	// Queue burst flash render
	BurstFlash.add(star.x, star.y, 46);
	soundManager.playSound('burstSmall');
}

// Floral burst with willow stars
function fallingLeavesEffect(star) {
	createBurst(7, (angle, speedMult) => {
		const newStar = Star.add(
			star.x,
			star.y,
			INVISIBLE,
			angle,
			speedMult * 2.4,
			2400 + Math.random() * 600,
			star.speedX,
			star.speedY
		);
		
		newStar.sparkColor = COLOR.Gold;
		newStar.sparkFreq = 144 / quality;
		newStar.sparkSpeed = 0.28;
		newStar.sparkLife = 750;
		newStar.sparkLifeVariation = 3.2;
	});
	// Queue burst flash render
	BurstFlash.add(star.x, star.y, 46);
	soundManager.playSound('burstSmall');
}

// Crackle pops into a small cloud of golden sparks.
function crackleEffect(star) {
	const count = isHighQuality ? 32 : 16;
	createParticleArc(0, PI_2, count, 1.8, (angle) => {
		Spark.add(
			star.x,
			star.y,
			COLOR.Gold,
			angle,
			// apply near cubic falloff to speed (places more particles towards outside)
			Math.pow(Math.random(), 0.45) * 2.4,
			300 + Math.random() * 200
		);
	});
}



/**
 * Shell can be constructed with options:
 *
 * spreadSize:      Size of the burst.
 * starCount: Number of stars to create. This is optional, and will be set to a reasonable quantity for size if omitted.
 * starLife:
 * starLifeVariation:
 * color:
 * glitterColor:
 * glitter: One of: 'light', 'medium', 'heavy', 'streamer', 'willow'
 * pistil:
 * pistilColor:
 * streamers:
 * crossette:
 * floral:
 * crackle:
 */
class Shell {
	constructor(options) {
		Object.assign(this, options);
		this.starLifeVariation = options.starLifeVariation || 0.125;
		this.color = options.color || randomColor();
		this.glitterColor = options.glitterColor || this.color;
				
		// Set default starCount if needed, will be based on shell size and scale exponentially, like a sphere's surface area.
		if (!this.starCount) {
			const density = options.starDensity || 1;
			const scaledSize = this.spreadSize / 54;
			this.starCount = Math.max(6, scaledSize * scaledSize * density);
		}
	}
	
	launch(position, launchHeight) {
		const width = stageW;
		const height = stageH;
		// Distance from sides of screen to keep shells.
		const hpad = 60;
		// Distance from top of screen to keep shell bursts.
		const vpad = 50;
		// Minimum burst height, as a percentage of stage height
		const minHeightPercent = 0.45;
		// Minimum burst height in px
		const minHeight = height - height * minHeightPercent;
		
		const launchX = position * (width - hpad * 2) + hpad;
		const launchY = height;
		const burstY = minHeight - (launchHeight * (minHeight - vpad));
		
		const launchDistance = launchY - burstY;
		// Using a custom power curve to approximate Vi needed to reach launchDistance under gravity and air drag.
		// Magic numbers came from testing.
		const launchVelocity = Math.pow(launchDistance * 0.04, 0.64);
		
		const comet = this.comet = Star.add(
			launchX,
			launchY,
			typeof this.color === 'string' &amp;&amp; this.color !== 'random' ? this.color : COLOR.White,
			Math.PI,
			launchVelocity * (this.horsetail ? 1.2 : 1),
			// Hang time is derived linearly from Vi; exact number came from testing
			launchVelocity * (this.horsetail ? 100 : 400)
		);
		
		// making comet &quot;heavy&quot; limits air drag
		comet.heavy = true;
		// comet spark trail
		comet.spinRadius = MyMath.random(0.32, 0.85);
		comet.sparkFreq = 32 / quality;
		if (isHighQuality) comet.sparkFreq = 8;
		comet.sparkLife = 320;
		comet.sparkLifeVariation = 3;
		if (this.glitter === 'willow' || this.fallingLeaves) {
			comet.sparkFreq = 20 / quality;
			comet.sparkSpeed = 0.5;
			comet.sparkLife = 500;
		}
		if (this.color === INVISIBLE) {
			comet.sparkColor = COLOR.Gold;
		}
		
		// Randomly make comet &quot;burn out&quot; a bit early.
		// This is disabled for horsetail shells, due to their very short airtime.
		if (Math.random() > 0.4 &amp;&amp; !this.horsetail) {
			comet.secondColor = INVISIBLE;
			comet.transitionTime = Math.pow(Math.random(), 1.5) * 700 + 500;
		}
		
		comet.onDeath = comet => this.burst(comet.x, comet.y);
		
		soundManager.playSound('lift');
	}
	
	burst(x, y) {
		// Set burst speed so overall burst grows to set size. This specific formula was derived from testing, and is affected by simulated air drag.
		const speed = this.spreadSize / 96;

		let color, onDeath, sparkFreq, sparkSpeed, sparkLife;
		let sparkLifeVariation = 0.25;
		// Some death effects, like crackle, play a sound, but should only be played once.
		let playedDeathSound = false;
		
		if (this.crossette) onDeath = (star) => {
			if (!playedDeathSound) {
				soundManager.playSound('crackleSmall');
				playedDeathSound = true;
			}
			crossetteEffect(star);
		}
		if (this.crackle) onDeath = (star) => {
			if (!playedDeathSound) {
				soundManager.playSound('crackle');
				playedDeathSound = true;
			}
			crackleEffect(star);
		}
		if (this.floral) onDeath = floralEffect;
		if (this.fallingLeaves) onDeath = fallingLeavesEffect;
		
		if (this.glitter === 'light') {
			sparkFreq = 400;
			sparkSpeed = 0.3;
			sparkLife = 300;
			sparkLifeVariation = 2;
		}
		else if (this.glitter === 'medium') {
			sparkFreq = 200;
			sparkSpeed = 0.44;
			sparkLife = 700;
			sparkLifeVariation = 2;
		}
		else if (this.glitter === 'heavy') {
			sparkFreq = 80;
			sparkSpeed = 0.8;
			sparkLife = 1400;
			sparkLifeVariation = 2;
		}
		else if (this.glitter === 'thick') {
			sparkFreq = 16;
			sparkSpeed = isHighQuality ? 1.65 : 1.5;
			sparkLife = 1400;
			sparkLifeVariation = 3;
		}
		else if (this.glitter === 'streamer') {
			sparkFreq = 32;
			sparkSpeed = 1.05;
			sparkLife = 620;
			sparkLifeVariation = 2;
		}
		else if (this.glitter === 'willow') {
			sparkFreq = 120;
			sparkSpeed = 0.34;
			sparkLife = 1400;
			sparkLifeVariation = 3.8;
		}
		
		// Apply quality to spark count
		sparkFreq = sparkFreq / quality;
		
		// Star factory for primary burst, pistils, and streamers.
		let firstStar = true;
		const starFactory = (angle, speedMult) => {
			// For non-horsetail shells, compute an initial vertical speed to add to star burst.
			// The magic number comes from testing what looks best. The ideal is that all shell
			// bursts appear visually centered for the majority of the star life (excl. willows etc.)
			const standardInitialSpeed = this.spreadSize / 1800;
			
			const star = Star.add(
				x,
				y,
				color || randomColor(),
				angle,
				speedMult * speed,
				// add minor variation to star life
				this.starLife + Math.random() * this.starLife * this.starLifeVariation,
				this.horsetail ? this.comet &amp;&amp; this.comet.speedX : 0,
				this.horsetail ? this.comet &amp;&amp; this.comet.speedY : -standardInitialSpeed
			);
	
			if (this.secondColor) {
				star.transitionTime = this.starLife * (Math.random() * 0.05 + 0.32);
				star.secondColor = this.secondColor;
			}

			if (this.strobe) {
				star.transitionTime = this.starLife * (Math.random() * 0.08 + 0.46);
				star.strobe = true;
				// How many milliseconds between switch of strobe state &quot;tick&quot;. Note that the strobe pattern
				// is on:off:off, so this is the &quot;on&quot; duration, while the &quot;off&quot; duration is twice as long.
				star.strobeFreq = Math.random() * 20 + 40;
				if (this.strobeColor) {
					star.secondColor = this.strobeColor;
				}
			}
			
			star.onDeath = onDeath;

			if (this.glitter) {
				star.sparkFreq = sparkFreq;
				star.sparkSpeed = sparkSpeed;
				star.sparkLife = sparkLife;
				star.sparkLifeVariation = sparkLifeVariation;
				star.sparkColor = this.glitterColor;
				star.sparkTimer = Math.random() * star.sparkFreq;
			}
		};
		
		
		if (typeof this.color === 'string') {
			if (this.color === 'random') {
				color = null; // falsey value creates random color in starFactory
			} else {
				color = this.color;
			}
			
			// Rings have positional randomness, but are rotated randomly
			if (this.ring) {
				const ringStartAngle = Math.random() * Math.PI;
				const ringSquash = Math.pow(Math.random(), 2) * 0.85 + 0.15;;
				
				createParticleArc(0, PI_2, this.starCount, 0, angle => {
					// Create a ring, squashed horizontally
					const initSpeedX = Math.sin(angle) * speed * ringSquash;
					const initSpeedY = Math.cos(angle) * speed;
					// Rotate ring
					const newSpeed = MyMath.pointDist(0, 0, initSpeedX, initSpeedY);
					const newAngle = MyMath.pointAngle(0, 0, initSpeedX, initSpeedY) + ringStartAngle;
					const star = Star.add(
						x,
						y,
						color,
						newAngle,
						// apply near cubic falloff to speed (places more particles towards outside)
						newSpeed,//speed,
						// add minor variation to star life
						this.starLife + Math.random() * this.starLife * this.starLifeVariation
					);
					
					if (this.glitter) {
						star.sparkFreq = sparkFreq;
						star.sparkSpeed = sparkSpeed;
						star.sparkLife = sparkLife;
						star.sparkLifeVariation = sparkLifeVariation;
						star.sparkColor = this.glitterColor;
						star.sparkTimer = Math.random() * star.sparkFreq;
					}
				});
			}
			// Normal burst
			else {
				createBurst(this.starCount, starFactory);
			}
		}
		else if (Array.isArray(this.color)) {
			if (Math.random() < 0.5) {
				const start = Math.random() * Math.PI;
				const start2 = start + Math.PI;
				const arc = Math.PI;
				color = this.color[0];
				// Not creating a full arc automatically reduces star count.
				createBurst(this.starCount, starFactory, start, arc);
				color = this.color[1];
				createBurst(this.starCount, starFactory, start2, arc);
			} else {
				color = this.color[0];
				createBurst(this.starCount / 2, starFactory);
				color = this.color[1];
				createBurst(this.starCount / 2, starFactory);
			}
		}
		else {
			throw new Error('Invalid shell color. Expected string or array of strings, but got: ' + this.color);
		}
		
		if (this.pistil) {
			const innerShell = new Shell({
				spreadSize: this.spreadSize * 0.5,
				starLife: this.starLife * 0.6,
				starLifeVariation: this.starLifeVariation,
				starDensity: 1.4,
				color: this.pistilColor,
				glitter: 'light',
				glitterColor: this.pistilColor === COLOR.Gold ? COLOR.Gold : COLOR.White
			});
			innerShell.burst(x, y);
		}
		
		if (this.streamers) {
			const innerShell = new Shell({
				spreadSize: this.spreadSize * 0.9,
				starLife: this.starLife * 0.8,
				starLifeVariation: this.starLifeVariation,
				starCount: Math.floor(Math.max(6, this.spreadSize / 45)),
				color: COLOR.White,
				glitter: 'streamer'
			});
			innerShell.burst(x, y);
		}
		
		// Queue burst flash render
		BurstFlash.add(x, y, this.spreadSize / 4);

		// Play sound, but only for &quot;original&quot; shell, the one that was launched.
		// We don't want multiple sounds from pistil or streamer &quot;sub-shells&quot;.
		// This can be detected by the presence of a comet.
		if (this.comet) {
			// Scale explosion sound based on current shell size and selected (max) shell size.
			// Shooting selected shell size will always sound the same no matter the selected size,
			// but when smaller shells are auto-fired, they will sound smaller. It doesn't sound great
			// when a value too small is given though, so instead of basing it on proportions, we just
			// look at the difference in size and map it to a range known to sound good.
			const maxDiff = 2;
			const sizeDifferenceFromMaxSize = Math.min(maxDiff, shellSizeSelector() - this.shellSize);
			const soundScale = (1 - sizeDifferenceFromMaxSize / maxDiff) * 0.3 + 0.7;
			soundManager.playSound('burst', soundScale);
		}
	}
}



const BurstFlash = {
	active: [],
	_pool: [],
	
	_new() {
		return {}
	},
	
	add(x, y, radius) {
		const instance = this._pool.pop() || this._new();
		
		instance.x = x;
		instance.y = y;
		instance.radius = radius;
		
		this.active.push(instance);
		return instance;
	},
	
	returnInstance(instance) {
		this._pool.push(instance);
	}
};



// Helper to generate objects for storing active particles.
// Particles are stored in arrays keyed by color (code, not name) for improved rendering performance.
function createParticleCollection() {
	const collection = {};
	COLOR_CODES_W_INVIS.forEach(color => {
		collection[color] = [];
	});
	return collection;
}


// Star properties (WIP)
// -----------------------
// transitionTime - how close to end of life that star transition happens

const Star = {
	// Visual properties
	drawWidth: 3,
	airDrag: 0.98,
	airDragHeavy: 0.992,
	
	// Star particles will be keyed by color
	active: createParticleCollection(),
	_pool: [],
	
	_new() {
		return {};
	},

	add(x, y, color, angle, speed, life, speedOffX, speedOffY) {
		const instance = this._pool.pop() || this._new();
		
		instance.visible = true;
		instance.heavy = false;
		instance.x = x;
		instance.y = y;
		instance.prevX = x;
		instance.prevY = y;
		instance.color = color;
		instance.speedX = Math.sin(angle) * speed + (speedOffX || 0);
		instance.speedY = Math.cos(angle) * speed + (speedOffY || 0);
		instance.life = life;
		instance.fullLife = life;
		instance.spinAngle = Math.random() * PI_2;
		instance.spinSpeed = 0.8;
		instance.spinRadius = 0;
		instance.sparkFreq = 0; // ms between spark emissions
		instance.sparkSpeed = 1;
		instance.sparkTimer = 0;
		instance.sparkColor = color;
		instance.sparkLife = 750;
		instance.sparkLifeVariation = 0.25;
		instance.strobe = false;
		
		this.active[color].push(instance);
		return instance;
	},

	// Public method for cleaning up and returning an instance back to the pool.
	returnInstance(instance) {
		// Call onDeath handler if available (and pass it current star instance)
		instance.onDeath &amp;&amp; instance.onDeath(instance);
		// Clean up
		instance.onDeath = null;
		instance.secondColor = null;
		instance.transitionTime = 0;
		instance.colorChanged = false;
		// Add back to the pool.
		this._pool.push(instance);
	}
};


const Spark = {
	// Visual properties
	drawWidth: 0, // set in `configDidUpdate()`
	airDrag: 0.9,
	
	// Star particles will be keyed by color
	active: createParticleCollection(),
	_pool: [],
	
	_new() {
		return {};
	},

	add(x, y, color, angle, speed, life) {
		const instance = this._pool.pop() || this._new();
		
		instance.x = x;
		instance.y = y;
		instance.prevX = x;
		instance.prevY = y;
		instance.color = color;
		instance.speedX = Math.sin(angle) * speed;
		instance.speedY = Math.cos(angle) * speed;
		instance.life = life;
		
		this.active[color].push(instance);
		return instance;
	},

	// Public method for cleaning up and returning an instance back to the pool.
	returnInstance(instance) {
		// Add back to the pool.
		this._pool.push(instance);
	}
};



const soundManager = {
	baseURL: 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/',
	ctx: new (window.AudioContext || window.webkitAudioContext),
	sources: {
		lift: {
			volume: 1,
			playbackRateMin: 0.85,
			playbackRateMax: 0.95,
			fileNames: [
				'lift1.mp3',
				'lift2.mp3',
				'lift3.mp3'
			]
		},
		burst: {
			volume: 1,
			playbackRateMin: 0.8,
			playbackRateMax: 0.9,
			fileNames: [
				'burst1.mp3',
				'burst2.mp3'
			]
		},
		burstSmall: {
			volume: 0.25,
			playbackRateMin: 0.8,
			playbackRateMax: 1,
			fileNames: [
				'burst-sm-1.mp3',
				'burst-sm-2.mp3'
			]
		},
		crackle: {
			volume: 0.2,
			playbackRateMin: 1,
			playbackRateMax: 1,
			fileNames: ['crackle1.mp3']
		},
		crackleSmall: {
			volume: 0.3,
			playbackRateMin: 1,
			playbackRateMax: 1,
			fileNames: ['crackle-sm-1.mp3']
		}
	},

	preload() {
		const allFilePromises = [];

		function checkStatus(response) {
			if (response.status >= 200 &amp;&amp; response.status < 300) {
				return response;
			}
			const customError = new Error(response.statusText);
			customError.response = response;
			throw customError;
		}

		const types = Object.keys(this.sources);
		types.forEach(type => {
			const source = this.sources[type];
			const { fileNames } = source;
			const filePromises = [];
			fileNames.forEach(fileName => {
				const fileURL = this.baseURL + fileName;
				// Promise will resolve with decoded audio buffer.
				const promise = fetch(fileURL)
					.then(checkStatus)
					.then(response => response.arrayBuffer())
					.then(data => new Promise(resolve => {
						this.ctx.decodeAudioData(data, resolve);
					}));

				filePromises.push(promise);
				allFilePromises.push(promise);
			});

			Promise.all(filePromises)
				.then(buffers => {
					source.buffers = buffers;
				});
		});

		return Promise.all(allFilePromises);
	},
	
	pauseAll() {
		this.ctx.suspend();
	},

	resumeAll() {
		// Play a sound with no volume for iOS. This 'unlocks' the audio context when the user first enables sound.
		this.playSound('lift', 0);
		// Chrome mobile requires interaction before starting audio context.
		// The sound toggle button is triggered on 'touchstart', which doesn't seem to count as a full
		// interaction to Chrome. I guess it needs a click? At any rate if the first thing the user does
		// is enable audio, it doesn't work. Using a setTimeout allows the first interaction to be registered.
		// Perhaps a better solution is to track whether the user has interacted, and if not but they try enabling
		// sound, show a tooltip that they should tap again to enable sound.
		setTimeout(() => {
			this.ctx.resume();
		}, 250);
	},
	
	// Private property used to throttle small burst sounds.
	_lastSmallBurstTime: 0,

	/**
	 * Play a sound of `type`. Will randomly pick a file associated with type, and play it at the specified volume
	 * and play speed, with a bit of random variance in play speed. This is all based on `sources` config.
	 *
	 * @param  {string} type - The type of sound to play.
	 * @param  {?number} scale=1 - Value between 0 and 1 (values outside range will be clamped). Scales less than one
	 *                             descrease volume and increase playback speed. This is because large explosions are
	 *                             louder, deeper, and reverberate longer than small explosions.
	 *                             Note that a scale of 0 will mute the sound.
	 */
	playSound(type, scale=1) {
		// Ensure `scale` is within valid range.
		scale = MyMath.clamp(scale, 0, 1);

		// Disallow starting new sounds if sound is disabled, app is running in slow motion, or paused.
		// Slow motion check has some wiggle room in case user doesn't finish dragging the speed bar
		// *all* the way back.
		if (!canPlaySoundSelector() || simSpeed < 0.95) {
			return;
		}
		
		// Throttle small bursts, since floral/falling leaves shells have a lot of them.
		if (type === 'burstSmall') {
			const now = Date.now();
			if (now - this._lastSmallBurstTime < 20) {
				return;
			}
			this._lastSmallBurstTime = now;
		}
		
		const source = this.sources[type];

		if (!source) {
			throw new Error(`Sound of type &quot;${type}&quot; doesn't exist.`);
		}
		
		const initialVolume = source.volume;
		const initialPlaybackRate = MyMath.random(
			source.playbackRateMin,
			source.playbackRateMax
		);
		
		// Volume descreases with scale.
		const scaledVolume = initialVolume * scale;
		// Playback rate increases with scale. For this, we map the scale of 0-1 to a scale of 2-1.
		// So at a scale of 1, sound plays normally, but as scale approaches 0 speed approaches double.
		const scaledPlaybackRate = initialPlaybackRate * (2 - scale);
		
		const gainNode = this.ctx.createGain();
		gainNode.gain.value = scaledVolume;

		const buffer = MyMath.randomChoice(source.buffers);
		const bufferSource = this.ctx.createBufferSource();
		bufferSource.playbackRate.value = scaledPlaybackRate;
		bufferSource.buffer = buffer;
		bufferSource.connect(gainNode);
		gainNode.connect(this.ctx.destination);
		bufferSource.start(0);
	}
};




// Kick things off.

function setLoadingStatus(status) {
	document.querySelector('.loading-init__status').textContent = status;
}

// CodePen profile header doesn't need audio, just initialize.
if (IS_HEADER) {
	init();
} else {
	// Allow status to render, then preload assets and start app.
	setLoadingStatus('Lighting Fuses');
	setTimeout(() => {
		soundManager.preload()
		.then(
			init,
			reason => {
				// Codepen preview doesn't like to load the audio, so just init to fix the preview for now.
				init();
				// setLoadingStatus('Error Loading Audio');
				return Promise.reject(reason);
			}
		);
	}, 0);
}

</script>
  
  <script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/fscreen%401.0.1.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/Stage%400.1.4.js'></script>
<script src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/329180/MyMath.js'></script>
  
  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>
   
   <!--HALLOWEEN-->
    <div id="result-iframe-wrap" role="main">

    <iframe data-visible-from="10-31" data-visible-to="10-31" style="z-index:0;position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />


  
  <title>CodePen - happy halloween</title>
  <link href=&quot;https://fonts.googleapis.com/css?family=Freckle+Face&quot; rel=&quot;stylesheet&quot;>
  <link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/normalize/5.0.0/normalize.min.css&quot;>

  
  
<style>
body, html {
  width: 100%;
  height: 100%;
  min-height: 700px;
  background: #041e2b;
  /* Old browsers */
  /* FF3.6-15 */
  /* Chrome10-25,Safari5.1-6 */
  background: linear-gradient(to bottom, #041e2b 0%, #407886 41%, #d4dbdb 69%, black 69%, black 100%);
  /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=&quot;#041e2b&quot;, endColorstr=&quot;#000000&quot;,GradientType=0 );
  /* IE6-9 */
  font-family: &quot;Freckle Face&quot;, cursive;
}

#foreground {
  height: 600px;
  position: absolute;
  margin-top: -200px;
  overflow-y: hidden;
}

h1 {
  position: absolute;
  top: 550px;
  width: 100%;
  text-align: center;
  font-size: 45px;
  color: orange;
  white-space: pre;
  margin-left: 20px;
}

span {
  letterspacing: 200px;
}

.moon {
  left: 25%;
  position: absolute;
  top: 100px;
}

.horseman {
  width: 184px;
  height: 123px;
  background: url(&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/horse-hallow5.svg&quot;);
  -webkit-animation: horsemove 0.7s steps(15) infinite;
          animation: horsemove 0.7s steps(15) infinite;
  position: absolute;
  left: 50%;
  margin-left: -100px;
  top: 300px;
}

.pumpkin {
  position: absolute;
  left: 50%;
  margin-left: -100px;
  top: 300px;
}

.ground {
  width: 151%;
  height: 697px;
  position: absolute;
  background-size: 800px 716px;
  left: 0;
  transform: translateZ(0);
  -webkit-backface-visibility: hidden;
          backface-visibility: hidden;
  perspective: 1000px;
}

.front {
  background: url(&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/hallowfront4.svg&quot;) repeat-x;
  background-size: 1000px 871px;
  top: -100px;
  -webkit-animation: bk 20s -5s linear infinite;
          animation: bk 20s -5s linear infinite;
}

.frontmid {
  background: url(&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/hallowmidfront2.svg&quot;) repeat-x;
  background-size: 1000px 871px;
  top: -100px;
  -webkit-animation: bk 50s -5s linear infinite;
          animation: bk 50s -5s linear infinite;
}

.mid {
  background: url(&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/hallowmid2.svg&quot;) repeat-x;
  background-size: 1000px 871px;
  top: -100px;
  -webkit-animation: bk 100s -5s linear infinite;
          animation: bk 100s -5s linear infinite;
}

.back {
  background: url(&quot;https://s3-us-west-2.amazonaws.com/s.cdpn.io/28963/hallowback2.svg&quot;) repeat-x;
  background-size: 1000px 871px;
  top: -100px;
  -webkit-animation: bk 100s -5s linear infinite;
          animation: bk 100s -5s linear infinite;
}

@-webkit-keyframes horsemove {
  100% {
    background-position: 0 -1848px;
  }
}

@keyframes horsemove {
  100% {
    background-position: 0 -1848px;
  }
}
@-webkit-keyframes bk {
  100% {
    background-position: -200% 0;
  }
}
@keyframes bk {
  100% {
    background-position: -200% 0;
  }
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <svg class=&quot;moon&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; viewBox=&quot;0 0 100 100&quot; width=&quot;100&quot; height=&quot;100&quot;>
  <circle r=&quot;30&quot; fill=&quot;#fff&quot; cx=&quot;70&quot; cy=&quot;70&quot; />
</svg>

<div class=&quot;back ground&quot;></div>
<div class=&quot;mid ground&quot;></div>
<div class=&quot;frontmid ground&quot;></div>
<div class=&quot;front ground&quot;></div>
<div class=&quot;horseman&quot;></div>

  <defs>
    <radialGradient id=&quot;radial-gradient&quot; cx=&quot;213.02&quot; cy=&quot;213.02&quot; r=&quot;213.02&quot; gradientUnits=&quot;userSpaceOnUse&quot;>
      <stop offset=&quot;0&quot; stop-color=&quot;#f69449&quot;/>
      <stop offset=&quot;0.7&quot; stop-color=&quot;#e99623&quot; stop-opacity=&quot;0.8&quot;/>
      <stop offset=&quot;1&quot; stop-color=&quot;#d7ba95&quot; stop-opacity=&quot;0&quot;/>
    </radialGradient>
  </defs>
  <title>pumpkin</title>
  <g id=&quot;pumpkin&quot;>
    <circle id=&quot;back-area&quot; cx=&quot;213&quot; cy=&quot;213&quot; r=&quot;213&quot; opacity=&quot;0.75&quot; fill=&quot;url(#radial-gradient)&quot;/>
    <path id=&quot;p-back&quot; d=&quot;M329.5,132.4c-29.4-27.7-58.5-32-74.9-31.6s-25.5,9.8-32.1,16.5c-1.9,1.9-6.7,3.4-12.8,4.6a31.3,31.3,0,0,1-2.8-3.7c-5.8-9.4-15.2-19.2-14.3-25.5s34.8-2.2,42.4-5.4,1.4-18.3,16.5-21.4,25.3-10.6,39.2-24.5S328.6.9,328.6.9,291.4,23.2,275,23.2s-28,8.9-36.1,15.2-19.6-.3-28.6,13.4-.6,19.5-12.5,22.7-8.4,6.7-28.9,2.7c-10.5-2.1-20.1,0-28.3,3.6-3.1-3.8-13.3-14.6-28.3-17.4C94,59.8,76.6,66,68.1,73.6S50.4,100.9,49,129.4s2.6,45,12,53.9S74.8,194,74.8,194l.6-1.6c-10.1,26.8-7.9,58.2-1.5,75.9C82.9,293.3,119,317,119,317s48.1,22.2,67.8,25.3c7,1.1,18.2,1.7,30.9,1.3l1.1.9v-.9c22.6-.7,49.6-4.2,65.6-12.3,25.3-12.8,68.2-50.9,73.1-74.5S358.8,160.1,329.5,132.4Zm-235,30.8a74.4,74.4,0,0,0-17.6,25.7l4.2-10.5S59.7,168.9,61,134.2s11.2-49,22.3-54.8,27.3-9.8,35.3-4,10.2,9.4,10.2,9.4l6.7-1.4a93.7,93.7,0,0,0-14.2,9.9C111,101.7,96.7,116.5,99.4,128s.9,15.5,9.4,17.3,29.4-12.8,31.2-16.4,3.6-31.7,3.6-31.7,11.2-3.6,18.3,1.8,8,15.7,4.5,24.1c-.6,1.4-1.3,2.9-2.1,4.3l-3.7.6C145.7,130.7,124.7,135.1,94.5,163.2ZM132.8,120c-4.5,7.6-7.5,10.6-11.5,10.6a9.5,9.5,0,0,1-6.3-2.1s-6.1-3.6,1.3-14.7,16.9-11.6,16.9-11.6S137.2,112.4,132.8,120Z&quot; fill=&quot;#010101&quot; fill-rule=&quot;evenodd&quot;/>
    <g id=&quot;face&quot;>
      <path d=&quot;M147.5,248.8s.4-36.7,6.3-44.6c0,0,20.4,28.1,41,29.5,0,0-19.5,10.7-31.6,15.2S147.5,248.8,147.5,248.8Z&quot; fill=&quot;#f8951d&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M233.1,259.1s4-37.1,6.7-40.2,34.7,23.2,29.8,26.8S233.1,259.1,233.1,259.1Z&quot; fill=&quot;#f8951d&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M295.1,215.8s.4-43.7-1.3-51.2c0,0,21.9,17.4,20.1,22.8S295.1,215.8,295.1,215.8Z&quot; fill=&quot;#f8951d&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M327.7,218.9c-5.4,11.2-4,22.3-7.6,24.1s-8.9-6.7-11.2,1.8-3.6,15.6-3.6,15.6-15.2-2.1-15.2,3.6-4,12.4-4,12.4-10.7-7.6-15.2-3.6-5.7,12.5-11.1,9.8-15.6.4-17.4,2.7-11.6,4-13.4-2.2-12.1,7.1-14.3,7.1-7.1-4-13.8-5.8-11.5,7.6-11.5,7.6l-8.5-17s-7.6,13.4-14.7,11.6S148,271,148,271s13.4,25.4,21.4,25.9,13.4,9.4,16.5,12.1,14.6-2.2,17.8-.4,6.7,14.7,13.4,11.2,6.7-11.2,17.9-6.3,20.2,12.5,23.7,3.6,22.2-10.7,26.2-12.1.9-10.7,11.6-14.7,13.4-12.2,17-18.8,17.9-13.7,15.6-21.8S327.7,218.9,327.7,218.9Z&quot; fill=&quot;#f8951d&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M327.7,218.9s-.9,22.8,1.3,30.8-12.1,15.2-15.6,21.8-6.3,14.7-17,18.8-7.6,13.4-11.6,14.7-22.8,3.1-26.2,12.1c-1.9,5-5.6,4.8-10.5,2.8-4.4,2.5-12-3.1-21-7.1-4.3.9-5.9,4.7-10.1,6.9-2.5,1.4-4.6.3-6.4-1.5l-1.4.9c-6,3.2-9.5-6.9-12.4-10.3-4.3.8-9.1,1.9-10.9.3,3.7-1,8.2-2.1,10-1.1,3.9,4.2,7.4,14.4,13.4,11.2l1.4-.9c5.2-3.6,6.1-9.5,15.4-5.8s17.6,10,22,7.5a6.5,6.5,0,0,0,2.7-3.5c3.5-8.9,22.2-10.7,26.2-12.1s.9-10.7,11.6-14.7,13.4-12.2,17-18.8,17.9-13.7,15.6-21.8a37.3,37.3,0,0,1-1-6.1c-2.1,1.1-4.6-1-6.8-1.7a3,3,0,0,1-1.2,1.1,3.1,3.1,0,0,1-2.4,0,2.7,2.7,0,0,1,3.6-1.2c2.2.7,4.7,2.8,6.6,1.8C323.6,240.9,322.4,229.9,327.7,218.9Z&quot; fill=&quot;#d9c98e&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M151.3,210.1a18.7,18.7,0,0,1,2.4-5.9s20.4,28.1,41,29.5c0,0-19.5,10.7-31.6,15.2-7.9,2.9-12.1,2-14.1,1.1a33.3,33.3,0,0,0,6.3-1.7c12.1-4.5,31.6-15.2,31.6-15.2C172.8,232,158.7,218.5,151.3,210.1Z&quot; fill=&quot;#d9c98e&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M233.1,259.1l.4-3.3c9.7-3.2,25-8.4,28.3-10.8s-12.9-17.7-22.9-24.1a6.3,6.3,0,0,1,.9-2c2.7-3.1,34.7,23.2,29.8,26.8S233.1,259.1,233.1,259.1Z&quot; fill=&quot;#d9c98e&quot; fill-rule=&quot;evenodd&quot;/>
      <path d=&quot;M295.1,215.8V204.1c4.7-6.7,10-14.6,10.9-17.5s-5.6-10-11.6-15.4a47.7,47.7,0,0,0-.7-6.7s21.9,17.4,20.1,22.8S295.1,215.8,295.1,215.8Z&quot; fill=&quot;#d9c98e&quot; fill-rule=&quot;evenodd&quot;/>
    </g>
  </g>
</svg>
    <script src=&quot;https://cpwebassets.codepen.io/assets/common/stopExecutionOnTimeout-2c7831bb44f98c1391d6a4ffda0e1fd302503391ca806e7fcc7b9b87197aec26.js&quot;></script>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/1.18.4/TweenMax.min.js'></script>
<script src='//s3-us-west-2.amazonaws.com/s.cdpn.io/16327/MorphSVGPlugin.min.js?r=18'></script>
<script src='//s3-us-west-2.amazonaws.com/s.cdpn.io/16327/findShapeIndex.js?r=19'></script>
      <script id=&quot;rendered-js&quot; >
function sceneOne() {
  var tl = new TimelineMax();

  tl.add(&quot;begin&quot;, &quot;+=1&quot;);
  tl.fromTo(&quot;.pumpkin&quot;, 2, {
    scale: 0,
    x: 0,
    y: 0,
    rotation: 180 },
  {
    scale: 1,
    bezier: {
      type: &quot;soft&quot;,
      values: [{
        x: 400,
        y: 175 },
      {
        x: 30,
        y: 250 }],

      autoRotate: false },

    rotation: 0,
    ease: Circ.easeInOut },
  &quot;begin+=1&quot;);
  tl.to(&quot;#face, #back-area&quot;, 1, {
    opacity: 0.5,
    yoyo: true,
    repeatDelay: 0.65,
    repeat: -1,
    ease: RoughEase.ease.config({ template: Power0.easeNone, strength: 1, points: 20, taper: &quot;none&quot;, randomize: true, clamp: false }) },
  &quot;begin+=3&quot;);
  tl.from(&quot;h1&quot;, 2, {
    opacity: 0,
    ease: RoughEase.ease.config({ template: Power0.easeNone, strength: 1, points: 20, taper: &quot;none&quot;, randomize: true, clamp: false }) },
  &quot;begin+=3&quot;);
  tl.from(&quot;h1&quot;, 1, {
    rotationX: 180,
    ease: Sine.easeOut },
  &quot;begin+=3&quot;);

  return tl;
}

//add it all to master timeline
var master = new TimelineMax();
master.add(sceneOne(), &quot;first&quot;);
//# sourceURL=pen.js
    </script>

  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>
   
   
   <!--SNOW-->
    <div id="result-iframe-wrap" role="main">

    <iframe data-visible-from="12-01" data-visible-to="12-31" style="z-index:0;position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />


  
  <title>CodePen - Snow (Pure CSS)</title>
  
  
  
  
<style>
body {
  height: 100vh;
  background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
  overflow: hidden;
  filter: drop-shadow(0 0 10px white);
}

.snow {
  position: absolute;
  width: 10px;
  height: 10px;
  background: white;
  border-radius: 50%;
}
.snow:nth-child(1) {
  opacity: 0.1961;
  transform: translate(64.074vw, -10px) scale(0.4663);
  animation: fall-1 20s -10s linear infinite;
}
@keyframes fall-1 {
  46.184% {
    transform: translate(74.0096vw, 46.184vh) scale(0.4663);
  }
  to {
    transform: translate(69.0418vw, 100vh) scale(0.4663);
  }
}
.snow:nth-child(2) {
  opacity: 0.0082;
  transform: translate(43.663vw, -10px) scale(0.0337);
  animation: fall-2 28s -14s linear infinite;
}
@keyframes fall-2 {
  54.415% {
    transform: translate(46.3479vw, 54.415vh) scale(0.0337);
  }
  to {
    transform: translate(45.00545vw, 100vh) scale(0.0337);
  }
}
.snow:nth-child(3) {
  opacity: 0.8018;
  transform: translate(74.1171vw, -10px) scale(0.947);
  animation: fall-3 30s -4s linear infinite;
}
@keyframes fall-3 {
  34.321% {
    transform: translate(75.0396vw, 34.321vh) scale(0.947);
  }
  to {
    transform: translate(74.57835vw, 100vh) scale(0.947);
  }
}
.snow:nth-child(4) {
  opacity: 0.7325;
  transform: translate(26.0663vw, -10px) scale(0.229);
  animation: fall-4 21s -16s linear infinite;
}
@keyframes fall-4 {
  42.675% {
    transform: translate(22.2729vw, 42.675vh) scale(0.229);
  }
  to {
    transform: translate(24.1696vw, 100vh) scale(0.229);
  }
}
.snow:nth-child(5) {
  opacity: 0.2173;
  transform: translate(5.1232vw, -10px) scale(0.3483);
  animation: fall-5 16s -19s linear infinite;
}
@keyframes fall-5 {
  44.887% {
    transform: translate(5.7619vw, 44.887vh) scale(0.3483);
  }
  to {
    transform: translate(5.44255vw, 100vh) scale(0.3483);
  }
}
.snow:nth-child(6) {
  opacity: 0.233;
  transform: translate(23.9565vw, -10px) scale(0.2573);
  animation: fall-6 15s -30s linear infinite;
}
@keyframes fall-6 {
  55.246% {
    transform: translate(20.4558vw, 55.246vh) scale(0.2573);
  }
  to {
    transform: translate(22.20615vw, 100vh) scale(0.2573);
  }
}
.snow:nth-child(7) {
  opacity: 0.4158;
  transform: translate(97.8016vw, -10px) scale(0.587);
  animation: fall-7 15s -28s linear infinite;
}
@keyframes fall-7 {
  38.099% {
    transform: translate(97.7584vw, 38.099vh) scale(0.587);
  }
  to {
    transform: translate(97.78vw, 100vh) scale(0.587);
  }
}
.snow:nth-child(8) {
  opacity: 0.4842;
  transform: translate(53.5112vw, -10px) scale(0.898);
  animation: fall-8 21s -20s linear infinite;
}
@keyframes fall-8 {
  72.848% {
    transform: translate(55.1436vw, 72.848vh) scale(0.898);
  }
  to {
    transform: translate(54.3274vw, 100vh) scale(0.898);
  }
}
.snow:nth-child(9) {
  opacity: 0.8439;
  transform: translate(90.4743vw, -10px) scale(0.5639);
  animation: fall-9 23s -30s linear infinite;
}
@keyframes fall-9 {
  57.212% {
    transform: translate(96.2798vw, 57.212vh) scale(0.5639);
  }
  to {
    transform: translate(93.37705vw, 100vh) scale(0.5639);
  }
}
.snow:nth-child(10) {
  opacity: 0.938;
  transform: translate(89.9574vw, -10px) scale(0.9444);
  animation: fall-10 27s -1s linear infinite;
}
@keyframes fall-10 {
  63.862% {
    transform: translate(95.4516vw, 63.862vh) scale(0.9444);
  }
  to {
    transform: translate(92.7045vw, 100vh) scale(0.9444);
  }
}
.snow:nth-child(11) {
  opacity: 0.3288;
  transform: translate(73.6746vw, -10px) scale(0.4633);
  animation: fall-11 23s -20s linear infinite;
}
@keyframes fall-11 {
  69.09% {
    transform: translate(78.6436vw, 69.09vh) scale(0.4633);
  }
  to {
    transform: translate(76.1591vw, 100vh) scale(0.4633);
  }
}
.snow:nth-child(12) {
  opacity: 0.8681;
  transform: translate(48.0157vw, -10px) scale(0.9543);
  animation: fall-12 28s -30s linear infinite;
}
@keyframes fall-12 {
  45.484% {
    transform: translate(50.1344vw, 45.484vh) scale(0.9543);
  }
  to {
    transform: translate(49.07505vw, 100vh) scale(0.9543);
  }
}
.snow:nth-child(13) {
  opacity: 0.3036;
  transform: translate(19.735vw, -10px) scale(0.3434);
  animation: fall-13 29s -21s linear infinite;
}
@keyframes fall-13 {
  39.616% {
    transform: translate(27.6739vw, 39.616vh) scale(0.3434);
  }
  to {
    transform: translate(23.70445vw, 100vh) scale(0.3434);
  }
}
.snow:nth-child(14) {
  opacity: 0.9868;
  transform: translate(18.1476vw, -10px) scale(0.266);
  animation: fall-14 27s -24s linear infinite;
}
@keyframes fall-14 {
  76.429% {
    transform: translate(27.1177vw, 76.429vh) scale(0.266);
  }
  to {
    transform: translate(22.63265vw, 100vh) scale(0.266);
  }
}
.snow:nth-child(15) {
  opacity: 0.2895;
  transform: translate(41.519vw, -10px) scale(0.3063);
  animation: fall-15 26s -11s linear infinite;
}
@keyframes fall-15 {
  54.902% {
    transform: translate(51.5125vw, 54.902vh) scale(0.3063);
  }
  to {
    transform: translate(46.51575vw, 100vh) scale(0.3063);
  }
}
.snow:nth-child(16) {
  opacity: 0.4759;
  transform: translate(6.2171vw, -10px) scale(0.9717);
  animation: fall-16 22s -25s linear infinite;
}
@keyframes fall-16 {
  47.457% {
    transform: translate(14.0238vw, 47.457vh) scale(0.9717);
  }
  to {
    transform: translate(10.12045vw, 100vh) scale(0.9717);
  }
}
.snow:nth-child(17) {
  opacity: 0.3865;
  transform: translate(10.9854vw, -10px) scale(0.9282);
  animation: fall-17 10s -13s linear infinite;
}
@keyframes fall-17 {
  61.083% {
    transform: translate(18.6998vw, 61.083vh) scale(0.9282);
  }
  to {
    transform: translate(14.8426vw, 100vh) scale(0.9282);
  }
}
.snow:nth-child(18) {
  opacity: 0.0675;
  transform: translate(85.68vw, -10px) scale(0.5736);
  animation: fall-18 22s -5s linear infinite;
}
@keyframes fall-18 {
  66.851% {
    transform: translate(82.0997vw, 66.851vh) scale(0.5736);
  }
  to {
    transform: translate(83.88985vw, 100vh) scale(0.5736);
  }
}
.snow:nth-child(19) {
  opacity: 0.6058;
  transform: translate(69.396vw, -10px) scale(0.7429);
  animation: fall-19 29s -26s linear infinite;
}
@keyframes fall-19 {
  35.913% {
    transform: translate(70.5713vw, 35.913vh) scale(0.7429);
  }
  to {
    transform: translate(69.98365vw, 100vh) scale(0.7429);
  }
}
.snow:nth-child(20) {
  opacity: 0.9526;
  transform: translate(55.1342vw, -10px) scale(0.7228);
  animation: fall-20 10s -28s linear infinite;
}
@keyframes fall-20 {
  51.582% {
    transform: translate(45.8781vw, 51.582vh) scale(0.7228);
  }
  to {
    transform: translate(50.50615vw, 100vh) scale(0.7228);
  }
}
.snow:nth-child(21) {
  opacity: 0.4638;
  transform: translate(30.941vw, -10px) scale(0.9322);
  animation: fall-21 26s -3s linear infinite;
}
@keyframes fall-21 {
  42.263% {
    transform: translate(23.7402vw, 42.263vh) scale(0.9322);
  }
  to {
    transform: translate(27.3406vw, 100vh) scale(0.9322);
  }
}
.snow:nth-child(22) {
  opacity: 0.2268;
  transform: translate(58.9899vw, -10px) scale(0.0576);
  animation: fall-22 12s -15s linear infinite;
}
@keyframes fall-22 {
  36.55% {
    transform: translate(59.4031vw, 36.55vh) scale(0.0576);
  }
  to {
    transform: translate(59.1965vw, 100vh) scale(0.0576);
  }
}
.snow:nth-child(23) {
  opacity: 0.0832;
  transform: translate(38.2955vw, -10px) scale(0.1897);
  animation: fall-23 28s -2s linear infinite;
}
@keyframes fall-23 {
  43.104% {
    transform: translate(42.5532vw, 43.104vh) scale(0.1897);
  }
  to {
    transform: translate(40.42435vw, 100vh) scale(0.1897);
  }
}
.snow:nth-child(24) {
  opacity: 0.4011;
  transform: translate(96.8779vw, -10px) scale(0.6739);
  animation: fall-24 10s -3s linear infinite;
}
@keyframes fall-24 {
  46.934% {
    transform: translate(92.9838vw, 46.934vh) scale(0.6739);
  }
  to {
    transform: translate(94.93085vw, 100vh) scale(0.6739);
  }
}
.snow:nth-child(25) {
  opacity: 0.2619;
  transform: translate(65.3623vw, -10px) scale(0.1834);
  animation: fall-25 29s -8s linear infinite;
}
@keyframes fall-25 {
  71.871% {
    transform: translate(60.63vw, 71.871vh) scale(0.1834);
  }
  to {
    transform: translate(62.99615vw, 100vh) scale(0.1834);
  }
}
.snow:nth-child(26) {
  opacity: 0.6774;
  transform: translate(43.0692vw, -10px) scale(0.7581);
  animation: fall-26 23s -18s linear infinite;
}
@keyframes fall-26 {
  56.272% {
    transform: translate(42.2105vw, 56.272vh) scale(0.7581);
  }
  to {
    transform: translate(42.63985vw, 100vh) scale(0.7581);
  }
}
.snow:nth-child(27) {
  opacity: 0.9484;
  transform: translate(55.6828vw, -10px) scale(0.5719);
  animation: fall-27 21s -9s linear infinite;
}
@keyframes fall-27 {
  68.489% {
    transform: translate(63.3738vw, 68.489vh) scale(0.5719);
  }
  to {
    transform: translate(59.5283vw, 100vh) scale(0.5719);
  }
}
.snow:nth-child(28) {
  opacity: 0.405;
  transform: translate(46.1103vw, -10px) scale(0.7499);
  animation: fall-28 13s -2s linear infinite;
}
@keyframes fall-28 {
  46.969% {
    transform: translate(48.7921vw, 46.969vh) scale(0.7499);
  }
  to {
    transform: translate(47.4512vw, 100vh) scale(0.7499);
  }
}
.snow:nth-child(29) {
  opacity: 0.7614;
  transform: translate(84.7473vw, -10px) scale(0.2441);
  animation: fall-29 12s -4s linear infinite;
}
@keyframes fall-29 {
  79.802% {
    transform: translate(92.7152vw, 79.802vh) scale(0.2441);
  }
  to {
    transform: translate(88.73125vw, 100vh) scale(0.2441);
  }
}
.snow:nth-child(30) {
  opacity: 0.5821;
  transform: translate(79.9227vw, -10px) scale(0.4544);
  animation: fall-30 21s -9s linear infinite;
}
@keyframes fall-30 {
  61.151% {
    transform: translate(80.0635vw, 61.151vh) scale(0.4544);
  }
  to {
    transform: translate(79.9931vw, 100vh) scale(0.4544);
  }
}
.snow:nth-child(31) {
  opacity: 0.0975;
  transform: translate(77.1944vw, -10px) scale(0.1318);
  animation: fall-31 16s -14s linear infinite;
}
@keyframes fall-31 {
  44.01% {
    transform: translate(68.694vw, 44.01vh) scale(0.1318);
  }
  to {
    transform: translate(72.9442vw, 100vh) scale(0.1318);
  }
}
.snow:nth-child(32) {
  opacity: 0.9952;
  transform: translate(75.5224vw, -10px) scale(0.863);
  animation: fall-32 25s -9s linear infinite;
}
@keyframes fall-32 {
  63.659% {
    transform: translate(74.8464vw, 63.659vh) scale(0.863);
  }
  to {
    transform: translate(75.1844vw, 100vh) scale(0.863);
  }
}
.snow:nth-child(33) {
  opacity: 0.1064;
  transform: translate(54.4613vw, -10px) scale(0.7582);
  animation: fall-33 24s -2s linear infinite;
}
@keyframes fall-33 {
  62.855% {
    transform: translate(52.5464vw, 62.855vh) scale(0.7582);
  }
  to {
    transform: translate(53.50385vw, 100vh) scale(0.7582);
  }
}
.snow:nth-child(34) {
  opacity: 0.0564;
  transform: translate(20.1956vw, -10px) scale(0.9841);
  animation: fall-34 11s -23s linear infinite;
}
@keyframes fall-34 {
  51.624% {
    transform: translate(21.9795vw, 51.624vh) scale(0.9841);
  }
  to {
    transform: translate(21.08755vw, 100vh) scale(0.9841);
  }
}
.snow:nth-child(35) {
  opacity: 0.6962;
  transform: translate(13.7834vw, -10px) scale(0.4971);
  animation: fall-35 18s -8s linear infinite;
}
@keyframes fall-35 {
  61.769% {
    transform: translate(11.7238vw, 61.769vh) scale(0.4971);
  }
  to {
    transform: translate(12.7536vw, 100vh) scale(0.4971);
  }
}
.snow:nth-child(36) {
  opacity: 0.3317;
  transform: translate(10.5166vw, -10px) scale(0.3895);
  animation: fall-36 14s -9s linear infinite;
}
@keyframes fall-36 {
  77.137% {
    transform: translate(16.9955vw, 77.137vh) scale(0.3895);
  }
  to {
    transform: translate(13.75605vw, 100vh) scale(0.3895);
  }
}
.snow:nth-child(37) {
  opacity: 0.3416;
  transform: translate(74.9615vw, -10px) scale(0.8275);
  animation: fall-37 24s -14s linear infinite;
}
@keyframes fall-37 {
  36.062% {
    transform: translate(69.6792vw, 36.062vh) scale(0.8275);
  }
  to {
    transform: translate(72.32035vw, 100vh) scale(0.8275);
  }
}
.snow:nth-child(38) {
  opacity: 0.6823;
  transform: translate(54.9982vw, -10px) scale(0.4081);
  animation: fall-38 21s -18s linear infinite;
}
@keyframes fall-38 {
  49.962% {
    transform: translate(62.338vw, 49.962vh) scale(0.4081);
  }
  to {
    transform: translate(58.6681vw, 100vh) scale(0.4081);
  }
}
.snow:nth-child(39) {
  opacity: 0.5995;
  transform: translate(92.2358vw, -10px) scale(0.5543);
  animation: fall-39 22s -18s linear infinite;
}
@keyframes fall-39 {
  45.638% {
    transform: translate(88.1685vw, 45.638vh) scale(0.5543);
  }
  to {
    transform: translate(90.20215vw, 100vh) scale(0.5543);
  }
}
.snow:nth-child(40) {
  opacity: 0.6675;
  transform: translate(89.4293vw, -10px) scale(0.2321);
  animation: fall-40 29s -24s linear infinite;
}
@keyframes fall-40 {
  76.055% {
    transform: translate(84.7094vw, 76.055vh) scale(0.2321);
  }
  to {
    transform: translate(87.06935vw, 100vh) scale(0.2321);
  }
}
.snow:nth-child(41) {
  opacity: 0.1493;
  transform: translate(83.3762vw, -10px) scale(0.3298);
  animation: fall-41 20s -26s linear infinite;
}
@keyframes fall-41 {
  53.401% {
    transform: translate(79.5516vw, 53.401vh) scale(0.3298);
  }
  to {
    transform: translate(81.4639vw, 100vh) scale(0.3298);
  }
}
.snow:nth-child(42) {
  opacity: 0.4016;
  transform: translate(55.8533vw, -10px) scale(0.9556);
  animation: fall-42 16s -4s linear infinite;
}
@keyframes fall-42 {
  70.466% {
    transform: translate(51.0471vw, 70.466vh) scale(0.9556);
  }
  to {
    transform: translate(53.4502vw, 100vh) scale(0.9556);
  }
}
.snow:nth-child(43) {
  opacity: 0.5515;
  transform: translate(17.1466vw, -10px) scale(0.0168);
  animation: fall-43 20s -29s linear infinite;
}
@keyframes fall-43 {
  50.055% {
    transform: translate(10.4295vw, 50.055vh) scale(0.0168);
  }
  to {
    transform: translate(13.78805vw, 100vh) scale(0.0168);
  }
}
.snow:nth-child(44) {
  opacity: 0.9746;
  transform: translate(46.7186vw, -10px) scale(0.1583);
  animation: fall-44 16s -27s linear infinite;
}
@keyframes fall-44 {
  77.975% {
    transform: translate(42.7119vw, 77.975vh) scale(0.1583);
  }
  to {
    transform: translate(44.71525vw, 100vh) scale(0.1583);
  }
}
.snow:nth-child(45) {
  opacity: 0.3401;
  transform: translate(30.8969vw, -10px) scale(0.1372);
  animation: fall-45 27s -21s linear infinite;
}
@keyframes fall-45 {
  60.873% {
    transform: translate(23.8148vw, 60.873vh) scale(0.1372);
  }
  to {
    transform: translate(27.35585vw, 100vh) scale(0.1372);
  }
}
.snow:nth-child(46) {
  opacity: 0.0089;
  transform: translate(18.7242vw, -10px) scale(0.6999);
  animation: fall-46 22s -26s linear infinite;
}
@keyframes fall-46 {
  52.722% {
    transform: translate(27.715vw, 52.722vh) scale(0.6999);
  }
  to {
    transform: translate(23.2196vw, 100vh) scale(0.6999);
  }
}
.snow:nth-child(47) {
  opacity: 0.7288;
  transform: translate(15.7824vw, -10px) scale(0.8293);
  animation: fall-47 20s -5s linear infinite;
}
@keyframes fall-47 {
  51.574% {
    transform: translate(17.1745vw, 51.574vh) scale(0.8293);
  }
  to {
    transform: translate(16.47845vw, 100vh) scale(0.8293);
  }
}
.snow:nth-child(48) {
  opacity: 0.5697;
  transform: translate(28.4392vw, -10px) scale(0.6193);
  animation: fall-48 14s -22s linear infinite;
}
@keyframes fall-48 {
  59.254% {
    transform: translate(24.5657vw, 59.254vh) scale(0.6193);
  }
  to {
    transform: translate(26.50245vw, 100vh) scale(0.6193);
  }
}
.snow:nth-child(49) {
  opacity: 0.5133;
  transform: translate(27.9844vw, -10px) scale(0.9771);
  animation: fall-49 13s -2s linear infinite;
}
@keyframes fall-49 {
  38.638% {
    transform: translate(27.3295vw, 38.638vh) scale(0.9771);
  }
  to {
    transform: translate(27.65695vw, 100vh) scale(0.9771);
  }
}
.snow:nth-child(50) {
  opacity: 0.1925;
  transform: translate(11.0924vw, -10px) scale(0.69);
  animation: fall-50 30s -28s linear infinite;
}
@keyframes fall-50 {
  61.126% {
    transform: translate(16.8452vw, 61.126vh) scale(0.69);
  }
  to {
    transform: translate(13.9688vw, 100vh) scale(0.69);
  }
}
.snow:nth-child(51) {
  opacity: 0.7895;
  transform: translate(13.9778vw, -10px) scale(0.6754);
  animation: fall-51 23s -23s linear infinite;
}
@keyframes fall-51 {
  48.58% {
    transform: translate(8.1153vw, 48.58vh) scale(0.6754);
  }
  to {
    transform: translate(11.04655vw, 100vh) scale(0.6754);
  }
}
.snow:nth-child(52) {
  opacity: 0.866;
  transform: translate(78.1534vw, -10px) scale(0.1095);
  animation: fall-52 25s -28s linear infinite;
}
@keyframes fall-52 {
  53.398% {
    transform: translate(75.9074vw, 53.398vh) scale(0.1095);
  }
  to {
    transform: translate(77.0304vw, 100vh) scale(0.1095);
  }
}
.snow:nth-child(53) {
  opacity: 0.4538;
  transform: translate(47.3581vw, -10px) scale(0.0435);
  animation: fall-53 15s -18s linear infinite;
}
@keyframes fall-53 {
  65.056% {
    transform: translate(41.0446vw, 65.056vh) scale(0.0435);
  }
  to {
    transform: translate(44.20135vw, 100vh) scale(0.0435);
  }
}
.snow:nth-child(54) {
  opacity: 0.1159;
  transform: translate(67.196vw, -10px) scale(0.9236);
  animation: fall-54 19s -10s linear infinite;
}
@keyframes fall-54 {
  46.429% {
    transform: translate(76.6865vw, 46.429vh) scale(0.9236);
  }
  to {
    transform: translate(71.94125vw, 100vh) scale(0.9236);
  }
}
.snow:nth-child(55) {
  opacity: 0.6079;
  transform: translate(44.3684vw, -10px) scale(0.6554);
  animation: fall-55 11s -23s linear infinite;
}
@keyframes fall-55 {
  31.675% {
    transform: translate(47.4749vw, 31.675vh) scale(0.6554);
  }
  to {
    transform: translate(45.92165vw, 100vh) scale(0.6554);
  }
}
.snow:nth-child(56) {
  opacity: 0.1707;
  transform: translate(85.626vw, -10px) scale(0.3616);
  animation: fall-56 17s -22s linear infinite;
}
@keyframes fall-56 {
  63.239% {
    transform: translate(78.3609vw, 63.239vh) scale(0.3616);
  }
  to {
    transform: translate(81.99345vw, 100vh) scale(0.3616);
  }
}
.snow:nth-child(57) {
  opacity: 0.4105;
  transform: translate(11.2284vw, -10px) scale(0.0998);
  animation: fall-57 26s -13s linear infinite;
}
@keyframes fall-57 {
  39.485% {
    transform: translate(5.4755vw, 39.485vh) scale(0.0998);
  }
  to {
    transform: translate(8.35195vw, 100vh) scale(0.0998);
  }
}
.snow:nth-child(58) {
  opacity: 0.5717;
  transform: translate(98.5572vw, -10px) scale(0.3406);
  animation: fall-58 13s -4s linear infinite;
}
@keyframes fall-58 {
  38.065% {
    transform: translate(99.1145vw, 38.065vh) scale(0.3406);
  }
  to {
    transform: translate(98.83585vw, 100vh) scale(0.3406);
  }
}
.snow:nth-child(59) {
  opacity: 0.2231;
  transform: translate(19.7425vw, -10px) scale(0.1735);
  animation: fall-59 24s -3s linear infinite;
}
@keyframes fall-59 {
  32.229% {
    transform: translate(15.0116vw, 32.229vh) scale(0.1735);
  }
  to {
    transform: translate(17.37705vw, 100vh) scale(0.1735);
  }
}
.snow:nth-child(60) {
  opacity: 0.3941;
  transform: translate(38.7227vw, -10px) scale(0.8088);
  animation: fall-60 23s -23s linear infinite;
}
@keyframes fall-60 {
  77.033% {
    transform: translate(46.3669vw, 77.033vh) scale(0.8088);
  }
  to {
    transform: translate(42.5448vw, 100vh) scale(0.8088);
  }
}
.snow:nth-child(61) {
  opacity: 0.2528;
  transform: translate(67.6864vw, -10px) scale(0.6017);
  animation: fall-61 28s -4s linear infinite;
}
@keyframes fall-61 {
  71.635% {
    transform: translate(69.9041vw, 71.635vh) scale(0.6017);
  }
  to {
    transform: translate(68.79525vw, 100vh) scale(0.6017);
  }
}
.snow:nth-child(62) {
  opacity: 0.9596;
  transform: translate(90.4124vw, -10px) scale(0.6716);
  animation: fall-62 27s -3s linear infinite;
}
@keyframes fall-62 {
  54.832% {
    transform: translate(80.5033vw, 54.832vh) scale(0.6716);
  }
  to {
    transform: translate(85.45785vw, 100vh) scale(0.6716);
  }
}
.snow:nth-child(63) {
  opacity: 0.1271;
  transform: translate(40.1752vw, -10px) scale(0.234);
  animation: fall-63 29s -18s linear infinite;
}
@keyframes fall-63 {
  38.827% {
    transform: translate(45.7478vw, 38.827vh) scale(0.234);
  }
  to {
    transform: translate(42.9615vw, 100vh) scale(0.234);
  }
}
.snow:nth-child(64) {
  opacity: 0.0194;
  transform: translate(63.9309vw, -10px) scale(0.1834);
  animation: fall-64 25s -26s linear infinite;
}
@keyframes fall-64 {
  30.423% {
    transform: translate(71.7497vw, 30.423vh) scale(0.1834);
  }
  to {
    transform: translate(67.8403vw, 100vh) scale(0.1834);
  }
}
.snow:nth-child(65) {
  opacity: 0.1536;
  transform: translate(17.9617vw, -10px) scale(0.5528);
  animation: fall-65 26s -8s linear infinite;
}
@keyframes fall-65 {
  78.259% {
    transform: translate(21.6869vw, 78.259vh) scale(0.5528);
  }
  to {
    transform: translate(19.8243vw, 100vh) scale(0.5528);
  }
}
.snow:nth-child(66) {
  opacity: 0.9945;
  transform: translate(71.2858vw, -10px) scale(0.8928);
  animation: fall-66 13s -15s linear infinite;
}
@keyframes fall-66 {
  34.057% {
    transform: translate(62.6389vw, 34.057vh) scale(0.8928);
  }
  to {
    transform: translate(66.96235vw, 100vh) scale(0.8928);
  }
}
.snow:nth-child(67) {
  opacity: 0.3515;
  transform: translate(78.1097vw, -10px) scale(0.5099);
  animation: fall-67 23s -3s linear infinite;
}
@keyframes fall-67 {
  78.711% {
    transform: translate(83.0444vw, 78.711vh) scale(0.5099);
  }
  to {
    transform: translate(80.57705vw, 100vh) scale(0.5099);
  }
}
.snow:nth-child(68) {
  opacity: 0.4069;
  transform: translate(69.5567vw, -10px) scale(0.7714);
  animation: fall-68 10s -1s linear infinite;
}
@keyframes fall-68 {
  52.209% {
    transform: translate(73.2887vw, 52.209vh) scale(0.7714);
  }
  to {
    transform: translate(71.4227vw, 100vh) scale(0.7714);
  }
}
.snow:nth-child(69) {
  opacity: 0.3723;
  transform: translate(10.8268vw, -10px) scale(0.9961);
  animation: fall-69 13s -12s linear infinite;
}
@keyframes fall-69 {
  48.122% {
    transform: translate(17.9033vw, 48.122vh) scale(0.9961);
  }
  to {
    transform: translate(14.36505vw, 100vh) scale(0.9961);
  }
}
.snow:nth-child(70) {
  opacity: 0.9177;
  transform: translate(91.4533vw, -10px) scale(0.3594);
  animation: fall-70 18s -22s linear infinite;
}
@keyframes fall-70 {
  36.267% {
    transform: translate(89.7065vw, 36.267vh) scale(0.3594);
  }
  to {
    transform: translate(90.5799vw, 100vh) scale(0.3594);
  }
}
.snow:nth-child(71) {
  opacity: 0.7021;
  transform: translate(46.2608vw, -10px) scale(0.577);
  animation: fall-71 27s -17s linear infinite;
}
@keyframes fall-71 {
  43.659% {
    transform: translate(40.3552vw, 43.659vh) scale(0.577);
  }
  to {
    transform: translate(43.308vw, 100vh) scale(0.577);
  }
}
.snow:nth-child(72) {
  opacity: 0.2923;
  transform: translate(51.4381vw, -10px) scale(0.2215);
  animation: fall-72 30s -26s linear infinite;
}
@keyframes fall-72 {
  60.878% {
    transform: translate(55.9609vw, 60.878vh) scale(0.2215);
  }
  to {
    transform: translate(53.6995vw, 100vh) scale(0.2215);
  }
}
.snow:nth-child(73) {
  opacity: 0.4355;
  transform: translate(56.609vw, -10px) scale(0.2103);
  animation: fall-73 15s -19s linear infinite;
}
@keyframes fall-73 {
  50.781% {
    transform: translate(51.0117vw, 50.781vh) scale(0.2103);
  }
  to {
    transform: translate(53.81035vw, 100vh) scale(0.2103);
  }
}
.snow:nth-child(74) {
  opacity: 0.6638;
  transform: translate(63.5361vw, -10px) scale(0.2331);
  animation: fall-74 24s -14s linear infinite;
}
@keyframes fall-74 {
  76.526% {
    transform: translate(57.5562vw, 76.526vh) scale(0.2331);
  }
  to {
    transform: translate(60.54615vw, 100vh) scale(0.2331);
  }
}
.snow:nth-child(75) {
  opacity: 0.1765;
  transform: translate(70.4475vw, -10px) scale(0.963);
  animation: fall-75 26s -22s linear infinite;
}
@keyframes fall-75 {
  57.111% {
    transform: translate(80.3454vw, 57.111vh) scale(0.963);
  }
  to {
    transform: translate(75.39645vw, 100vh) scale(0.963);
  }
}
.snow:nth-child(76) {
  opacity: 0.5649;
  transform: translate(23.7723vw, -10px) scale(0.6654);
  animation: fall-76 23s -24s linear infinite;
}
@keyframes fall-76 {
  54.52% {
    transform: translate(23.8554vw, 54.52vh) scale(0.6654);
  }
  to {
    transform: translate(23.81385vw, 100vh) scale(0.6654);
  }
}
.snow:nth-child(77) {
  opacity: 0.2661;
  transform: translate(37.6757vw, -10px) scale(0.1164);
  animation: fall-77 28s -16s linear infinite;
}
@keyframes fall-77 {
  33.422% {
    transform: translate(37.1225vw, 33.422vh) scale(0.1164);
  }
  to {
    transform: translate(37.3991vw, 100vh) scale(0.1164);
  }
}
.snow:nth-child(78) {
  opacity: 0.4803;
  transform: translate(3.2511vw, -10px) scale(0.3649);
  animation: fall-78 28s -24s linear infinite;
}
@keyframes fall-78 {
  53.858% {
    transform: translate(-0.4882vw, 53.858vh) scale(0.3649);
  }
  to {
    transform: translate(1.38145vw, 100vh) scale(0.3649);
  }
}
.snow:nth-child(79) {
  opacity: 0.8816;
  transform: translate(10.9097vw, -10px) scale(0.9798);
  animation: fall-79 10s -2s linear infinite;
}
@keyframes fall-79 {
  79.509% {
    transform: translate(9.4677vw, 79.509vh) scale(0.9798);
  }
  to {
    transform: translate(10.1887vw, 100vh) scale(0.9798);
  }
}
.snow:nth-child(80) {
  opacity: 0.7751;
  transform: translate(12.3577vw, -10px) scale(0.9786);
  animation: fall-80 18s -5s linear infinite;
}
@keyframes fall-80 {
  59.299% {
    transform: translate(11.5519vw, 59.299vh) scale(0.9786);
  }
  to {
    transform: translate(11.9548vw, 100vh) scale(0.9786);
  }
}
.snow:nth-child(81) {
  opacity: 0.9113;
  transform: translate(81.381vw, -10px) scale(0.9859);
  animation: fall-81 20s -5s linear infinite;
}
@keyframes fall-81 {
  70.382% {
    transform: translate(76.1347vw, 70.382vh) scale(0.9859);
  }
  to {
    transform: translate(78.75785vw, 100vh) scale(0.9859);
  }
}
.snow:nth-child(82) {
  opacity: 0.1192;
  transform: translate(74.7112vw, -10px) scale(0.443);
  animation: fall-82 18s -3s linear infinite;
}
@keyframes fall-82 {
  52.612% {
    transform: translate(72.557vw, 52.612vh) scale(0.443);
  }
  to {
    transform: translate(73.6341vw, 100vh) scale(0.443);
  }
}
.snow:nth-child(83) {
  opacity: 0.96;
  transform: translate(53.7027vw, -10px) scale(0.6792);
  animation: fall-83 16s -3s linear infinite;
}
@keyframes fall-83 {
  32.23% {
    transform: translate(58.2545vw, 32.23vh) scale(0.6792);
  }
  to {
    transform: translate(55.9786vw, 100vh) scale(0.6792);
  }
}
.snow:nth-child(84) {
  opacity: 0.8797;
  transform: translate(5.2182vw, -10px) scale(0.7734);
  animation: fall-84 29s -27s linear infinite;
}
@keyframes fall-84 {
  33.729% {
    transform: translate(-4.5899vw, 33.729vh) scale(0.7734);
  }
  to {
    transform: translate(0.31415vw, 100vh) scale(0.7734);
  }
}
.snow:nth-child(85) {
  opacity: 0.8068;
  transform: translate(40.6515vw, -10px) scale(0.4306);
  animation: fall-85 18s -26s linear infinite;
}
@keyframes fall-85 {
  69.969% {
    transform: translate(43.6091vw, 69.969vh) scale(0.4306);
  }
  to {
    transform: translate(42.1303vw, 100vh) scale(0.4306);
  }
}
.snow:nth-child(86) {
  opacity: 0.5511;
  transform: translate(72.0087vw, -10px) scale(0.2934);
  animation: fall-86 11s -2s linear infinite;
}
@keyframes fall-86 {
  56.246% {
    transform: translate(76.8057vw, 56.246vh) scale(0.2934);
  }
  to {
    transform: translate(74.4072vw, 100vh) scale(0.2934);
  }
}
.snow:nth-child(87) {
  opacity: 0.3251;
  transform: translate(43.4206vw, -10px) scale(0.9109);
  animation: fall-87 23s -22s linear infinite;
}
@keyframes fall-87 {
  38.274% {
    transform: translate(47.739vw, 38.274vh) scale(0.9109);
  }
  to {
    transform: translate(45.5798vw, 100vh) scale(0.9109);
  }
}
.snow:nth-child(88) {
  opacity: 0.7872;
  transform: translate(85.1422vw, -10px) scale(0.489);
  animation: fall-88 11s -1s linear infinite;
}
@keyframes fall-88 {
  53.24% {
    transform: translate(94.7075vw, 53.24vh) scale(0.489);
  }
  to {
    transform: translate(89.92485vw, 100vh) scale(0.489);
  }
}
.snow:nth-child(89) {
  opacity: 0.0988;
  transform: translate(93.9463vw, -10px) scale(0.9706);
  animation: fall-89 12s -4s linear infinite;
}
@keyframes fall-89 {
  60.799% {
    transform: translate(101.4834vw, 60.799vh) scale(0.9706);
  }
  to {
    transform: translate(97.71485vw, 100vh) scale(0.9706);
  }
}
.snow:nth-child(90) {
  opacity: 0.9721;
  transform: translate(67.285vw, -10px) scale(0.5104);
  animation: fall-90 26s -7s linear infinite;
}
@keyframes fall-90 {
  33.44% {
    transform: translate(74.109vw, 33.44vh) scale(0.5104);
  }
  to {
    transform: translate(70.697vw, 100vh) scale(0.5104);
  }
}
.snow:nth-child(91) {
  opacity: 0.8084;
  transform: translate(85.3944vw, -10px) scale(0.5789);
  animation: fall-91 12s -4s linear infinite;
}
@keyframes fall-91 {
  68.232% {
    transform: translate(77.5671vw, 68.232vh) scale(0.5789);
  }
  to {
    transform: translate(81.48075vw, 100vh) scale(0.5789);
  }
}
.snow:nth-child(92) {
  opacity: 0.8919;
  transform: translate(27.7857vw, -10px) scale(0.0407);
  animation: fall-92 25s -16s linear infinite;
}
@keyframes fall-92 {
  44.925% {
    transform: translate(23.107vw, 44.925vh) scale(0.0407);
  }
  to {
    transform: translate(25.44635vw, 100vh) scale(0.0407);
  }
}
.snow:nth-child(93) {
  opacity: 0.2547;
  transform: translate(75.1511vw, -10px) scale(0.7099);
  animation: fall-93 22s -7s linear infinite;
}
@keyframes fall-93 {
  75.698% {
    transform: translate(84.9825vw, 75.698vh) scale(0.7099);
  }
  to {
    transform: translate(80.0668vw, 100vh) scale(0.7099);
  }
}
.snow:nth-child(94) {
  opacity: 0.5013;
  transform: translate(56.5892vw, -10px) scale(0.4367);
  animation: fall-94 13s -17s linear infinite;
}
@keyframes fall-94 {
  47.442% {
    transform: translate(52.6697vw, 47.442vh) scale(0.4367);
  }
  to {
    transform: translate(54.62945vw, 100vh) scale(0.4367);
  }
}
.snow:nth-child(95) {
  opacity: 0.2694;
  transform: translate(21.7358vw, -10px) scale(0.5511);
  animation: fall-95 27s -5s linear infinite;
}
@keyframes fall-95 {
  51.689% {
    transform: translate(17.8754vw, 51.689vh) scale(0.5511);
  }
  to {
    transform: translate(19.8056vw, 100vh) scale(0.5511);
  }
}
.snow:nth-child(96) {
  opacity: 0.2219;
  transform: translate(9.9929vw, -10px) scale(0.2535);
  animation: fall-96 19s -14s linear infinite;
}
@keyframes fall-96 {
  38.049% {
    transform: translate(16.2593vw, 38.049vh) scale(0.2535);
  }
  to {
    transform: translate(13.1261vw, 100vh) scale(0.2535);
  }
}
.snow:nth-child(97) {
  opacity: 0.61;
  transform: translate(35.0386vw, -10px) scale(0.312);
  animation: fall-97 13s -30s linear infinite;
}
@keyframes fall-97 {
  45.249% {
    transform: translate(32.3324vw, 45.249vh) scale(0.312);
  }
  to {
    transform: translate(33.6855vw, 100vh) scale(0.312);
  }
}
.snow:nth-child(98) {
  opacity: 0.9911;
  transform: translate(47.2031vw, -10px) scale(0.5554);
  animation: fall-98 10s -29s linear infinite;
}
@keyframes fall-98 {
  79.384% {
    transform: translate(43.5502vw, 79.384vh) scale(0.5554);
  }
  to {
    transform: translate(45.37665vw, 100vh) scale(0.5554);
  }
}
.snow:nth-child(99) {
  opacity: 0.3926;
  transform: translate(83.4286vw, -10px) scale(0.9932);
  animation: fall-99 19s -5s linear infinite;
}
@keyframes fall-99 {
  35.098% {
    transform: translate(89.5015vw, 35.098vh) scale(0.9932);
  }
  to {
    transform: translate(86.46505vw, 100vh) scale(0.9932);
  }
}
.snow:nth-child(100) {
  opacity: 0.9546;
  transform: translate(60.7224vw, -10px) scale(0.5672);
  animation: fall-100 19s -17s linear infinite;
}
@keyframes fall-100 {
  78.736% {
    transform: translate(68.3055vw, 78.736vh) scale(0.5672);
  }
  to {
    transform: translate(64.51395vw, 100vh) scale(0.5672);
  }
}
.snow:nth-child(101) {
  opacity: 0.8546;
  transform: translate(1.7351vw, -10px) scale(0.6464);
  animation: fall-101 30s -29s linear infinite;
}
@keyframes fall-101 {
  31.013% {
    transform: translate(-6.0421vw, 31.013vh) scale(0.6464);
  }
  to {
    transform: translate(-2.1535vw, 100vh) scale(0.6464);
  }
}
.snow:nth-child(102) {
  opacity: 0.6651;
  transform: translate(7.7469vw, -10px) scale(0.7301);
  animation: fall-102 16s -29s linear infinite;
}
@keyframes fall-102 {
  78.839% {
    transform: translate(9.0004vw, 78.839vh) scale(0.7301);
  }
  to {
    transform: translate(8.37365vw, 100vh) scale(0.7301);
  }
}
.snow:nth-child(103) {
  opacity: 0.2646;
  transform: translate(63.5629vw, -10px) scale(0.5027);
  animation: fall-103 30s -18s linear infinite;
}
@keyframes fall-103 {
  30.336% {
    transform: translate(53.8112vw, 30.336vh) scale(0.5027);
  }
  to {
    transform: translate(58.68705vw, 100vh) scale(0.5027);
  }
}
.snow:nth-child(104) {
  opacity: 0.9642;
  transform: translate(65.1681vw, -10px) scale(0.5006);
  animation: fall-104 22s -9s linear infinite;
}
@keyframes fall-104 {
  58.015% {
    transform: translate(65.8129vw, 58.015vh) scale(0.5006);
  }
  to {
    transform: translate(65.4905vw, 100vh) scale(0.5006);
  }
}
.snow:nth-child(105) {
  opacity: 0.443;
  transform: translate(15.9081vw, -10px) scale(0.0777);
  animation: fall-105 19s -18s linear infinite;
}
@keyframes fall-105 {
  46.028% {
    transform: translate(8.9432vw, 46.028vh) scale(0.0777);
  }
  to {
    transform: translate(12.42565vw, 100vh) scale(0.0777);
  }
}
.snow:nth-child(106) {
  opacity: 0.0057;
  transform: translate(9.4795vw, -10px) scale(0.9502);
  animation: fall-106 23s -7s linear infinite;
}
@keyframes fall-106 {
  50.351% {
    transform: translate(9.6023vw, 50.351vh) scale(0.9502);
  }
  to {
    transform: translate(9.5409vw, 100vh) scale(0.9502);
  }
}
.snow:nth-child(107) {
  opacity: 0.1969;
  transform: translate(25.7219vw, -10px) scale(0.6037);
  animation: fall-107 13s -27s linear infinite;
}
@keyframes fall-107 {
  56.048% {
    transform: translate(19.2732vw, 56.048vh) scale(0.6037);
  }
  to {
    transform: translate(22.49755vw, 100vh) scale(0.6037);
  }
}
.snow:nth-child(108) {
  opacity: 0.3417;
  transform: translate(78.8432vw, -10px) scale(0.376);
  animation: fall-108 28s -18s linear infinite;
}
@keyframes fall-108 {
  59.894% {
    transform: translate(69.3863vw, 59.894vh) scale(0.376);
  }
  to {
    transform: translate(74.11475vw, 100vh) scale(0.376);
  }
}
.snow:nth-child(109) {
  opacity: 0.1804;
  transform: translate(42.5857vw, -10px) scale(0.7259);
  animation: fall-109 20s -19s linear infinite;
}
@keyframes fall-109 {
  31.873% {
    transform: translate(40.7508vw, 31.873vh) scale(0.7259);
  }
  to {
    transform: translate(41.66825vw, 100vh) scale(0.7259);
  }
}
.snow:nth-child(110) {
  opacity: 0.1952;
  transform: translate(66.9746vw, -10px) scale(0.7504);
  animation: fall-110 23s -1s linear infinite;
}
@keyframes fall-110 {
  47.786% {
    transform: translate(58.7736vw, 47.786vh) scale(0.7504);
  }
  to {
    transform: translate(62.8741vw, 100vh) scale(0.7504);
  }
}
.snow:nth-child(111) {
  opacity: 0.9838;
  transform: translate(25.7827vw, -10px) scale(0.2249);
  animation: fall-111 16s -19s linear infinite;
}
@keyframes fall-111 {
  45.903% {
    transform: translate(27.4442vw, 45.903vh) scale(0.2249);
  }
  to {
    transform: translate(26.61345vw, 100vh) scale(0.2249);
  }
}
.snow:nth-child(112) {
  opacity: 0.2449;
  transform: translate(2.8393vw, -10px) scale(0.2183);
  animation: fall-112 19s -14s linear infinite;
}
@keyframes fall-112 {
  55.113% {
    transform: translate(-5.058vw, 55.113vh) scale(0.2183);
  }
  to {
    transform: translate(-1.10935vw, 100vh) scale(0.2183);
  }
}
.snow:nth-child(113) {
  opacity: 0.9888;
  transform: translate(94.5052vw, -10px) scale(0.4289);
  animation: fall-113 30s -29s linear infinite;
}
@keyframes fall-113 {
  57.336% {
    transform: translate(92.6417vw, 57.336vh) scale(0.4289);
  }
  to {
    transform: translate(93.57345vw, 100vh) scale(0.4289);
  }
}
.snow:nth-child(114) {
  opacity: 0.6069;
  transform: translate(20.7963vw, -10px) scale(0.2904);
  animation: fall-114 24s -16s linear infinite;
}
@keyframes fall-114 {
  61.179% {
    transform: translate(18.6996vw, 61.179vh) scale(0.2904);
  }
  to {
    transform: translate(19.74795vw, 100vh) scale(0.2904);
  }
}
.snow:nth-child(115) {
  opacity: 0.0166;
  transform: translate(83.9195vw, -10px) scale(0.0909);
  animation: fall-115 16s -27s linear infinite;
}
@keyframes fall-115 {
  75.029% {
    transform: translate(77.7317vw, 75.029vh) scale(0.0909);
  }
  to {
    transform: translate(80.8256vw, 100vh) scale(0.0909);
  }
}
.snow:nth-child(116) {
  opacity: 0.2585;
  transform: translate(98.0605vw, -10px) scale(0.7284);
  animation: fall-116 23s -6s linear infinite;
}
@keyframes fall-116 {
  78.845% {
    transform: translate(98.8236vw, 78.845vh) scale(0.7284);
  }
  to {
    transform: translate(98.44205vw, 100vh) scale(0.7284);
  }
}
.snow:nth-child(117) {
  opacity: 0.0278;
  transform: translate(70.4339vw, -10px) scale(0.4526);
  animation: fall-117 29s -19s linear infinite;
}
@keyframes fall-117 {
  40.625% {
    transform: translate(80.4265vw, 40.625vh) scale(0.4526);
  }
  to {
    transform: translate(75.4302vw, 100vh) scale(0.4526);
  }
}
.snow:nth-child(118) {
  opacity: 0.4996;
  transform: translate(76.7514vw, -10px) scale(0.3901);
  animation: fall-118 27s -22s linear infinite;
}
@keyframes fall-118 {
  69.439% {
    transform: translate(81.4105vw, 69.439vh) scale(0.3901);
  }
  to {
    transform: translate(79.08095vw, 100vh) scale(0.3901);
  }
}
.snow:nth-child(119) {
  opacity: 0.321;
  transform: translate(46.1104vw, -10px) scale(0.1218);
  animation: fall-119 25s -19s linear infinite;
}
@keyframes fall-119 {
  30.724% {
    transform: translate(54.6569vw, 30.724vh) scale(0.1218);
  }
  to {
    transform: translate(50.38365vw, 100vh) scale(0.1218);
  }
}
.snow:nth-child(120) {
  opacity: 0.0499;
  transform: translate(79.3463vw, -10px) scale(0.3753);
  animation: fall-120 21s -2s linear infinite;
}
@keyframes fall-120 {
  47.261% {
    transform: translate(77.9366vw, 47.261vh) scale(0.3753);
  }
  to {
    transform: translate(78.64145vw, 100vh) scale(0.3753);
  }
}
.snow:nth-child(121) {
  opacity: 0.0642;
  transform: translate(20.354vw, -10px) scale(0.8253);
  animation: fall-121 15s -1s linear infinite;
}
@keyframes fall-121 {
  65.011% {
    transform: translate(25.0939vw, 65.011vh) scale(0.8253);
  }
  to {
    transform: translate(22.72395vw, 100vh) scale(0.8253);
  }
}
.snow:nth-child(122) {
  opacity: 0.4069;
  transform: translate(52.4289vw, -10px) scale(0.9406);
  animation: fall-122 13s -14s linear infinite;
}
@keyframes fall-122 {
  46.281% {
    transform: translate(46.0838vw, 46.281vh) scale(0.9406);
  }
  to {
    transform: translate(49.25635vw, 100vh) scale(0.9406);
  }
}
.snow:nth-child(123) {
  opacity: 0.3869;
  transform: translate(14.5918vw, -10px) scale(0.7321);
  animation: fall-123 20s -24s linear infinite;
}
@keyframes fall-123 {
  30.009% {
    transform: translate(16.4691vw, 30.009vh) scale(0.7321);
  }
  to {
    transform: translate(15.53045vw, 100vh) scale(0.7321);
  }
}
.snow:nth-child(124) {
  opacity: 0.3203;
  transform: translate(12.7662vw, -10px) scale(0.5681);
  animation: fall-124 25s -17s linear infinite;
}
@keyframes fall-124 {
  35.727% {
    transform: translate(10.3588vw, 35.727vh) scale(0.5681);
  }
  to {
    transform: translate(11.5625vw, 100vh) scale(0.5681);
  }
}
.snow:nth-child(125) {
  opacity: 0.1658;
  transform: translate(62.3007vw, -10px) scale(0.8202);
  animation: fall-125 30s -24s linear infinite;
}
@keyframes fall-125 {
  48.264% {
    transform: translate(59.7139vw, 48.264vh) scale(0.8202);
  }
  to {
    transform: translate(61.0073vw, 100vh) scale(0.8202);
  }
}
.snow:nth-child(126) {
  opacity: 0.5101;
  transform: translate(27.1375vw, -10px) scale(0.5105);
  animation: fall-126 30s -19s linear infinite;
}
@keyframes fall-126 {
  50.663% {
    transform: translate(20.8923vw, 50.663vh) scale(0.5105);
  }
  to {
    transform: translate(24.0149vw, 100vh) scale(0.5105);
  }
}
.snow:nth-child(127) {
  opacity: 0.9093;
  transform: translate(76.0633vw, -10px) scale(0.4191);
  animation: fall-127 16s -24s linear infinite;
}
@keyframes fall-127 {
  70.966% {
    transform: translate(71.6307vw, 70.966vh) scale(0.4191);
  }
  to {
    transform: translate(73.847vw, 100vh) scale(0.4191);
  }
}
.snow:nth-child(128) {
  opacity: 0.8433;
  transform: translate(96.0707vw, -10px) scale(0.5755);
  animation: fall-128 28s -1s linear infinite;
}
@keyframes fall-128 {
  47.616% {
    transform: translate(105.422vw, 47.616vh) scale(0.5755);
  }
  to {
    transform: translate(100.74635vw, 100vh) scale(0.5755);
  }
}
.snow:nth-child(129) {
  opacity: 0.3679;
  transform: translate(16.1612vw, -10px) scale(0.71);
  animation: fall-129 16s -19s linear infinite;
}
@keyframes fall-129 {
  70.055% {
    transform: translate(22.5999vw, 70.055vh) scale(0.71);
  }
  to {
    transform: translate(19.38055vw, 100vh) scale(0.71);
  }
}
.snow:nth-child(130) {
  opacity: 0.1173;
  transform: translate(86.6465vw, -10px) scale(0.9759);
  animation: fall-130 27s -28s linear infinite;
}
@keyframes fall-130 {
  55.49% {
    transform: translate(78.5375vw, 55.49vh) scale(0.9759);
  }
  to {
    transform: translate(82.592vw, 100vh) scale(0.9759);
  }
}
.snow:nth-child(131) {
  opacity: 0.1343;
  transform: translate(91.1473vw, -10px) scale(0.7666);
  animation: fall-131 21s -12s linear infinite;
}
@keyframes fall-131 {
  47.974% {
    transform: translate(93.1735vw, 47.974vh) scale(0.7666);
  }
  to {
    transform: translate(92.1604vw, 100vh) scale(0.7666);
  }
}
.snow:nth-child(132) {
  opacity: 0.2174;
  transform: translate(44.2318vw, -10px) scale(0.1408);
  animation: fall-132 11s -8s linear infinite;
}
@keyframes fall-132 {
  45.146% {
    transform: translate(39.0737vw, 45.146vh) scale(0.1408);
  }
  to {
    transform: translate(41.65275vw, 100vh) scale(0.1408);
  }
}
.snow:nth-child(133) {
  opacity: 0.7527;
  transform: translate(48.1051vw, -10px) scale(0.5069);
  animation: fall-133 24s -28s linear infinite;
}
@keyframes fall-133 {
  76.223% {
    transform: translate(56.1864vw, 76.223vh) scale(0.5069);
  }
  to {
    transform: translate(52.14575vw, 100vh) scale(0.5069);
  }
}
.snow:nth-child(134) {
  opacity: 0.1354;
  transform: translate(68.725vw, -10px) scale(0.2898);
  animation: fall-134 16s -17s linear infinite;
}
@keyframes fall-134 {
  57.56% {
    transform: translate(77.7506vw, 57.56vh) scale(0.2898);
  }
  to {
    transform: translate(73.2378vw, 100vh) scale(0.2898);
  }
}
.snow:nth-child(135) {
  opacity: 0.4955;
  transform: translate(7.3464vw, -10px) scale(0.9105);
  animation: fall-135 28s -17s linear infinite;
}
@keyframes fall-135 {
  35.837% {
    transform: translate(15.5935vw, 35.837vh) scale(0.9105);
  }
  to {
    transform: translate(11.46995vw, 100vh) scale(0.9105);
  }
}
.snow:nth-child(136) {
  opacity: 0.8092;
  transform: translate(39.274vw, -10px) scale(0.8085);
  animation: fall-136 26s -20s linear infinite;
}
@keyframes fall-136 {
  65.309% {
    transform: translate(48.8088vw, 65.309vh) scale(0.8085);
  }
  to {
    transform: translate(44.0414vw, 100vh) scale(0.8085);
  }
}
.snow:nth-child(137) {
  opacity: 0.7653;
  transform: translate(18.6171vw, -10px) scale(0.0595);
  animation: fall-137 16s -22s linear infinite;
}
@keyframes fall-137 {
  75.973% {
    transform: translate(15.8794vw, 75.973vh) scale(0.0595);
  }
  to {
    transform: translate(17.24825vw, 100vh) scale(0.0595);
  }
}
.snow:nth-child(138) {
  opacity: 0.8807;
  transform: translate(1.3687vw, -10px) scale(0.9047);
  animation: fall-138 24s -4s linear infinite;
}
@keyframes fall-138 {
  37.329% {
    transform: translate(7.8274vw, 37.329vh) scale(0.9047);
  }
  to {
    transform: translate(4.59805vw, 100vh) scale(0.9047);
  }
}
.snow:nth-child(139) {
  opacity: 0.2434;
  transform: translate(80.9867vw, -10px) scale(0.0411);
  animation: fall-139 16s -5s linear infinite;
}
@keyframes fall-139 {
  65.191% {
    transform: translate(77.7452vw, 65.191vh) scale(0.0411);
  }
  to {
    transform: translate(79.36595vw, 100vh) scale(0.0411);
  }
}
.snow:nth-child(140) {
  opacity: 0.0751;
  transform: translate(31.6928vw, -10px) scale(0.9545);
  animation: fall-140 25s -14s linear infinite;
}
@keyframes fall-140 {
  53.761% {
    transform: translate(37.7394vw, 53.761vh) scale(0.9545);
  }
  to {
    transform: translate(34.7161vw, 100vh) scale(0.9545);
  }
}
.snow:nth-child(141) {
  opacity: 0.2284;
  transform: translate(32.6287vw, -10px) scale(0.6138);
  animation: fall-141 25s -29s linear infinite;
}
@keyframes fall-141 {
  30.765% {
    transform: translate(24.6145vw, 30.765vh) scale(0.6138);
  }
  to {
    transform: translate(28.6216vw, 100vh) scale(0.6138);
  }
}
.snow:nth-child(142) {
  opacity: 0.0705;
  transform: translate(37.91vw, -10px) scale(0.5335);
  animation: fall-142 27s -13s linear infinite;
}
@keyframes fall-142 {
  31.126% {
    transform: translate(43.5747vw, 31.126vh) scale(0.5335);
  }
  to {
    transform: translate(40.74235vw, 100vh) scale(0.5335);
  }
}
.snow:nth-child(143) {
  opacity: 0.0375;
  transform: translate(88.0394vw, -10px) scale(0.3257);
  animation: fall-143 25s -26s linear infinite;
}
@keyframes fall-143 {
  44.534% {
    transform: translate(87.0051vw, 44.534vh) scale(0.3257);
  }
  to {
    transform: translate(87.52225vw, 100vh) scale(0.3257);
  }
}
.snow:nth-child(144) {
  opacity: 0.2877;
  transform: translate(25.9211vw, -10px) scale(0.8635);
  animation: fall-144 20s -22s linear infinite;
}
@keyframes fall-144 {
  33.246% {
    transform: translate(26.2556vw, 33.246vh) scale(0.8635);
  }
  to {
    transform: translate(26.08835vw, 100vh) scale(0.8635);
  }
}
.snow:nth-child(145) {
  opacity: 0.5794;
  transform: translate(2.149vw, -10px) scale(0.832);
  animation: fall-145 21s -23s linear infinite;
}
@keyframes fall-145 {
  78.556% {
    transform: translate(-6.9947vw, 78.556vh) scale(0.832);
  }
  to {
    transform: translate(-2.42285vw, 100vh) scale(0.832);
  }
}
.snow:nth-child(146) {
  opacity: 0.3434;
  transform: translate(29.0184vw, -10px) scale(0.5127);
  animation: fall-146 26s -8s linear infinite;
}
@keyframes fall-146 {
  68.843% {
    transform: translate(20.9807vw, 68.843vh) scale(0.5127);
  }
  to {
    transform: translate(24.99955vw, 100vh) scale(0.5127);
  }
}
.snow:nth-child(147) {
  opacity: 0.6533;
  transform: translate(12.6772vw, -10px) scale(0.4156);
  animation: fall-147 17s -17s linear infinite;
}
@keyframes fall-147 {
  53.283% {
    transform: translate(8.9874vw, 53.283vh) scale(0.4156);
  }
  to {
    transform: translate(10.8323vw, 100vh) scale(0.4156);
  }
}
.snow:nth-child(148) {
  opacity: 0.8796;
  transform: translate(2.5309vw, -10px) scale(0.1369);
  animation: fall-148 10s -11s linear infinite;
}
@keyframes fall-148 {
  35.283% {
    transform: translate(1.3062vw, 35.283vh) scale(0.1369);
  }
  to {
    transform: translate(1.91855vw, 100vh) scale(0.1369);
  }
}
.snow:nth-child(149) {
  opacity: 0.8882;
  transform: translate(7.7337vw, -10px) scale(0.7995);
  animation: fall-149 25s -29s linear infinite;
}
@keyframes fall-149 {
  59.372% {
    transform: translate(6.5346vw, 59.372vh) scale(0.7995);
  }
  to {
    transform: translate(7.13415vw, 100vh) scale(0.7995);
  }
}
.snow:nth-child(150) {
  opacity: 0.8731;
  transform: translate(69.5767vw, -10px) scale(0.6697);
  animation: fall-150 17s -14s linear infinite;
}
@keyframes fall-150 {
  61.197% {
    transform: translate(60.6906vw, 61.197vh) scale(0.6697);
  }
  to {
    transform: translate(65.13365vw, 100vh) scale(0.6697);
  }
}
.snow:nth-child(151) {
  opacity: 0.9739;
  transform: translate(46.6474vw, -10px) scale(0.0028);
  animation: fall-151 27s -16s linear infinite;
}
@keyframes fall-151 {
  35.493% {
    transform: translate(48.0777vw, 35.493vh) scale(0.0028);
  }
  to {
    transform: translate(47.36255vw, 100vh) scale(0.0028);
  }
}
.snow:nth-child(152) {
  opacity: 0.1047;
  transform: translate(1.8378vw, -10px) scale(0.6857);
  animation: fall-152 13s -1s linear infinite;
}
@keyframes fall-152 {
  69.255% {
    transform: translate(5.4484vw, 69.255vh) scale(0.6857);
  }
  to {
    transform: translate(3.6431vw, 100vh) scale(0.6857);
  }
}
.snow:nth-child(153) {
  opacity: 0.5233;
  transform: translate(77.2042vw, -10px) scale(0.5917);
  animation: fall-153 19s -12s linear infinite;
}
@keyframes fall-153 {
  47.22% {
    transform: translate(75.1586vw, 47.22vh) scale(0.5917);
  }
  to {
    transform: translate(76.1814vw, 100vh) scale(0.5917);
  }
}
.snow:nth-child(154) {
  opacity: 0.9147;
  transform: translate(80.967vw, -10px) scale(0.1789);
  animation: fall-154 11s -30s linear infinite;
}
@keyframes fall-154 {
  61.875% {
    transform: translate(75.5842vw, 61.875vh) scale(0.1789);
  }
  to {
    transform: translate(78.2756vw, 100vh) scale(0.1789);
  }
}
.snow:nth-child(155) {
  opacity: 0.0462;
  transform: translate(9.9333vw, -10px) scale(0.9977);
  animation: fall-155 19s -17s linear infinite;
}
@keyframes fall-155 {
  32.973% {
    transform: translate(17.0115vw, 32.973vh) scale(0.9977);
  }
  to {
    transform: translate(13.4724vw, 100vh) scale(0.9977);
  }
}
.snow:nth-child(156) {
  opacity: 0.5372;
  transform: translate(69.866vw, -10px) scale(0.2754);
  animation: fall-156 21s -12s linear infinite;
}
@keyframes fall-156 {
  77.44% {
    transform: translate(67.5238vw, 77.44vh) scale(0.2754);
  }
  to {
    transform: translate(68.6949vw, 100vh) scale(0.2754);
  }
}
.snow:nth-child(157) {
  opacity: 0.7165;
  transform: translate(56.3097vw, -10px) scale(0.848);
  animation: fall-157 23s -21s linear infinite;
}
@keyframes fall-157 {
  54.087% {
    transform: translate(61.2575vw, 54.087vh) scale(0.848);
  }
  to {
    transform: translate(58.7836vw, 100vh) scale(0.848);
  }
}
.snow:nth-child(158) {
  opacity: 0.2395;
  transform: translate(35.861vw, -10px) scale(0.5803);
  animation: fall-158 10s -4s linear infinite;
}
@keyframes fall-158 {
  61.602% {
    transform: translate(41.7492vw, 61.602vh) scale(0.5803);
  }
  to {
    transform: translate(38.8051vw, 100vh) scale(0.5803);
  }
}
.snow:nth-child(159) {
  opacity: 0.0668;
  transform: translate(44.1725vw, -10px) scale(0.6478);
  animation: fall-159 19s -18s linear infinite;
}
@keyframes fall-159 {
  74.014% {
    transform: translate(35.1534vw, 74.014vh) scale(0.6478);
  }
  to {
    transform: translate(39.66295vw, 100vh) scale(0.6478);
  }
}
.snow:nth-child(160) {
  opacity: 0.5588;
  transform: translate(15.5186vw, -10px) scale(0.3678);
  animation: fall-160 19s -14s linear infinite;
}
@keyframes fall-160 {
  44.215% {
    transform: translate(24.8303vw, 44.215vh) scale(0.3678);
  }
  to {
    transform: translate(20.17445vw, 100vh) scale(0.3678);
  }
}
.snow:nth-child(161) {
  opacity: 0.6949;
  transform: translate(35.9943vw, -10px) scale(0.1117);
  animation: fall-161 20s -17s linear infinite;
}
@keyframes fall-161 {
  43.25% {
    transform: translate(40.0099vw, 43.25vh) scale(0.1117);
  }
  to {
    transform: translate(38.0021vw, 100vh) scale(0.1117);
  }
}
.snow:nth-child(162) {
  opacity: 0.2794;
  transform: translate(21.6729vw, -10px) scale(0.4293);
  animation: fall-162 28s -3s linear infinite;
}
@keyframes fall-162 {
  40.575% {
    transform: translate(25.7179vw, 40.575vh) scale(0.4293);
  }
  to {
    transform: translate(23.6954vw, 100vh) scale(0.4293);
  }
}
.snow:nth-child(163) {
  opacity: 0.3867;
  transform: translate(61.1047vw, -10px) scale(0.5057);
  animation: fall-163 11s -8s linear infinite;
}
@keyframes fall-163 {
  44.47% {
    transform: translate(62.7034vw, 44.47vh) scale(0.5057);
  }
  to {
    transform: translate(61.90405vw, 100vh) scale(0.5057);
  }
}
.snow:nth-child(164) {
  opacity: 0.0598;
  transform: translate(0.0387vw, -10px) scale(0.7621);
  animation: fall-164 20s -12s linear infinite;
}
@keyframes fall-164 {
  77.404% {
    transform: translate(-5.2611vw, 77.404vh) scale(0.7621);
  }
  to {
    transform: translate(-2.6112vw, 100vh) scale(0.7621);
  }
}
.snow:nth-child(165) {
  opacity: 0.1247;
  transform: translate(71.938vw, -10px) scale(0.7145);
  animation: fall-165 15s -17s linear infinite;
}
@keyframes fall-165 {
  76.045% {
    transform: translate(76.0597vw, 76.045vh) scale(0.7145);
  }
  to {
    transform: translate(73.99885vw, 100vh) scale(0.7145);
  }
}
.snow:nth-child(166) {
  opacity: 0.2068;
  transform: translate(80.4144vw, -10px) scale(0.0411);
  animation: fall-166 18s -26s linear infinite;
}
@keyframes fall-166 {
  46.347% {
    transform: translate(85.6563vw, 46.347vh) scale(0.0411);
  }
  to {
    transform: translate(83.03535vw, 100vh) scale(0.0411);
  }
}
.snow:nth-child(167) {
  opacity: 0.5139;
  transform: translate(9.3231vw, -10px) scale(0.1923);
  animation: fall-167 13s -29s linear infinite;
}
@keyframes fall-167 {
  61.783% {
    transform: translate(8.8163vw, 61.783vh) scale(0.1923);
  }
  to {
    transform: translate(9.0697vw, 100vh) scale(0.1923);
  }
}
.snow:nth-child(168) {
  opacity: 0.1509;
  transform: translate(72.1538vw, -10px) scale(0.8949);
  animation: fall-168 21s -20s linear infinite;
}
@keyframes fall-168 {
  33.303% {
    transform: translate(66.1285vw, 33.303vh) scale(0.8949);
  }
  to {
    transform: translate(69.14115vw, 100vh) scale(0.8949);
  }
}
.snow:nth-child(169) {
  opacity: 0.0867;
  transform: translate(96.9532vw, -10px) scale(0.5829);
  animation: fall-169 29s -14s linear infinite;
}
@keyframes fall-169 {
  43.664% {
    transform: translate(98.9187vw, 43.664vh) scale(0.5829);
  }
  to {
    transform: translate(97.93595vw, 100vh) scale(0.5829);
  }
}
.snow:nth-child(170) {
  opacity: 0.9189;
  transform: translate(81.6648vw, -10px) scale(0.391);
  animation: fall-170 26s -20s linear infinite;
}
@keyframes fall-170 {
  61.168% {
    transform: translate(82.4247vw, 61.168vh) scale(0.391);
  }
  to {
    transform: translate(82.04475vw, 100vh) scale(0.391);
  }
}
.snow:nth-child(171) {
  opacity: 0.3363;
  transform: translate(13.5295vw, -10px) scale(0.2773);
  animation: fall-171 21s -6s linear infinite;
}
@keyframes fall-171 {
  52.438% {
    transform: translate(15.6297vw, 52.438vh) scale(0.2773);
  }
  to {
    transform: translate(14.5796vw, 100vh) scale(0.2773);
  }
}
.snow:nth-child(172) {
  opacity: 0.3636;
  transform: translate(53.6557vw, -10px) scale(0.8128);
  animation: fall-172 15s -3s linear infinite;
}
@keyframes fall-172 {
  32.332% {
    transform: translate(43.8144vw, 32.332vh) scale(0.8128);
  }
  to {
    transform: translate(48.73505vw, 100vh) scale(0.8128);
  }
}
.snow:nth-child(173) {
  opacity: 0.2532;
  transform: translate(44.8171vw, -10px) scale(0.5492);
  animation: fall-173 14s -20s linear infinite;
}
@keyframes fall-173 {
  51.941% {
    transform: translate(45.7882vw, 51.941vh) scale(0.5492);
  }
  to {
    transform: translate(45.30265vw, 100vh) scale(0.5492);
  }
}
.snow:nth-child(174) {
  opacity: 0.9757;
  transform: translate(67.9411vw, -10px) scale(0.4294);
  animation: fall-174 11s -5s linear infinite;
}
@keyframes fall-174 {
  53.859% {
    transform: translate(71.2243vw, 53.859vh) scale(0.4294);
  }
  to {
    transform: translate(69.5827vw, 100vh) scale(0.4294);
  }
}
.snow:nth-child(175) {
  opacity: 0.4898;
  transform: translate(59.7095vw, -10px) scale(0.0923);
  animation: fall-175 28s -19s linear infinite;
}
@keyframes fall-175 {
  31.749% {
    transform: translate(62.2656vw, 31.749vh) scale(0.0923);
  }
  to {
    transform: translate(60.98755vw, 100vh) scale(0.0923);
  }
}
.snow:nth-child(176) {
  opacity: 0.6617;
  transform: translate(60.2725vw, -10px) scale(0.5275);
  animation: fall-176 10s -28s linear infinite;
}
@keyframes fall-176 {
  31.5% {
    transform: translate(63.7575vw, 31.5vh) scale(0.5275);
  }
  to {
    transform: translate(62.015vw, 100vh) scale(0.5275);
  }
}
.snow:nth-child(177) {
  opacity: 0.442;
  transform: translate(56.2662vw, -10px) scale(0.9742);
  animation: fall-177 30s -20s linear infinite;
}
@keyframes fall-177 {
  42.609% {
    transform: translate(48.9431vw, 42.609vh) scale(0.9742);
  }
  to {
    transform: translate(52.60465vw, 100vh) scale(0.9742);
  }
}
.snow:nth-child(178) {
  opacity: 0.9235;
  transform: translate(18.4604vw, -10px) scale(0.2456);
  animation: fall-178 12s -20s linear infinite;
}
@keyframes fall-178 {
  78.754% {
    transform: translate(13.4548vw, 78.754vh) scale(0.2456);
  }
  to {
    transform: translate(15.9576vw, 100vh) scale(0.2456);
  }
}
.snow:nth-child(179) {
  opacity: 0.255;
  transform: translate(1.327vw, -10px) scale(0.2309);
  animation: fall-179 30s -10s linear infinite;
}
@keyframes fall-179 {
  67.533% {
    transform: translate(10.6594vw, 67.533vh) scale(0.2309);
  }
  to {
    transform: translate(5.9932vw, 100vh) scale(0.2309);
  }
}
.snow:nth-child(180) {
  opacity: 0.7459;
  transform: translate(37.4935vw, -10px) scale(0.6778);
  animation: fall-180 16s -4s linear infinite;
}
@keyframes fall-180 {
  51.186% {
    transform: translate(33.1045vw, 51.186vh) scale(0.6778);
  }
  to {
    transform: translate(35.299vw, 100vh) scale(0.6778);
  }
}
.snow:nth-child(181) {
  opacity: 0.1101;
  transform: translate(67.4798vw, -10px) scale(0.6032);
  animation: fall-181 28s -7s linear infinite;
}
@keyframes fall-181 {
  67.141% {
    transform: translate(61.081vw, 67.141vh) scale(0.6032);
  }
  to {
    transform: translate(64.2804vw, 100vh) scale(0.6032);
  }
}
.snow:nth-child(182) {
  opacity: 0.7962;
  transform: translate(71.113vw, -10px) scale(0.7645);
  animation: fall-182 11s -24s linear infinite;
}
@keyframes fall-182 {
  61.83% {
    transform: translate(71.4714vw, 61.83vh) scale(0.7645);
  }
  to {
    transform: translate(71.2922vw, 100vh) scale(0.7645);
  }
}
.snow:nth-child(183) {
  opacity: 0.1248;
  transform: translate(96.7587vw, -10px) scale(0.9421);
  animation: fall-183 27s -2s linear infinite;
}
@keyframes fall-183 {
  69.637% {
    transform: translate(100.4205vw, 69.637vh) scale(0.9421);
  }
  to {
    transform: translate(98.5896vw, 100vh) scale(0.9421);
  }
}
.snow:nth-child(184) {
  opacity: 0.5279;
  transform: translate(89.231vw, -10px) scale(0.3322);
  animation: fall-184 24s -24s linear infinite;
}
@keyframes fall-184 {
  57.901% {
    transform: translate(94.0814vw, 57.901vh) scale(0.3322);
  }
  to {
    transform: translate(91.6562vw, 100vh) scale(0.3322);
  }
}
.snow:nth-child(185) {
  opacity: 0.3828;
  transform: translate(76.0815vw, -10px) scale(0.2538);
  animation: fall-185 29s -22s linear infinite;
}
@keyframes fall-185 {
  65.291% {
    transform: translate(69.4609vw, 65.291vh) scale(0.2538);
  }
  to {
    transform: translate(72.7712vw, 100vh) scale(0.2538);
  }
}
.snow:nth-child(186) {
  opacity: 0.5055;
  transform: translate(75.4642vw, -10px) scale(0.4651);
  animation: fall-186 21s -28s linear infinite;
}
@keyframes fall-186 {
  71.74% {
    transform: translate(72.5701vw, 71.74vh) scale(0.4651);
  }
  to {
    transform: translate(74.01715vw, 100vh) scale(0.4651);
  }
}
.snow:nth-child(187) {
  opacity: 0.2137;
  transform: translate(49.4656vw, -10px) scale(0.5946);
  animation: fall-187 26s -29s linear infinite;
}
@keyframes fall-187 {
  53.999% {
    transform: translate(47.7649vw, 53.999vh) scale(0.5946);
  }
  to {
    transform: translate(48.61525vw, 100vh) scale(0.5946);
  }
}
.snow:nth-child(188) {
  opacity: 0.5361;
  transform: translate(51.2211vw, -10px) scale(0.9926);
  animation: fall-188 11s -13s linear infinite;
}
@keyframes fall-188 {
  72.941% {
    transform: translate(48.9581vw, 72.941vh) scale(0.9926);
  }
  to {
    transform: translate(50.0896vw, 100vh) scale(0.9926);
  }
}
.snow:nth-child(189) {
  opacity: 0.6936;
  transform: translate(45.8449vw, -10px) scale(0.7132);
  animation: fall-189 26s -23s linear infinite;
}
@keyframes fall-189 {
  79.824% {
    transform: translate(52.0511vw, 79.824vh) scale(0.7132);
  }
  to {
    transform: translate(48.948vw, 100vh) scale(0.7132);
  }
}
.snow:nth-child(190) {
  opacity: 0.8396;
  transform: translate(40.8396vw, -10px) scale(0.8384);
  animation: fall-190 27s -4s linear infinite;
}
@keyframes fall-190 {
  52.088% {
    transform: translate(33.5455vw, 52.088vh) scale(0.8384);
  }
  to {
    transform: translate(37.19255vw, 100vh) scale(0.8384);
  }
}
.snow:nth-child(191) {
  opacity: 0.8256;
  transform: translate(61.429vw, -10px) scale(0.7689);
  animation: fall-191 13s -14s linear infinite;
}
@keyframes fall-191 {
  68.068% {
    transform: translate(65.1592vw, 68.068vh) scale(0.7689);
  }
  to {
    transform: translate(63.2941vw, 100vh) scale(0.7689);
  }
}
.snow:nth-child(192) {
  opacity: 0.3059;
  transform: translate(81.419vw, -10px) scale(0.7448);
  animation: fall-192 13s -24s linear infinite;
}
@keyframes fall-192 {
  48.242% {
    transform: translate(74.261vw, 48.242vh) scale(0.7448);
  }
  to {
    transform: translate(77.84vw, 100vh) scale(0.7448);
  }
}
.snow:nth-child(193) {
  opacity: 0.9851;
  transform: translate(53.9525vw, -10px) scale(0.9384);
  animation: fall-193 14s -20s linear infinite;
}
@keyframes fall-193 {
  64.74% {
    transform: translate(59.0825vw, 64.74vh) scale(0.9384);
  }
  to {
    transform: translate(56.5175vw, 100vh) scale(0.9384);
  }
}
.snow:nth-child(194) {
  opacity: 0.7409;
  transform: translate(46.4701vw, -10px) scale(0.963);
  animation: fall-194 14s -7s linear infinite;
}
@keyframes fall-194 {
  69.519% {
    transform: translate(36.7994vw, 69.519vh) scale(0.963);
  }
  to {
    transform: translate(41.63475vw, 100vh) scale(0.963);
  }
}
.snow:nth-child(195) {
  opacity: 0.1383;
  transform: translate(77.062vw, -10px) scale(0.0763);
  animation: fall-195 19s -26s linear infinite;
}
@keyframes fall-195 {
  35.202% {
    transform: translate(71.2453vw, 35.202vh) scale(0.0763);
  }
  to {
    transform: translate(74.15365vw, 100vh) scale(0.0763);
  }
}
.snow:nth-child(196) {
  opacity: 0.6434;
  transform: translate(84.1853vw, -10px) scale(0.9244);
  animation: fall-196 20s -22s linear infinite;
}
@keyframes fall-196 {
  76.244% {
    transform: translate(76.3362vw, 76.244vh) scale(0.9244);
  }
  to {
    transform: translate(80.26075vw, 100vh) scale(0.9244);
  }
}
.snow:nth-child(197) {
  opacity: 0.2297;
  transform: translate(72.688vw, -10px) scale(0.6313);
  animation: fall-197 23s -5s linear infinite;
}
@keyframes fall-197 {
  53.123% {
    transform: translate(65.6758vw, 53.123vh) scale(0.6313);
  }
  to {
    transform: translate(69.1819vw, 100vh) scale(0.6313);
  }
}
.snow:nth-child(198) {
  opacity: 0.7108;
  transform: translate(56.6765vw, -10px) scale(0.1905);
  animation: fall-198 16s -15s linear infinite;
}
@keyframes fall-198 {
  38.509% {
    transform: translate(53.1169vw, 38.509vh) scale(0.1905);
  }
  to {
    transform: translate(54.8967vw, 100vh) scale(0.1905);
  }
}
.snow:nth-child(199) {
  opacity: 0.3351;
  transform: translate(54.0441vw, -10px) scale(0.3972);
  animation: fall-199 17s -10s linear infinite;
}
@keyframes fall-199 {
  71.327% {
    transform: translate(55.0028vw, 71.327vh) scale(0.3972);
  }
  to {
    transform: translate(54.52345vw, 100vh) scale(0.3972);
  }
}
.snow:nth-child(200) {
  opacity: 0.4613;
  transform: translate(5.2449vw, -10px) scale(0.7903);
  animation: fall-200 22s -6s linear infinite;
}
@keyframes fall-200 {
  67.455% {
    transform: translate(3.9962vw, 67.455vh) scale(0.7903);
  }
  to {
    transform: translate(4.62055vw, 100vh) scale(0.7903);
  }
}
</style>

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
<div class=&quot;snow&quot;></div>
  
  
  
  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>
   
      
      
      <!--FALL-->
      <div id="result-iframe-wrap" role="main">

    <iframe data-visible-from="09-22" data-visible-to="09-22"  style="position:fixed; top:0; left:0; bottom:0; right:0; width:100%; height:100%; border:none; margin:0; padding:0; overflow:hidden:" id="result" srcdoc="
<!DOCTYPE html>
<html lang=&quot;en&quot; >

<head>

  <meta charset=&quot;UTF-8&quot;>
  
  <link rel=&quot;apple-touch-icon&quot; type=&quot;image/png&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/apple-touch-icon-5ae1a0698dcc2402e9712f7d01ed509a57814f994c660df9f7a952f3060705ee.png&quot; />

  <meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;CodePen&quot;>

  <link rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/favicon-aec34940fbc1a6e787974dcd360f2c6b63348d4b1f4e06c77743096d55480f33.ico&quot; />

  <link rel=&quot;mask-icon&quot; type=&quot;image/x-icon&quot; href=&quot;https://cpwebassets.codepen.io/assets/favicon/logo-pin-b4b4269c16397ad2f0f7a01bcdf513a1994f4c94b8af2f191c09eb0d601762b1.svg&quot; color=&quot;#111&quot; />  
  
  
  

  <script>
  window.console = window.console || function(t) {};
</script>

  
  
  <script>
  if (document.location.search.match(/type=embed/gi)) {
    window.parent.postMessage(&quot;resize&quot;, &quot;*&quot;);
  }
</script>


</head>

<body translate=&quot;no&quot; >
  <canvas id=&quot;canvasleaves&quot;></canvas>
<style>
  canvas {
    margin: 0;
    background-color: burlywood;
    border: none;
}
body {
    margin: 0;
    background-color: burlywood;
    border: none;
}
  </style>
<script>
  var tree = {

    canvas:     '',
    ctx:        '',
    height:     0,
    width:      0,
    spread:     0.2,
    drawLeaves: true,
    leaveType:  this.MEDIUM_LEAVES,
    
    MAX_BRANCH_WIDTH:   10,
    SMALL_LEAVES:       100,
    MEDIUM_LEAVES:      200,
    BIG_LEAVES:         500,
    THIN_LEAVES:        900,
    automnColors: ['#996655', '#cc6633', '#cc8844', '#cc8866', '#ff8833', '#ffbb55'],
    branchColor: '#3F3F3F',
    leavesColor: '',

    draw : function(ctx, h, w, spread, leaves, leaveType, index, treeHeight) {
        this.leavesColor = this.automnColors[Math.floor(Math.random() * this.automnColors.length)];
        // Set how much the tree branches are spread
        if(spread >= 0.3 &amp;&amp; spread <= 1) {
            this.spread = spread;
        } else {
            this.spread = 0.6;
        }
        
        if(leaves === true || leaves === false) {
            this.drawLeaves = leaves;
        } else {
            this.leaves = true;
        }
        
        if(leaveType == this.SMALL_LEAVES || 
           leaveType == this.MEDIUM_LEAVES || 
           leaveType == this.BIG_LEAVES || 
           leaveType == this.THIN_LEAVES) {
            this.leaveType = leaveType;
        } else {
            this.leaveType = this.MEDIUM_LEAVES;
        }
        
        this.ctx = ctx;
        this.height = h;
        this.width = w;
        //this.ctx.clearRect(0,0,this.width,this.height);
        var gradient = this.ctx.createLinearGradient(0, height, 0, 0)
        gradient.addColorStop(0,&quot;rgba(255,255,255,0.01)&quot;);
        gradient.addColorStop(1,&quot;rgba(255,255,255,0)&quot;);
        //this.ctx.fillStyle = 'rgba(255,255,255,0.01)';
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, width, height);

        // Center the tree in the window
        this.ctx.translate(index*this.width/treeNumbers - (Math.random()*100 - Math.random()*100) ,this.height);
        // Set the leaves to a random color
        this.leavesColor = this.leavesColor;
        // Set branch thickness
        this.ctx.lineWidth = 1 + (Math.random() * this.MAX_BRANCH_WIDTH);
        this.ctx.lineJoin = 'round';
        
        this.branch(0, treeHeight);
    },
    
    /**
     * @member branch
     * tree.branch() main tree drawing function
     *
     * @param {String} depth the maimum depth the tree can branch,
     *        Keep this value near 12, larger value take linger to render.
     *
     */
    branch : function(depth, treeHeight) {
        if (depth < 12) 
        {
            this.ctx.beginPath();
            this.ctx.moveTo(0,0);
            this.ctx.lineTo(0,-(this.height)/treeHeight);

            this.ctx.strokeStyle = this.branchColor;
            this.ctx.stroke();
            
            this.ctx.translate(0,-this.height/treeHeight);
            // Random integer from -0.1 to 0.1
            var randomN = -(Math.random() * 0.1) + 0.1;

            this.ctx.rotate(randomN); 

            if ((Math.random() * 1) < this.spread)
            {
                // Draw the left branches
                //this.ctx.rotate((Math.floor(Math.random() * 45) + 25)*0.001);
                var rotateLeft = (Math.random()*(4-3+1)+3)*0.1;
                var rotateRight = (Math.random()*(7-6+1)+6)*0.1;
                this.ctx.rotate(-rotateLeft);
                //var scaling = (Math.random()*(7-5+1)+5)*0.1;
                this.ctx.scale(0.7, 0.7);
                this.ctx.save();
                this.branch(depth + 1, treeHeight);
                // Draw the right branches
                this.ctx.restore();  
                this.ctx.rotate(rotateRight);
                this.ctx.save();
                this.branch(depth + 1, treeHeight);   
                this.ctx.restore();        
            }
            else 
            { 
                this.branch(depth, treeHeight);
            }

        }
        else
        {   
            // Now that we have done drawing branches, draw the leaves
            if(this.drawLeaves) {
                var lengthFactor = 200;
                if(this.leaveType === this.THIN_LEAVES) {
                    lengthFactor = 10;
                }
                this.ctx.fillStyle = this.leavesColor;
                this.ctx.fillRect(0, 0, this.leaveType, lengthFactor);
                this.ctx.stroke();
            }
        }
    }
};




var width = window.innerWidth;  
var height = window.innerHeight;
var intervalId = 0;
var treeNumbers = 10;
var trees = [];

var drawLeaves = true;
var treeSpread = Math.random()*10; // 0.6
var temp  = Math.round(Math.random()*10); // 2
var leaveType = '';

switch(temp) {
    case '1': leaveType = tree.SMALL_LEAVES;
            break;
    case '2': leaveType = tree.MEDIUM_LEAVES;
            break;
    case '3': leaveType = tree.BIG_LEAVES;
            break;
    case '4': leaveType = tree.THIN_LEAVES;
            break;
    default:leaveType = tree.MEDIUM_LEAVES;
}


function init() {
    
    var canvas = document.getElementById(&quot;canvasleaves&quot;);
    
    if(canvas.getContext(&quot;2d&quot;)) {
    
        canvas.height = height;
        canvas.width = width;
        ctx = canvas.getContext(&quot;2d&quot;);
        for(var i=0;i<treeNumbers;i++){
            drawTree(i);
        }
    
    } else {
        document.getElementsByTagName('body').innerHTML = &quot;Your browser doen't support Canvas!&quot;;
    }

    animate();
};

function drawTree(i) {
    ctx.save();
    tree.draw(ctx,height,width,treeSpread,drawLeaves,leaveType, i, 10);
    ctx.restore();
}


function animate(){
    ctx.save();
    // Math.round((Math.random()*(500-5+1)+5))
    tree.draw(ctx,height,width,treeSpread,drawLeaves,leaveType, Math.round((Math.random()*(treeNumbers+1))), Math.round((Math.random()*(15-5+1)+5)));
    ctx.restore();
}

document.body.onkeydown = function(e){
    animate();
}

init();
</script>
  
  
  
  

</body>

</html>
 
" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts allow-top-navigation-by-user-activation allow-downloads allow-presentation" allow="accelerometer; camera; encrypted-media; display-capture; geolocation; gyroscope; microphone; midi; clipboard-read; clipboard-write" allowtransparency="true" allowpaymentrequest="true" allowfullscreen="true" class="result-iframe">
    </iframe>

  </div>
   
	 <style>
    html {
      font-size: 15px;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      min-height: 100%;
    }

    body {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
  </style>
</head>
  <script>
  let arrow = document.querySelectorAll(".arrow");
  for (var i = 0; i < arrow.length; i++) {
    arrow[i].addEventListener("click", (e)=>{
   let arrowParent = e.target.parentElement.parentElement;//selecting main parent of arrow
   arrowParent.classList.toggle("showMenu");
    });
  }
  let sidebar = document.querySelector(".sidebar");
  let sidebarBtn = document.querySelector(".bx-menu");
  console.log(sidebarBtn);
  sidebarBtn.addEventListener("click", ()=>{
    sidebar.classList.toggle("close");
  });
  </script>
 <input type="checkbox" class="form-check-input" id="darkSwitch">
     <script>

var darkSwitch = document.getElementById("darkSwitch");
window.addEventListener("load", function () {
  if (darkSwitch) {
    initTheme();
    darkSwitch.addEventListener("change", function () {
      resetTheme();
    });
  }
});

/**
 * Summary: function that adds or removes the attribute 'data-theme' depending if
 * the switch is 'on' or 'off'.
 *
 * Description: initTheme is a function that uses localStorage from JavaScript DOM,
 * to store the value of the HTML switch. If the switch was already switched to
 * 'on' it will set an HTML attribute to the body named: 'data-theme' to a 'dark'
 * value. If it is the first time opening the page, or if the switch was off the
 * 'data-theme' attribute will not be set.
 * @return {void}
 */
function initTheme() {
  var darkThemeSelected =
    localStorage.getItem("darkSwitch") !== null &&
    localStorage.getItem("darkSwitch") === "dark";
  darkSwitch.checked = darkThemeSelected;
  darkThemeSelected
    ? document.body.setAttribute("data-theme", "dark")
    : document.body.removeAttribute("data-theme");
}

/**
 * Summary: resetTheme checks if the switch is 'on' or 'off' and if it is toggled
 * on it will set the HTML attribute 'data-theme' to dark so the dark-theme CSS is
 * applied.
 * @return {void}
 */
function resetTheme() {
  if (darkSwitch.checked) {
    document.body.setAttribute("data-theme", "dark");
    localStorage.setItem("darkSwitch", "dark");
  } else {
    document.body.removeAttribute("data-theme");
    localStorage.removeItem("darkSwitch");
  }
}
</script>
  <!-- IE 11 polyfill for CSS and Custom Properties -->
  <script
    nomodule>window.MSInputMethodContext && document.documentMode && document.write('<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-ie11@5/css/bootstrap-ie11.min.css"><script src="https://cdn.jsdelivr.net/npm/ie11-custom-properties@4/ie11CustomProperties.min.js"><\/script>');</script>
<script>
/*!
 * Dark Mode Switch v1.0.1 (https://github.com/coliff/dark-mode-switch)
 * Copyright 2021 C.Oliff
 * Licensed under MIT (https://github.com/coliff/dark-mode-switch/blob/main/LICENSE)
 */
var darkSwitch=document.getElementById("darkSwitch");window.addEventListener("load",(function(){if(darkSwitch){initTheme();darkSwitch.addEventListener("change",(function(){resetTheme()}))}}));function initTheme(){var darkThemeSelected=localStorage.getItem("darkSwitch")!==null&&localStorage.getItem("darkSwitch")==="dark";darkSwitch.checked=darkThemeSelected;darkThemeSelected?document.body.setAttribute("data-theme","dark"):document.body.removeAttribute("data-theme")}function resetTheme(){if(darkSwitch.checked){document.body.setAttribute("data-theme","dark");localStorage.setItem("darkSwitch","dark")}else{document.body.removeAttribute("data-theme");localStorage.removeItem("darkSwitch")}}
</script>

  <body onload="typeWriter()"></body>
<style>
.header {
	 position: relative;
	 overflow: hidden;
   text-align: center;

}

 .arrow {
	 position: absolute;
	 width: 100%;
	 height: 100%;
	 font-size: 18px;
	 opacity: 0;
	 transform: scale(1.7);
	 animation: fade-content 0.5s 2.2s cubic-bezier(0.2, 1, 0.2, 1) forwards;
}
 .arrow::before, .arrow::after {
	 content: '';
	 position: absolute;
	 top: 50%;
	 left: 50%;
	 border-top: 1.5em solid transparent;
}
 .arrow::before {
	 border-right: 1em solid #c7deef;
	 transform-origin: 100% 0;
	 transform: translate(calc(-100%), -75%) skewY(-25deg);
}
 .arrow::after {
	 border-left: 1em solid #5a7695;
	 transform-origin: 0 0;
	 transform: translate(1px, -75%) skewY(25deg);
}
 .slogan {
	 max-width: 630px;
	 margin: 0 auto 3.5rem;
	 color: #023161;
	 font: 100 26px / 1.5 sans-serif;
	 text-shadow: 0 1px 1px rgba(0, 0, 0, .2);
	 text-transform: capitalize;
	 opacity: 0;
	 transform: perspective(800px) rotateX(-60deg) translateY(50px);
	 animation: fade-content 0.85s 2.1s cubic-bezier(0.2, 1, 0.2, 1) forwards;
}
 .slogan .ps {
	 color: #fff;
	 text-transform: lowercase;
	 text-shadow: 0 1px 2px rgba(0, 30, 50, .15);
}
 .btns {
	 margin-bottom: 5rem;
   z-index: 10;
}
 .btn {
	 position: relative;
	 padding: 0.75rem 1rem;
	 border: none;
	 border-radius: 0.25rem;
	 outline: none;
	 font-size: 14px;
	 text-transform: capitalize;
	 color: #008cdd;
	 background: linear-gradient(#fff, rgba(255, 255, 255, .9));
	 text-shadow: 0 0px 0 #fff;
	 box-shadow: inset 0 1px 1px #fff, inset 0 -1px 4px rgba(23, 78, 138, .1), 0 4px 20px -2px rgba(0, 0, 0, .2);
	 cursor: pointer;
	 opacity: 0;
	 transform: perspective(800px) rotateX(-50deg) translateY(30px);
	 animation: fade-content 0.7s 2.2s forwards;
}

[data-theme="dark"]  .btn {
	 background: #404040;
     	 box-shadow: inset 0 1px 1px #202020, inset 0 -1px 4px rgba(23, 78, 138, .1), 0 4px 20px -2px rgba(0, 0, 0, .2);
     color: white;
}

 .btn::before {
	 content: '';
	 position: absolute;
	 top: 0;
	 left: 0;
	 right: 0;
	 bottom: 0;
	 border-radius: inherit;
	 color: rgba(0, 0, 0, .2);
	 opacity: 0;
	 box-shadow: 0 4px 20px -2px;
	 transition-duration: 0.4s;
}
 .btn:hover::before {
	 opacity: 1;
}
 .btn--primary {
	 color: #fff;
	 font-weight: 900;
	 text-shadow: 0 1px 0 rgba(0, 0, 0, .1);
	 box-shadow: 0 4px 16px -1px rgba(0, 0, 0, .4);
	 background: #123159 linear-gradient(#123159, #0f294d);
}


 .btn--primary::before {
	 color: rgba(0, 0, 0, .3);
}
 .btn ~ .btn {
	 margin-left: 1.5em;
	 animation-delay: 2.4s;
}
 .circle {
	 position: absolute;
	 top: calc(50% - 10vw);
	 left: calc(50% - 50vw);
	 width: 200vw;
	 height: 200vw;
	 border-radius: 50%;
	 background-color: rgba(255, 0, 0, .1);
	 background-image: linear-gradient(45deg, rgba(59, 196, 237, .75) 55%, rgba(156, 122, 255, .75), rgba(250, 115, 180, .75) 72%);
	 transform: translate(100%, 500px);
	 animation: fade-content 1.2s 0.7s cubic-bezier(0.2, 1, 0.2, 1) forwards;
	 mix-blend-mode: darken;
}
 .circle.c2 {
	 top: calc(50% - 1vw);
	 left: calc(50% - 90vw);
	 width: 250vw;
	 height: 250vw;
	 background-image: linear-gradient(45deg, rgba(192, 91, 212, .75) 62.5%, rgba(136, 64, 237, .75), rgba(235, 113, 196, .75) 70%);
	 animation-delay: 0.5s;
}
 .hill {
	 position: relative;
	 height: 20rem;
	 overflow: hidden;
}
 .hill::before {
	 content: '';
	 position: absolute;
	 border-radius: 50%;
	 top: 1rem;
	 left: 50%;
	 width: 1000vw;
	 height: 1000vw;
	 transform: translate(calc(-50% + 35vw), 0);
	 background-color: #fff;
	 color: #90909010;
	 box-shadow: 0 0 0.5rem, 0 0 2rem, 0 0 3rem;
}

[data-theme="dark"]  .hill::before {
	 background-color: #404040;
     color: #20202010;
}
 @keyframes fade-content {
	 to {
		 opacity: 1;
		 transform: none;
	}
}
 *, *::before, *::after {
	 box-sizing: border-box;
	 margin: 0;
	 padding: 0;
} 
 .info {
	 position: absolute;
	 bottom: 0;
	 right: 0;
	 margin: 1em;
	 font-size: 0.9em;
	 font-style: italic;
	 font-family: serif;
	 text-align: right;
	 opacity: 0.5;
}
 .info a {
	 color: inherit;
}
 .sr-only {
	 position: absolute;
	 width: 1px;
	 height: 1px;
	 padding: 0;
	 margin: -1px;
	 overflow: hidden;
	 clip: rect(0, 0, 0, 0);
	 border: 0;
}
 
</style>
<header onload="typeWriter()" class="header">
  <div class="circle c1"></div>
  <div class="circle c2"></div> 
    <h1 class="slogan" style="text-align: center;position: relative;" class="w3-animate-top" class="title"><div data-visible-from="12-30" data-visible-to="01-01"><img style="width:434.5px;height:219px;z-index:10;position: relative;" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogony.png?raw=true" /></div>
      <img data-visible-from="01-02" data-visible-to="02-13" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
      <div data-visible-from="02-14" data-visible-to="02-14"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogovd.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="02-15" data-visible-to="03-24" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
<div data-visible-from="03-25" data-visible-to="04-20"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogoed.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="04-21" data-visible-to="07-03" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
      <div data-visible-from="07-04" data-visible-to="07-04"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogoid.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="07-05" data-visible-to="10-29" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
      <div data-visible-from="10-30" data-visible-to="10-31"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogohd.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="11-01" data-visible-to="11-07" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
      <div data-visible-from="11-08" data-visible-to="11-31"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogotg.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="12-01" data-visible-to="12-19" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
      <div data-visible-from="12-20" data-visible-to="12-27"><img class="w3-animate-bottom" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/viaticmainlogocd.png?raw=true" alt="" style="width:434.5px;height:219px;"/></div>
      <img data-visible-from="12-28" data-visible-to="12-29" class="w3-animate-bottom"src="https://github.com/spitriziv/Viatic/blob/main/www/image/viaticwordlogo.png?raw=true" alt="" style="width:434.5px;height:219px;"/>
  </h1>
  
  <body>
<div class="wrapper">
<div class="popup">
<div class="popup-inside">
<div class="backgrounds">
<div class="background"></div>
<div class="background background2"></div>
<div class="background background3"></div>
<div class="background background4"></div>
<div class="background background5"></div>
<div class="background background6"></div>
</div>
</div> 
	<style>
 * {
	 box-sizing: border-box;
}
 .color {
	 background: linear-gradient(to right,#a972e8,#f078dc);
}
 .try-again {
	 cursor: pointer;
	 position: relative;
	 font-size: 16px;
}
 .try-again:after {
	 content: '';
	 position: absolute;
	 left: 15px;
	 right: 15px;
	 height: 1px;
	 top: 100%;
	 background: #ebebeb;
	 margin-top: 8px;
	 transition: all 0.3s ease;
}
 .try-again:hover:after {
	 left: 40%;
	 right: 40%;
}
 .wrapper {
	 position: absolute;
	 top: 0;
	 width: 100%;
	 height: 100%;
	 display: flex;
	 align-items: center;
	 justify-content: center;
}
 .popup {
   z-index: 130;
	 opacity: 0;
	 visibility: hidden;
	 height: 400px;
	 width: 400px;
	 flex-shrink: 0;
	 border-radius: 3px;
	 position: relative;
   top:-100px;
	 display: flex;

	 transition: all 0.2s ease;
}
 .popup-inside {
	 position: absolute;
	 left: 0;
	 top: 0;
	 height: 100%;
	 width: 100%;
	 overflow: hidden;
	 border-radius: 50%;
	 box-shadow: 0 0 0 black;
	 transition: box-shadow 0.5s ease 0.7s, border-radius 0.35s ease 0.7s;
}
 .backgrounds {
	 position: absolute;
	 left: 0;
	 top: 0;
	 height: 100%;
	 width: 100%;
	 overflow: hidden;
}
 .background {
	 --offset: 0;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 transform: scale(0);
	 transition: all 0.5s ease 0s;
	 border-radius: 50%;
}
 .background2 {
	 --offset: 10%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 transform: scale(0);
	 transition: all 0.5s ease 0.1s;
}
 .background3 {
	 --offset: 20%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 2;
	 transition: all 0.5s ease 0.2s;
}
 .background4 {
	 --offset: 30%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 3;
	 transition: all 0.5s ease 0.3s;
}
 .background5 {
	 --offset: 40%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 4;
	 transition: all 0.5s ease 0.4s;
}
 .background6 {
	 --offset: 40%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: white;
	 z-index: 5;
	 transition: all 0.8s ease 0.4s;
}
 .contenttell {
	 --offset: 0;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
   overflow: hidden;
	 display: flex;
	 opacity: 0;
	 transition: all 0.35s ease 0.75s;
	 z-index: 10;
}
 body.active .contenttell {
	 opacity: 1;
	 transform: none;
}
 body.active .popup {
	 opacity: 1;
	 visibility: visible;
}
 body.active .popup-inside {
	 border-radius: 0;
	 box-shadow: -50px 0 200px -50px #e1e0ff, 50px 0 200px -50px #a972e8;
}
 body.active .background {
	 transform: scale(1);
}
 body.active .background6 {
	 transform: scale(8);
}
    
    
   [data-theme="dark"] .color {
	 background: linear-gradient(to right,#a972e8,#f078dc);
}
 [data-theme="dark"] .try-again {
	 cursor: pointer;
	 position: relative;
	 font-size: 16px;
}
 [data-theme="dark"] .try-again:after {
	 content: '';
	 position: absolute;
	 left: 15px;
	 right: 15px;
	 height: 1px;
	 top: 100%;
	 background: #606060;
	 margin-top: 8px;
	 transition: all 0.3s ease;
}
 [data-theme="dark"] .try-again:hover:after {
	 left: 40%;
	 right: 40%;
}
 [data-theme="dark"] .wrapper {
	 position: absolute;
	 top: 0;
	 width: 100%;
	 height: 100%;
	 display: flex;
	 align-items: center;
	 justify-content: center;
}
 [data-theme="dark"] .popup {
   z-index: 130;
	 opacity: 0;
	 visibility: hidden;
	 height: 400px;
	 width: 400px;
	 flex-shrink: 0;
	 border-radius: 3px;
	 position: relative;
   top:-100px;
	 display: flex;

	 transition: all 0.2s ease;
}
 [data-theme="dark"] .popup-inside {
	 position: absolute;
	 left: 0;
	 top: 0;
	 height: 100%;
	 width: 100%;
	 overflow: hidden;
	 border-radius: 50%;
	 box-shadow: 0 0 0 black;
	 transition: box-shadow 0.5s ease 0.7s, border-radius 0.35s ease 0.7s;
}
 [data-theme="dark"] .backgrounds {
	 position: absolute;
	 left: 0;
	 top: 0;
	 height: 100%;
	 width: 100%;
	 overflow: hidden;
}
 [data-theme="dark"] .background {
	 --offset: 0;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 transform: scale(0);
	 transition: all 0.5s ease 0s;
	 border-radius: 50%;
}
 [data-theme="dark"] .background2 {
	 --offset: 10%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 transform: scale(0);
	 transition: all 0.5s ease 0.1s;
}
 [data-theme="dark"] .background3 {
	 --offset: 20%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 2;
	 transition: all 0.5s ease 0.2s;
}
 [data-theme="dark"] .background4 {
	 --offset: 30%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 3;
	 transition: all 0.5s ease 0.3s;
}
 [data-theme="dark"] .background5 {
	 --offset: 40%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: linear-gradient(to right,#e1e0ff50,#a972e850);
	 z-index: 4;
	 transition: all 0.5s ease 0.4s;
}
 [data-theme="dark"] .background6 {
	 --offset: 40%;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 background: #505050;
	 z-index: 5;
	 transition: all 0.8s ease 0.4s;
}
 [data-theme="dark"] .contenttell {
	 --offset: 0;
	 position: absolute;
	 left: var(--offset);
	 right: var(--offset);
	 bottom: var(--offset);
	 top: var(--offset);
	 display: flex;
	 opacity: 0;
	 transition: all 0.35s ease 0.75s;
   overflow: hidden;
	 z-index: 10;
   background: #404040;
}
 [data-theme="dark"] body.active .contenttell {
	 opacity: 1;
	 transform: none;
}
 [data-theme="dark"] body.active .popup {
	 opacity: 1;
	 visibility: visible;
}
 [data-theme="dark"] body.active .popup-inside {
	 border-radius: 0;
	 box-shadow: -50px 0 200px -50px #505050, 50px 0 200px -50px #202020;
}
[data-theme="dark"] body.active .background {
	 transform: scale(1);
}
 [data-theme="dark"] body.active .background6 {
	 transform: scale(8);
}
	</style>
<div class="contenttell">
<div class="contenttell-wrapper">
  <h3 style="position: absolute;top: 0; left: 0; right: 0;">Update name</h3>
  <h6 style="position: absolute;top: 30px; left: 0; right: 0;">Version: <b>#.#.#</b> ---- | <span style="color:gold;">State</span></h6>
<hr>
  <p style="position: absolute;top: 80px; left: 20px;"><b>Added:</b></p>
  <p style="position: absolute;top: 100px; left: 20px;">- item<br>- item</p>
  
  <p style="position: absolute;top: 80px; right: 120px;"><b>Removed:</b></p>
  <p style="position: absolute;top: 100px; right: 20px;">- item<br>- item</p>
  
  <p style="position: absolute;top: 240px; left: 20px;"><b>Changed:</b></p>
  <p style="position: absolute;top: 260px; left: 20px;">- item<br>- item</p>
  
  <p style="position: absolute;top: 240px; right: 115px;"><b>New Bugs:</b></p>
  <p style="position: absolute;top: 260px; right: 20px;">- item<br>- item</p>
<p style="position: absolute;bottom: 15px; left: 0; right: 0;" class="try-again" onclick="document.body.classList.remove('active')">Close</p>
</div>
</div>
</div>
</div>
</body>
  
  
  <div class="btns">
    <button style="z-index:100;position: relative;" onclick="document.body.classList.add('active')" class="btn btn--primary">Version: BETA 1.3.8</button>
    <button style="z-index:100;position: relative; color:red" class="btn">Un-Stable</button>
  </div>
  <div style="z-index:100;position: relative;top:-40px;" class="hill">
</div>

</header>
      <script>

var darkSwitch = document.getElementById("darkSwitch");
window.addEventListener("load", function () {
  if (darkSwitch) {
    initTheme();
    darkSwitch.addEventListener("change", function () {
      resetTheme();
    });
  }
});

/**
 * Summary: function that adds or removes the attribute 'data-theme' depending if
 * the switch is 'on' or 'off'.
 *
 * Description: initTheme is a function that uses localStorage from JavaScript DOM,
 * to store the value of the HTML switch. If the switch was already switched to
 * 'on' it will set an HTML attribute to the body named: 'data-theme' to a 'dark'
 * value. If it is the first time opening the page, or if the switch was off the
 * 'data-theme' attribute will not be set.
 * @return {void}
 */
function initTheme() {
  var darkThemeSelected =
    localStorage.getItem("darkSwitch") !== null &&
    localStorage.getItem("darkSwitch") === "dark";
  darkSwitch.checked = darkThemeSelected;
  darkThemeSelected
    ? document.body.setAttribute("data-theme", "dark")
    : document.body.removeAttribute("data-theme");
}

/**
 * Summary: resetTheme checks if the switch is 'on' or 'off' and if it is toggled
 * on it will set the HTML attribute 'data-theme' to dark so the dark-theme CSS is
 * applied.
 * @return {void}
 */
function resetTheme() {
  if (darkSwitch.checked) {
    document.body.setAttribute("data-theme", "dark");
    localStorage.setItem("darkSwitch", "dark");
  } else {
    document.body.removeAttribute("data-theme");
    localStorage.removeItem("darkSwitch");
  }
}
</script>
  <!-- IE 11 polyfill for CSS and Custom Properties -->
  <script
    nomodule>window.MSInputMethodContext && document.documentMode && document.write('<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-ie11@5/css/bootstrap-ie11.min.css"><script src="https://cdn.jsdelivr.net/npm/ie11-custom-properties@4/ie11CustomProperties.min.js"><\/script>');</script>
<script>
/*!
 * Dark Mode Switch v1.0.1 (https://github.com/coliff/dark-mode-switch)
 * Copyright 2021 C.Oliff
 * Licensed under MIT (https://github.com/coliff/dark-mode-switch/blob/main/LICENSE)
 */
var darkSwitch=document.getElementById("darkSwitch");window.addEventListener("load",(function(){if(darkSwitch){initTheme();darkSwitch.addEventListener("change",(function(){resetTheme()}))}}));function initTheme(){var darkThemeSelected=localStorage.getItem("darkSwitch")!==null&&localStorage.getItem("darkSwitch")==="dark";darkSwitch.checked=darkThemeSelected;darkThemeSelected?document.body.setAttribute("data-theme","dark"):document.body.removeAttribute("data-theme")}function resetTheme(){if(darkSwitch.checked){document.body.setAttribute("data-theme","dark");localStorage.setItem("darkSwitch","dark")}else{document.body.removeAttribute("data-theme");localStorage.removeItem("darkSwitch")}}
</script>
</div></section></body></html></div></div></div></div></div></div></div>
<script>
function typeWriter() { document.querySelector('.cont_principal').className= "cont_principal cont_error_active";  
}
</script>
<div class="cont_principal">
<div class="cont_error">
  </div>
  <div style="position: relative; left: 140px;z-index: 9999;">
    <h3>Koil:</h3>
  </div>
    <div style="position: relative; left: 60px;z-index: 9999;">
     <style>
  .ccards-list {
  z-index: 0;
  width: 100%;
  display: flex;
  justify-content: space-around;
  flex-wrap: wrap;
}

.ccard {
  margin: 30px auto;
  width: 210px;
  height: 210px;
  border-radius: 40px;
box-shadow: 5px 5px 30px 7px rgba(0,0,0,0.25), -5px -5px 30px 7px rgba(0,0,0,0.22);
  cursor: pointer;
  transition: 0.4s;
}

.ccard .ccard_image {
  width: inherit;
  height: inherit;
  border-radius: 40px;
}

.ccard .ccard_image img {
  width: inherit;
  height: inherit;
  border-radius: 10px;
  object-fit: cover;
}

.ccard .ccard_title {
  text-align: center;
  border-radius: 0px 0px 40px 40px;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 30px;
  margin-top: -80px;
  height: 40px;
}

.ccard:hover {
  transform: scale(0.9, 0.9);
  box-shadow: 5px 5px 30px 15px rgba(0,0,0,0.25), 
    -5px -5px 30px 15px rgba(0,0,0,0.22);
}

@media all and (max-width: 500px) {
  .ccard-list {
    /* On small screens, we are no longer using row direction but column */
    flex-direction: column;
  }
}


/*
.card {
  margin: 30px auto;
  width: 300px;
  height: 300px;
  border-radius: 40px;
  background-image: url('https://i.redd.it/b3esnz5ra34y.jpg');
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center;
  background-repeat: no-repeat;
box-shadow: 5px 5px 30px 7px rgba(0,0,0,0.25), -5px -5px 30px 7px rgba(0,0,0,0.22);
  transition: 0.4s;
}
*/
</style>
<div class="ccards-list">
  
<a href="koil/api.html" ><div class="ccard 1">
  <div class="ccard_image"> <img src="https://github.com/SpiritXIV/Koil/blob/main/koilapi.png?raw=true" /> </div>
  <div class="card_title">
  </div>
  </div></a>

  <a href="koil/fabric.html" ><div class="ccard 2">
  <div class="ccard_image">
    <img src="https://fabrickoil.github.io/Fabrickoil-Website/fabric.png" />
    </div>
  <div class="ccard_title">
  </div>
    </div></a>

<a href="koil/forge.html" ><div class="ccard 3">
  <div class="ccard_image">
    <img src="https://forgekoil.github.io/Forgekoil-Website/forge.png" />
  </div>
  <div class="ccard_title">
  </div>
  </div></a>
  
  <a href="koil/quilt.html" ><div class="ccard 4">
  <div class="ccard_image">
    <img src="https://quiltkoil.github.io/Quiltkoil-Website/quilt.png" />
    </div>
  <div class="ccard_title">
  </div>
    </div></a>
    </div>
</div>
      <div style="position: relative; left: 100px;z-index: 9999;">
    <br>
           <style>
[data-theme="dark"] .container{
  position: absolute;
  width: 90%;
	height: 100%;  
  display: flex;
  justify-content: space-between;
  flex-wrap:wrap;
  
}

[data-theme="dark"] .container .card{
  position:relative;
  left: 0px;
  right: 0px;
}

[data-theme="dark"] .container .card .face{
  width:300px;
  height: 200px;
  transition:.4s;
  
}

[data-theme="dark"] .container .card .face.face1{
  position: relative;
  left: 0px;
  right: 0px;
  background: #333;
  display: flex;
  justify-content: center;
  align-content:center;
  align-items: center;
  z-index: 1;
  transform: translateY(100px);
}

[data-theme="dark"] .container .card:hover .face.face1{
  transform: translateY(0);
  box-shadow:
    inset 0 0 60px whitesmoke,
    inset 20px 0 80px #f0f,
    inset -20px 0 80px #0ff,
    inset 20px 0 300px #f0f,
    inset -20px 0 300px #0ff,
    0 0 50px #fff,
    -10px 0 80px #f0f,
    10px 0 80px #0ff;
   
}


[data-theme="dark"] .container .card .face.face1 .content{
  opacity: .2;
  transition:  0.5s;
  text-align: center;
}

[data-theme="dark"] .container .card:hover .face.face1 .content{
  opacity: 1;
 
}

[data-theme="dark"] .container .card .face.face1 .content i{
  font-size: 3em;
  color: white;
  display: inline-block;
   
}

[data-theme="dark"] .container .card .face.face1 .content h3{
  font-size: 1em;
  color: white;
  text-align: center;
  

}

[data-theme="dark"] .container .card .face.face1 .content a{
   transition: .5s;
}

[data-theme="dark"] .container .card .face.face2{
   position: relative;
   background: #404040;
   display: flex;
   align-items: center;
   justify-content: center;
   padding: 20px;
  box-sizing: border-box;
  box-shadow: 0 20px 50px rgba(0,0,0,.8);
  transform: translateY(-100px);
}

[data-theme="dark"] .container .card:hover .face.face2{
    transform: translateY(0);


}

[data-theme="dark"] .container .card .face.face2 .content p, a{
  font-size: 10pt;
  margin: 0 ;
  padding: 0;
  color:#fff;
}

[data-theme="dark"] .container .card .face.face2 .content a{
  text-decoration:none;
  color: white;
  box-sizing: border-box;
  outline : 1px dashed white;
  padding: 10px;
  margin: 15px 0 0;
  display: inline-block;
}

[data-theme="dark"] .container .card .face.face2 .content a:hover{
  background: #333 ;
  color: whitesmoke; 
  box-shadow: inset 0px 0px 10px rgba(0,0,0,0.5);
}
[data-theme="dark"] .editorial {
  display: block;
  width: 100%;
  height: 60px;
  max-height: 60px;
  margin: 0;
  z-index:5;
  bottom:0;
  position:absolute;
  left:-40.5px;
  top:1000px;
  float:left;
}

.container{
  position: absolute;
  width: 90%;
	height: 100%;  
  display: flex;
  justify-content: space-between;
  flex-wrap:wrap;
  
}

.container .card{
  position:relative;
  left: 0px;
  right: 0px;
}

.container .card .face{
  width:300px;
  height: 200px;
  transition:.4s;
  
}

.container .card .face.face1{
  position: relative;
  left: 0px;
  right: 0px;
  background: #808080;
  display: flex;
  justify-content: center;
  align-content:center;
  align-items: center;
  z-index: 1;
  transform: translateY(100px);
}

.container .card:hover .face.face1{
  transform: translateY(0);
  box-shadow:
    inset 0 0 60px whitesmoke,
    inset 20px 0 80px #f0f,
    inset -20px 0 80px #0ff,
    inset 20px 0 300px #f0f,
    inset -20px 0 300px #0ff,
    0 0 50px #fff,
    -10px 0 80px #f0f,
    10px 0 80px #0ff;
   
}


.container .card .face.face1 .content{
  opacity: .2;
  transition:  0.5s;
  text-align: center;
}

.container .card:hover .face.face1 .content{
  opacity: 1;
 
}

.container .card .face.face1 .content i{
  font-size: 3em;
  color: black;
  display: inline-block;
   
}

.container .card .face.face1 .content h3{
  font-size: 1em;
  color: black;
  text-align: center;
  

}

.container .card .face.face1 .content a{
   transition: .5s;
}

.container .card .face.face2{
   position: relative;
   background: whitesmoke;
   display: flex;
   align-items: center;
   justify-content: center;
   padding: 20px;
  box-sizing: border-box;
  box-shadow: 0 20px 50px rgba(0,0,0,.8);
  transform: translateY(-100px);
}

.container .card:hover .face.face2{
    transform: translateY(0);


}

.container .card .face.face2 .content p, a{
  font-size: 10pt;
  margin: 0 ;
  padding: 0;
  color:#333;
}

.container .card .face.face2 .content a{
  text-decoration:none;
  color: black;
  box-sizing: border-box;
  outline : 1px dashed #333;
  padding: 10px;
  margin: 15px 0 0;
  display: inline-block;
}

.container .card .face.face2 .content a:hover{
  background: #888 ;
  color: whitesmoke; 
  box-shadow: inset 0px 0px 10px rgba(0,0,0,0.5);
}
.editorial {
  display: block;
  width: 100%;
  height: 60px;
  max-height: 60px;
  margin: 0;
  z-index:5;
  bottom:0;
  position:absolute;
  left:-40.5px;
  top:1000px;
  float:left;
}

.parallax1 > use {
  animation: move-forever1 10s linear infinite;
  &:nth-child(1) {
    animation-delay: -2s;
  }
}
.parallax2 > use {
  animation: move-forever2 8s linear infinite;
  &:nth-child(1) {
    animation-delay: -2s;
  }
}
.parallax3 > use {
  animation: move-forever3 6s linear infinite;
  &:nth-child(1) {
    animation-delay: -2s;
  }
}
.parallax4 > use {
  animation: move-forever4 4s linear infinite;
  &:nth-child(1) {
    animation-delay: -2s;
  }
}
@keyframes move-forever1 {
  0% {
    transform: translate(85px, 0%);
  }
  100% {
    transform: translate(-90px, 0%);
  }
}
@keyframes move-forever2 {
  0% {
    transform: translate(-90px, 0%);
  }
  100% {
    transform: translate(85px, 0%);
  }
}
@keyframes move-forever3 {
  0% {
    transform: translate(85px, 0%);
  }
  100% {
    transform: translate(-90px, 0%);
  }
}
@keyframes move-forever4 {
  0% {
    transform: translate(-90px, 0%);
  }
  100% {
    transform: translate(85px, 0%);
  }
}

 </style>
        <div data-visible-from="12-30" data-visible-to="01-01"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/firework1.png?raw=true" alt="firework1.png"/></div>
        <div data-visible-from="01-02" data-visible-to="02-13"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div> 
        <div data-visible-from="02-14" data-visible-to="02-14"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/heart1.png?raw=true"/></div> 
        <div data-visible-from="02-15" data-visible-to="03-24"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div> 
        <div data-visible-from="03-25" data-visible-to="04-20"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/easteregg1.png?raw=true"/></div> 
        <div data-visible-from="04-21" data-visible-to="07-03"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
        <div data-visible-from="07-04" data-visible-to="07-04"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/fireworkstal1.png?raw=true"/></div>
        <div data-visible-from="07-05" data-visible-to="10-29"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
        <div data-visible-from="10-30" data-visible-to="10-31"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/pumpkin1.png?raw=true"/></div>
        <div data-visible-from="11-01" data-visible-to="11-07"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
        <div data-visible-from="11-08" data-visible-to="11-31"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/leaf1.png?raw=true"/></div>
        <div data-visible-from="12-01" data-visible-to="12-19"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
        <div data-visible-from="12-20" data-visible-to="12-27"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/candycane1.png?raw=true"/></div>
        <div data-visible-from="12-28" data-visible-to="12-29"><img style="z-index:-1000;position: relative;top:10px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
  <div style="position: relative;top:-250px" class="container">
     <div class="card">
       <div class="face face1">
         <div class="content">
            <i class='bx bx-collection' ></i>      
            
           <h3>Vaitic Main</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>The main things to do with the website, that being info, help, and more.</p>
           <a href="main.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>
         </div>
       </div>
    </div>
    
<div class="card">
       <div class="face face1">
         <div class="content">
           <i class="fas fa-tools"></i>
            <h3>Utilities</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Things that can be helpfun, fun or useful depending on what you chose.</p>
           <a href="utilities.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
    
    
    <div class="card">
       <div class="face face1">
         <div class="content">
            <i class='far fa-chart-bar' ></i>
            <h3>Information</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Information on your device, the browser and soon to be more.</p>
           <a href="infomation.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
    
    
   <div class="card">
       <div class="face face1">
         <div class="content">
           <i class="fas fa-clock"></i>
            <h3>Viatic Labs</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Official projects that is going to be used for future things.</p>
           <a href="labs.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
    
        <div class="card">
       <div class="face face1">
         <div class="content">
           <i class="fas fa-pen-alt"></i>
            <h3>Web Designs</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Labs, or creations that are still in dev, that let you play with them while they are being made.</p>
           <a href="webdesigns.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
     
     <div class="card">
       <div class="face face1">
         <div class="content">
           <i class="fas fa-ring"></i>
            <h3>Extra Designs</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Extra designs that could be fun to play with, or have something cool with it.</p>
           <a href="extradesigns.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
        
    <div class="card">
       <div class="face face1">
         <div class="content">
           <i class="fas fa-cog"></i>
            <h3>Settings</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p>Adjust the way the website works by the provided options.</p>
           <a href="settings.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
    </div>
    <div class="card">
       <div class="face face1">
         <div class="content">
            <i class='	fas fa-info' ></i>      
           <h3>About</h3>
         </div>
       </div>
       <div class="face face2">
         <div class="content">
           <p> Information on who made the website, their contact info, what the future plans are and more</p>
           <a href="about.html" type="btn">Continue  <i style='font-size:14px' class='fas'>&#xf061;</i>
</a>         </div>
       </div>
           <div data-visible-from="12-30" data-visible-to="01-01"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/firework2.png?raw=true" alt="firework2.png"/></div>
           <div data-visible-from="01-02" data-visible-to="02-13"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="02-14" data-visible-to="02-14"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/heart2.png?raw=true"/></div>
           <div data-visible-from="02-15" data-visible-to="03-24"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="03-25" data-visible-to="04-20"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/easteregg2.png?raw=true"/></div>
           <div data-visible-from="04-21" data-visible-to="07-03"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="07-04" data-visible-to="07-04"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/fireworkstal2.png?raw=true"/></div>
           <div data-visible-from="07-05" data-visible-to="10-29"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="10-30" data-visible-to="10-31"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/spider1.png?raw=true"/></div>
           <div data-visible-from="11-01" data-visible-to="11-07"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="11-08" data-visible-to="11-31"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/leaf2.png?raw=true"/></div>
           <div data-visible-from="12-01" data-visible-to="12-19"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
           <div data-visible-from="11-08" data-visible-to="11-31"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/candycane2.png?raw=true"/></div>
           <div data-visible-from="12-28" data-visible-to="12-29"><img style="z-index:-1000;position: relative;top:-100px" src="https://github.com/spitriziv/Viatic/blob/main/www/image/event/blank.png?raw=true"/></div>
</div>
  </div>
  </div>
<div class="cont_aura_1"></div>
<div class="cont_aura_2"></div>
</div>

<style>
html{
}

.cont_principal {
position: absolute;  
top: 540px;
width: 100%;
height: 300%;
overflow: hidden;
background: #fff;
color: black;
}

[data-theme="dark"] .cont_principal {
background: #404040;
color: white;
}


.cont_aura_1 {
  position:absolute;
  width:300px;
  height: 120%;
top:25px;
right: -340px;
  background-color: #e179e8;
box-shadow: 0px 0px  60px  20px  rgba(225, 156, 230,0.5);
-webkit-transition: all 0.5s;
  transition: all 0.5s;
}

.cont_aura_2 {
  position:absolute;
  width:100%;
  height: 300px;
right:-10%;
bottom:-301px;
 background-color: #e06be8;
box-shadow: 0px 0px 60px 10px rgba(225, 156, 230, 0.5),0px 0px  20px  0px  rgba(0,0,0,0.1);
  z-index:5;
transition: all 0.5s;
-webkit-transition: all 0.5s;
}


.cont_error_active > .cont_aura_2 {
    animation-name: animation_error_2;
    animation-duration: 4s;
  animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-direction: alternate;
transform: rotate(-20deg);    
}
.cont_error_active > .cont_aura_1 {
 transform: rotate(20deg);
  right:-170px;
    animation-name: animation_error_1;
    animation-duration: 4s;
  animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-direction: alternate;
}

@-webkit-keyframes animation_error_1 {
  from {
    -webkit-transform: rotate(20deg);
  transform: rotate(20deg);
  }
  to {  -webkit-transform: rotate(25deg);
  transform: rotate(25deg);
  }
}
@-o-keyframes animation_error_1 {
  from {
    -webkit-transform: rotate(20deg);
  transform: rotate(20deg);
  }
  to {  -webkit-transform: rotate(25deg);
  transform: rotate(25deg);
  }

}
@-moz-keyframes animation_error_1 {
  from {
    -webkit-transform: rotate(20deg);
  transform: rotate(20deg);
  }
  to {  -webkit-transform: rotate(25deg);
  transform: rotate(25deg);
  }

}
@keyframes animation_error_1 {
  from {
    -webkit-transform: rotate(20deg);
  transform: rotate(20deg);
  }
  to {  -webkit-transform: rotate(25deg);
  transform: rotate(25deg);
  }
}




@-webkit-keyframes animation_error_2 {
  from { -webkit-transform: rotate(-15deg); 
  transform: rotate(-15deg);
  }
  to { -webkit-transform: rotate(-20deg);
  transform: rotate(-20deg);
  }
}
@-o-keyframes animation_error_2 {
  from { -webkit-transform: rotate(-15deg); 
  transform: rotate(-15deg);
  }
  to { -webkit-transform: rotate(-20deg);
  transform: rotate(-20deg);
  }
}
}
@-moz-keyframes animation_error_2 {
  from { -webkit-transform: rotate(-15deg); 
  transform: rotate(-15deg);
  }
  to { -webkit-transform: rotate(-20deg);
  transform: rotate(-20deg);
  }
}
@keyframes animation_error_2 {
  from { -webkit-transform: rotate(-15deg); 
  transform: rotate(-15deg);
  }
  to { -webkit-transform: rotate(-20deg);
  transform: rotate(-20deg);
  }
}
</style>
<body data-visible-from="01-01" data-visible-to="12-31"></body>
<script>
  var md = (new Date()).toISOString().substring(5, 10);
[].slice.call(document.querySelectorAll("[data-visible-from],[data-visible-to]")).forEach(function(el) {
  var from = el.dataset.visibleFrom || "01-01";
  var to = el.dataset.visibleTo || "12-31";
  el.style.display = (from <= md && md <= to ? "" : "none");
});
</script>
<script>
  var snowStorm = (function(window, document) {

  // --- common properties ---

  this.autoStart = true;          // Whether the snow should start automatically or not.
  this.excludeMobile = true;      // Snow is likely to be bad news for mobile phones' CPUs (and batteries.) Enable at your own risk.
  this.flakesMax = 128;           // Limit total amount of snow made (falling + sticking)
  this.flakesMaxActive = 64;      // Limit amount of snow falling at once (less = lower CPU use)
  this.animationInterval = 50;    // Theoretical "miliseconds per frame" measurement. 20 = fast + smooth, but high CPU use. 50 = more conservative, but slower
  this.useGPU = true;             // Enable transform-based hardware acceleration, reduce CPU load.
  this.className = null;          // CSS class name for further customization on snow elements
  this.excludeMobile = true;      // Snow is likely to be bad news for mobile phones' CPUs (and batteries.) By default, be nice.
  this.flakeBottom = null;        // Integer for Y axis snow limit, 0 or null for "full-screen" snow effect
  this.followMouse = false;        // Snow movement can respond to the user's mouse
  this.snowColor = '#fff';        // Don't eat (or use?) yellow snow.
  this.snowCharacter = '&bull;';  // &bull; = bullet, &middot; is square on some systems etc.
  this.snowStick = false;          // Whether or not snow should "stick" at the bottom. When off, will never collect.
  this.targetElement = settonullondecember;      // element which snow will be appended to (null = document.body) - can be an element ID eg. 'myDiv', or a DOM node reference
  this.useMeltEffect = true;      // When recycling fallen snow (or rarely, when falling), have it "melt" and fade out if browser supports it
  this.useTwinkleEffect = true;  // Allow snow to randomly "flicker" in and out of view while falling
  this.usePositionFixed = false;  // true = snow does not shift vertically when scrolling. May increase CPU load, disabled by default - if enabled, used only where supported
  this.usePixelPosition = false;  // Whether to use pixel values for snow top/left vs. percentages. Auto-enabled if body is position:relative or targetElement is specified.

  // --- less-used bits ---

  this.freezeOnBlur = true;       // Only snow when the window is in focus (foreground.) Saves CPU.
  this.flakeLeftOffset = 0;       // Left margin/gutter space on edge of container (eg. browser window.) Bump up these values if seeing horizontal scrollbars.
  this.flakeRightOffset = 0;      // Right margin/gutter space on edge of container
  this.flakeWidth = 8;            // Max pixel width reserved for snow element
  this.flakeHeight = 8;           // Max pixel height reserved for snow element
  this.vMaxX = 5;                 // Maximum X velocity range for snow
  this.vMaxY = 4;                 // Maximum Y velocity range for snow
  this.zIndex = 0;                // CSS stacking order applied to each snowflake

  // --- "No user-serviceable parts inside" past this point, yadda yadda ---

  var storm = this,
  features,
  // UA sniffing and backCompat rendering mode checks for fixed position, etc.
  isIE = navigator.userAgent.match(/msie/i),
  isIE6 = navigator.userAgent.match(/msie 6/i),
  isMobile = navigator.userAgent.match(/mobile|opera m(ob|in)/i),
  isBackCompatIE = (isIE && document.compatMode === 'BackCompat'),
  noFixed = (isBackCompatIE || isIE6),
  screenX = null, screenX2 = null, screenY = null, scrollY = null, docHeight = null, vRndX = null, vRndY = null,
  windOffset = 1,
  windMultiplier = 2,
  flakeTypes = 6,
  fixedForEverything = false,
  targetElementIsRelative = false,
  opacitySupported = (function(){
    try {
      document.createElement('div').style.opacity = '0.5';
    } catch(e) {
      return false;
    }
    return true;
  }()),
  didInit = false,
  docFrag = document.createDocumentFragment();

  features = (function() {

    var getAnimationFrame;

    /**
     * hat tip: paul irish
     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
     * https://gist.github.com/838785
     */

    function timeoutShim(callback) {
      window.setTimeout(callback, 1000/(storm.animationInterval || 20));
    }

    var _animationFrame = (window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        timeoutShim);

    // apply to window, avoid "illegal invocation" errors in Chrome
    getAnimationFrame = _animationFrame ? function() {
      return _animationFrame.apply(window, arguments);
    } : null;

    var testDiv;

    testDiv = document.createElement('div');

    function has(prop) {

      // test for feature support
      var result = testDiv.style[prop];
      return (result !== undefined ? prop : null);

    }

    // note local scope.
    var localFeatures = {

      transform: {
        ie:  has('-ms-transform'),
        moz: has('MozTransform'),
        opera: has('OTransform'),
        webkit: has('webkitTransform'),
        w3: has('transform'),
        prop: null // the normalized property value
      },

      getAnimationFrame: getAnimationFrame

    };

    localFeatures.transform.prop = (
      localFeatures.transform.w3 || 
      localFeatures.transform.moz ||
      localFeatures.transform.webkit ||
      localFeatures.transform.ie ||
      localFeatures.transform.opera
    );

    testDiv = null;

    return localFeatures;

  }());

  this.timer = null;
  this.flakes = [];
  this.disabled = false;
  this.active = false;
  this.meltFrameCount = 20;
  this.meltFrames = [];

  this.setXY = function(o, x, y) {

    if (!o) {
      return false;
    }

    if (storm.usePixelPosition || targetElementIsRelative) {

      o.style.left = (x - storm.flakeWidth) + 'px';
      o.style.top = (y - storm.flakeHeight) + 'px';

    } else if (noFixed) {

      o.style.right = (100-(x/screenX*100)) + '%';
      // avoid creating vertical scrollbars
      o.style.top = (Math.min(y, docHeight-storm.flakeHeight)) + 'px';

    } else {

      if (!storm.flakeBottom) {

        // if not using a fixed bottom coordinate...
        o.style.right = (100-(x/screenX*100)) + '%';
        o.style.bottom = (100-(y/screenY*100)) + '%';

      } else {

        // absolute top.
        o.style.right = (100-(x/screenX*100)) + '%';
        o.style.top = (Math.min(y, docHeight-storm.flakeHeight)) + 'px';

      }

    }

  };

  this.events = (function() {

    var old = (!window.addEventListener && window.attachEvent), slice = Array.prototype.slice,
    evt = {
      add: (old?'attachEvent':'addEventListener'),
      remove: (old?'detachEvent':'removeEventListener')
    };

    function getArgs(oArgs) {
      var args = slice.call(oArgs), len = args.length;
      if (old) {
        args[1] = 'on' + args[1]; // prefix
        if (len > 3) {
          args.pop(); // no capture
        }
      } else if (len === 3) {
        args.push(false);
      }
      return args;
    }

    function apply(args, sType) {
      var element = args.shift(),
          method = [evt[sType]];
      if (old) {
        element[method](args[0], args[1]);
      } else {
        element[method].apply(element, args);
      }
    }

    function addEvent() {
      apply(getArgs(arguments), 'add');
    }

    function removeEvent() {
      apply(getArgs(arguments), 'remove');
    }

    return {
      add: addEvent,
      remove: removeEvent
    };

  }());

  function rnd(n,min) {
    if (isNaN(min)) {
      min = 0;
    }
    return (Math.random()*n)+min;
  }

  function plusMinus(n) {
    return (parseInt(rnd(2),10)===1?n*-1:n);
  }

  this.randomizeWind = function() {
    var i;
    vRndX = plusMinus(rnd(storm.vMaxX,0.2));
    vRndY = rnd(storm.vMaxY,0.2);
    if (this.flakes) {
      for (i=0; i<this.flakes.length; i++) {
        if (this.flakes[i].active) {
          this.flakes[i].setVelocities();
        }
      }
    }
  };

  this.scrollHandler = function() {
    var i;
    // "attach" snowflakes to bottom of window if no absolute bottom value was given
    scrollY = (storm.flakeBottom ? 0 : parseInt(window.scrollY || document.documentElement.scrollTop || (noFixed ? document.body.scrollTop : 0), 10));
    if (isNaN(scrollY)) {
      scrollY = 0; // Netscape 6 scroll fix
    }
    if (!fixedForEverything && !storm.flakeBottom && storm.flakes) {
      for (i=0; i<storm.flakes.length; i++) {
        if (storm.flakes[i].active === 0) {
          storm.flakes[i].stick();
        }
      }
    }
  };

  this.resizeHandler = function() {
    if (window.innerWidth || window.innerHeight) {
      screenX = window.innerWidth - 16 - storm.flakeRightOffset;
      screenY = (storm.flakeBottom || window.innerHeight);
    } else {
      screenX = (document.documentElement.clientWidth || document.body.clientWidth || document.body.scrollWidth) - (!isIE ? 8 : 0) - storm.flakeRightOffset;
      screenY = storm.flakeBottom || document.documentElement.clientHeight || document.body.clientHeight || document.body.scrollHeight;
    }
    docHeight = document.body.offsetHeight;
    screenX2 = parseInt(screenX/2,10);
  };

  this.resizeHandlerAlt = function() {
    screenX = storm.targetElement.offsetWidth - storm.flakeRightOffset;
    screenY = storm.flakeBottom || storm.targetElement.offsetHeight;
    screenX2 = parseInt(screenX/2,10);
    docHeight = document.body.offsetHeight;
  };

  this.freeze = function() {
    // pause animation
    if (!storm.disabled) {
      storm.disabled = 1;
    } else {
      return false;
    }
    storm.timer = null;
  };

  this.resume = function() {
    if (storm.disabled) {
       storm.disabled = 0;
    } else {
      return false;
    }
    storm.timerInit();
  };

  this.toggleSnow = function() {
    if (!storm.flakes.length) {
      // first run
      storm.start();
    } else {
      storm.active = !storm.active;
      if (storm.active) {
        storm.show();
        storm.resume();
      } else {
        storm.stop();
        storm.freeze();
      }
    }
  };

  this.stop = function() {
    var i;
    this.freeze();
    for (i=0; i<this.flakes.length; i++) {
      this.flakes[i].o.style.display = 'none';
    }
    storm.events.remove(window,'scroll',storm.scrollHandler);
    storm.events.remove(window,'resize',storm.resizeHandler);
    if (storm.freezeOnBlur) {
      if (isIE) {
        storm.events.remove(document,'focusout',storm.freeze);
        storm.events.remove(document,'focusin',storm.resume);
      } else {
        storm.events.remove(window,'blur',storm.freeze);
        storm.events.remove(window,'focus',storm.resume);
      }
    }
  };

  this.show = function() {
    var i;
    for (i=0; i<this.flakes.length; i++) {
      this.flakes[i].o.style.display = 'block';
    }
  };

  this.SnowFlake = function(type,x,y) {
    var s = this;
    this.type = type;
    this.x = x||parseInt(rnd(screenX-20),10);
    this.y = (!isNaN(y)?y:-rnd(screenY)-12);
    this.vX = null;
    this.vY = null;
    this.vAmpTypes = [1,1.2,1.4,1.6,1.8]; // "amplification" for vX/vY (based on flake size/type)
    this.vAmp = this.vAmpTypes[this.type] || 1;
    this.melting = false;
    this.meltFrameCount = storm.meltFrameCount;
    this.meltFrames = storm.meltFrames;
    this.meltFrame = 0;
    this.twinkleFrame = 0;
    this.active = 1;
    this.fontSize = (10+(this.type/5)*10);
    this.o = document.createElement('div');
    this.o.innerHTML = storm.snowCharacter;
    if (storm.className) {
      this.o.setAttribute('class', storm.className);
    }
    this.o.style.color = storm.snowColor;
    this.o.style.position = (fixedForEverything?'fixed':'absolute');
    if (storm.useGPU && features.transform.prop) {
      // GPU-accelerated snow.
      this.o.style[features.transform.prop] = 'translate3d(0px, 0px, 0px)';
    }
    this.o.style.width = storm.flakeWidth+'px';
    this.o.style.height = storm.flakeHeight+'px';
    this.o.style.fontFamily = 'arial,verdana';
    this.o.style.cursor = 'default';
    this.o.style.overflow = 'hidden';
    this.o.style.fontWeight = 'normal';
    this.o.style.zIndex = storm.zIndex;
    docFrag.appendChild(this.o);

    this.refresh = function() {
      if (isNaN(s.x) || isNaN(s.y)) {
        // safety check
        return false;
      }
      storm.setXY(s.o, s.x, s.y);
    };

    this.stick = function() {
      if (noFixed || (storm.targetElement !== document.documentElement && storm.targetElement !== document.body)) {
        s.o.style.top = (screenY+scrollY-storm.flakeHeight)+'px';
      } else if (storm.flakeBottom) {
        s.o.style.top = storm.flakeBottom+'px';
      } else {
        s.o.style.display = 'none';
        s.o.style.bottom = '0%';
        s.o.style.position = 'fixed';
        s.o.style.display = 'block';
      }
    };

    this.vCheck = function() {
      if (s.vX>=0 && s.vX<0.2) {
        s.vX = 0.2;
      } else if (s.vX<0 && s.vX>-0.2) {
        s.vX = -0.2;
      }
      if (s.vY>=0 && s.vY<0.2) {
        s.vY = 0.2;
      }
    };

    this.move = function() {
      var vX = s.vX*windOffset, yDiff;
      s.x += vX;
      s.y += (s.vY*s.vAmp);
      if (s.x >= screenX || screenX-s.x < storm.flakeWidth) { // X-axis scroll check
        s.x = 0;
      } else if (vX < 0 && s.x-storm.flakeLeftOffset < -storm.flakeWidth) {
        s.x = screenX-storm.flakeWidth-1; // flakeWidth;
      }
      s.refresh();
      yDiff = screenY+scrollY-s.y+storm.flakeHeight;
      if (yDiff<storm.flakeHeight) {
        s.active = 0;
        if (storm.snowStick) {
          s.stick();
        } else {
          s.recycle();
        }
      } else {
        if (storm.useMeltEffect && s.active && s.type < 3 && !s.melting && Math.random()>0.998) {
          // ~1/1000 chance of melting mid-air, with each frame
          s.melting = true;
          s.melt();
          // only incrementally melt one frame
          // s.melting = false;
        }
        if (storm.useTwinkleEffect) {
          if (s.twinkleFrame < 0) {
            if (Math.random() > 0.97) {
              s.twinkleFrame = parseInt(Math.random() * 8, 10);
            }
          } else {
            s.twinkleFrame--;
            if (!opacitySupported) {
              s.o.style.visibility = (s.twinkleFrame && s.twinkleFrame % 2 === 0 ? 'hidden' : 'visible');
            } else {
              s.o.style.opacity = (s.twinkleFrame && s.twinkleFrame % 2 === 0 ? 0 : 1);
            }
          }
        }
      }
    };

    this.animate = function() {
      // main animation loop
      // move, check status, die etc.
      s.move();
    };

    this.setVelocities = function() {
      s.vX = vRndX+rnd(storm.vMaxX*0.12,0.1);
      s.vY = vRndY+rnd(storm.vMaxY*0.12,0.1);
    };

    this.setOpacity = function(o,opacity) {
      if (!opacitySupported) {
        return false;
      }
      o.style.opacity = opacity;
    };

    this.melt = function() {
      if (!storm.useMeltEffect || !s.melting) {
        s.recycle();
      } else {
        if (s.meltFrame < s.meltFrameCount) {
          s.setOpacity(s.o,s.meltFrames[s.meltFrame]);
          s.o.style.fontSize = s.fontSize-(s.fontSize*(s.meltFrame/s.meltFrameCount))+'px';
          s.o.style.lineHeight = storm.flakeHeight+2+(storm.flakeHeight*0.75*(s.meltFrame/s.meltFrameCount))+'px';
          s.meltFrame++;
        } else {
          s.recycle();
        }
      }
    };

    this.recycle = function() {
      s.o.style.display = 'none';
      s.o.style.position = (fixedForEverything?'fixed':'absolute');
      s.o.style.bottom = 'auto';
      s.setVelocities();
      s.vCheck();
      s.meltFrame = 0;
      s.melting = false;
      s.setOpacity(s.o,1);
      s.o.style.padding = '0px';
      s.o.style.margin = '0px';
      s.o.style.fontSize = s.fontSize+'px';
      s.o.style.lineHeight = (storm.flakeHeight+2)+'px';
      s.o.style.textAlign = 'center';
      s.o.style.verticalAlign = 'baseline';
      s.x = parseInt(rnd(screenX-storm.flakeWidth-20),10);
      s.y = parseInt(rnd(screenY)*-1,10)-storm.flakeHeight;
      s.refresh();
      s.o.style.display = 'block';
      s.active = 1;
    };

    this.recycle(); // set up x/y coords etc.
    this.refresh();

  };

  this.snow = function() {
    var active = 0, flake = null, i, j;
    for (i=0, j=storm.flakes.length; i<j; i++) {
      if (storm.flakes[i].active === 1) {
        storm.flakes[i].move();
        active++;
      }
      if (storm.flakes[i].melting) {
        storm.flakes[i].melt();
      }
    }
    if (active<storm.flakesMaxActive) {
      flake = storm.flakes[parseInt(rnd(storm.flakes.length),10)];
      if (flake.active === 0) {
        flake.melting = true;
      }
    }
    if (storm.timer) {
      features.getAnimationFrame(storm.snow);
    }
  };

  this.mouseMove = function(e) {
    if (!storm.followMouse) {
      return true;
    }
    var x = parseInt(e.clientX,10);
    if (x<screenX2) {
      windOffset = -windMultiplier+(x/screenX2*windMultiplier);
    } else {
      x -= screenX2;
      windOffset = (x/screenX2)*windMultiplier;
    }
  };

  this.createSnow = function(limit,allowInactive) {
    var i;
    for (i=0; i<limit; i++) {
      storm.flakes[storm.flakes.length] = new storm.SnowFlake(parseInt(rnd(flakeTypes),10));
      if (allowInactive || i>storm.flakesMaxActive) {
        storm.flakes[storm.flakes.length-1].active = -1;
      }
    }
    storm.targetElement.appendChild(docFrag);
  };

  this.timerInit = function() {
    storm.timer = true;
    storm.snow();
  };

  this.init = function() {
    var i;
    for (i=0; i<storm.meltFrameCount; i++) {
      storm.meltFrames.push(1-(i/storm.meltFrameCount));
    }
    storm.randomizeWind();
    storm.createSnow(storm.flakesMax); // create initial batch
    storm.events.add(window,'resize',storm.resizeHandler);
    storm.events.add(window,'scroll',storm.scrollHandler);
    if (storm.freezeOnBlur) {
      if (isIE) {
        storm.events.add(document,'focusout',storm.freeze);
        storm.events.add(document,'focusin',storm.resume);
      } else {
        storm.events.add(window,'blur',storm.freeze);
        storm.events.add(window,'focus',storm.resume);
      }
    }
    storm.resizeHandler();
    storm.scrollHandler();
    if (storm.followMouse) {
      storm.events.add(isIE?document:window,'mousemove',storm.mouseMove);
    }
    storm.animationInterval = Math.max(20,storm.animationInterval);
    storm.timerInit();
  };

  this.start = function(bFromOnLoad) {
    if (!didInit) {
      didInit = true;
    } else if (bFromOnLoad) {
      // already loaded and running
      return true;
    }
    if (typeof storm.targetElement === 'string') {
      var targetID = storm.targetElement;
      storm.targetElement = document.getElementById(targetID);
      if (!storm.targetElement) {
        throw new Error('Snowstorm: Unable to get targetElement "'+targetID+'"');
      }
    }
    if (!storm.targetElement) {
      storm.targetElement = (document.body || document.documentElement);
    }
    if (storm.targetElement !== document.documentElement && storm.targetElement !== document.body) {
      // re-map handler to get element instead of screen dimensions
      storm.resizeHandler = storm.resizeHandlerAlt;
      //and force-enable pixel positioning
      storm.usePixelPosition = true;
    }
    storm.resizeHandler(); // get bounding box elements
    storm.usePositionFixed = (storm.usePositionFixed && !noFixed && !storm.flakeBottom); // whether or not position:fixed is to be used
    if (window.getComputedStyle) {
      // attempt to determine if body or user-specified snow parent element is relatlively-positioned.
      try {
        targetElementIsRelative = (window.getComputedStyle(storm.targetElement, null).getPropertyValue('position') === 'relative');
      } catch(e) {
        // oh well
        targetElementIsRelative = false;
      }
    }
    fixedForEverything = storm.usePositionFixed;
    if (screenX && screenY && !storm.disabled) {
      storm.init();
      storm.active = true;
    }
  };

  function doDelayedStart() {
    window.setTimeout(function() {
      storm.start(true);
    }, 20);
    // event cleanup
    storm.events.remove(isIE?document:window,'mousemove',doDelayedStart);
  }

  function doStart() {
    if (!storm.excludeMobile || !isMobile) {
      doDelayedStart();
    }
    // event cleanup
    storm.events.remove(window, 'load', doStart);
  }

  // hooks for starting the snow
  if (storm.autoStart) {
    storm.events.add(window, 'load', doStart, false);
  }

  return this;

}(window, document));

</script>


<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<style>
 .loading {
	 position: fixed;
	 height: 100%;
	 width: 100%;
	 top: 0;
	 left: 0;
   right: 0;
	 background: #606060;
	 transition: 0.75s;
	 z-index: 99999;
}
 .loading-title {
	 color: #;
	 margin: 0;
	 position: absolute;
	 top: 50%;
	 left: 50%;
	 transform: translate(-50%, -50%);
}
 .loading-progress {
	 height: 11px;
	 background: #707070;
	 top: -11px;
	 bottom: 0;
	 width: 100%;
	 position: absolute;
	 transition: 0.35s;
	 z-index: 10000000000;
}
  
  [data-theme="dark"] .loading {
	 background: #202020;
}
 [data-theme="dark"] .loading-progress {
	 background: #303003;
}
</style>
<head>
  <div class="loading">
    <div class="loading-title">
      <style>

.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}
</style>
<div class="container">
        <img src="https://github.com/spitriziv/Viatic/blob/main/www/image/Viaticlogononame.png?raw=true"  style="height:200px;position: relative;top: -100px;left: -120px;right: 0;" />
</div>
    <div class="loading-progress"></div>
  </div>
</body>
<script>
  function getRandomArbitrary(min, max) {
  return Math.random() * (max - min) + min;
}

// super simple router - go to page specified in hash, otherwise go to "default"
function router(route) {
  const pageName = route ? route : $(".default.page").attr("data-page-name");
  const $page = $(`[data-page-name="${pageName}"]`);
  $(".page").css("display", "none");
  $("[data-page]").removeClass("active");
  $(`[data-page="${pageName}"]`).addClass("active");
  $page.css("display", "block");
}
router();

// fake loader
let progress = 390;
const fakeLoaderInterval = window.setInterval(function () {
  const $lp = $(".loading-progress");
  progress = progress + getRandomArbitrary(10, 25);
  $lp.css("transform", `translateX(${progress}%)`);

  if (progress >= 75) {
    window.clearInterval(fakeLoaderInterval);
    $lp.css("transform", "translateX(100%)");
    setTimeout(
      () => $(".loading").css("transform", "translateY(calc(100% + 10px))"),
      400
    );
  }
}, getRandomArbitrary(300, 500));

// navigation
$(".main-nav li a").on("click", (e) => {
  const $this = $(e.currentTarget);
  const route = $this.attr("data-page");

  $(".main-nav li a").removeClass("active");
  $this.addClass("active");
  router(route);
});

</script>-->
